
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Cookfront&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="cookfront@gmail.com">
    

    
    <meta name="description" content="Cookfront&apos;s Blog，前端开发，HTML，CSS，JavaScript，jQuery，HTML5，CSS3，Sass Compass，Node.js">
<meta property="og:type" content="website">
<meta property="og:title" content="Cookfront's Blog">
<meta property="og:url" content="http://cookfront.github.io/index.html">
<meta property="og:site_name" content="Cookfront's Blog">
<meta property="og:description" content="Cookfront&apos;s Blog，前端开发，HTML，CSS，JavaScript，jQuery，HTML5，CSS3，Sass Compass，Node.js">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cookfront's Blog">
<meta name="twitter:description" content="Cookfront&apos;s Blog，前端开发，HTML，CSS，JavaScript，jQuery，HTML5，CSS3，Sass Compass，Node.js">

    
    <link rel="alternative" href="/atom.xml" title="Cookfront&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Cookfront&#39;s Blog" title="Cookfront&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Cookfront&#39;s Blog">Cookfront&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:cookfront.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/24/youzan/" title="在有赞的四个月" itemprop="url">在有赞的四个月</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-11-24T03:47:42.000Z" itemprop="datePublished"> 發表於 2015-11-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>回顾四个月前，还在百度上研每天写着重复的代码，每天的日子也只是简单的重复，平淡如水。时间久了，就会觉得无聊了，继续呆下去，也不过是升T，然后继续每天写着重复的代码。走之前经理也以各种涨工资、教育资源、医疗资源来劝说，但内心是真的想走了，继续干下去感觉整个人都要废了，工作是真的很轻松，但自己一直以来是一个闲不住的人，而这样的生活让人觉得不踏实，不充实。</p>
<p>So，就要准备跳槽了，跳槽的时候第一就是选择城市了，可选的杭州与深圳，其实最想去的还是深圳，空气好，气候好，然而看着均价三万一平的房价，想想还是放弃了，内心也是无数个草泥马了=-=。这样也就只有杭州了，杭州房价不高，据说还在降，其他除了堵，各种单行道之外也没有发现其他啥缺点了。选择完城市就是选择公司，为什么选择有赞，是有一次在内推网上看到他们的招聘信息很接地气，看福利也很棒，就了解了一下有赞，第一感觉觉得未来很有前途的，所以这次跳槽也就第一优先选择了有赞，也没有投任何其他杭州的公司。</p>
<p>上面扯了这么多，开始进入正题了。来有赞这四个月确实工作比以前开心了，在这里的不仅仅是工作，生活也与工作融合在一起，工作也确实比以前忙了，更多的是接触到了很多以前没有接触到的技术。</p>
<hr>
<h2 id="公司氛围">公司氛围</h2><p>公司给人的感觉就像是一个伐木累，每个人都是其中的一员，每个月大家会全部聚在一起给这个月的寿星过生日，还有有点黄有点暴力的新人秀。当然不止这些，还有生活小组带你吃带你喝带你玩，各种兴趣小组总有适合你的：游泳、羽毛球、桌上足球，简直是数不胜数了。让我觉得印象最深的是我妈住院那次，HR发消息说有任何需要都可以联系她，不管是钱，其他需要，只要开口，内心真的很感动，从这时就觉得这家公司是可以托付终生的，真的是把每一位员工当作自己的家人去对待。</p>
<p><img src="http://7mnm9p.com1.z0.glb.clouddn.com/1.pic_hd.jpg" alt="enter image description here"></p>
<p>当然福利也是棒棒哒，绝对不比<code>BAT</code>差，每天下午有四五种水果，还有无限量零食，在这变胖应该只是时间问题的啦，过生日呢会根据每个人的性格购买不同的生日礼物，生宝宝了会有宝宝礼。真心的想说行政的妹子真的很贴心，把我们伺候的好好的，每天在写代码的同时，有吃有喝。餐补的话竟然有800，每个月中晚饭吃好喝好应该花完这些钱正好^_^。</p>
<hr>
<h2 id="成长">成长</h2><p>跳槽除了想涨工资之外，当然也希望能在新的团队中不断成长。在有赞的这四个月，自己在慢慢的成长，接触新的领域。</p>
<h3 id="MVC">MVC</h3><p>这边主要使用的框架是<code>Backbone</code>，当然还有当下时髦的<code>React</code>，<code>Webpack</code>，一些内部的工具你还可以尽情发挥。以前在百度使用的是<a href="http://tangram.baidu.com/about" target="_blank" rel="external">Tangram</a>，一个早已不在维护的类似<code>jQuery</code>的库，页面所有的逻辑都写在一起，看着很难受，真是一把辛酸一把累呀。到了这边使用<code>Backbone</code>、<code>React</code>写起来还是很爽的，组件式的开发，以前可能只是学习了下<code>React</code>类似的框架，没有在实际生产环境中用到，而现在这些都已经成为日常每天都要接触的，看看现在的代码也比以前好看了:-)。</p>
<h3 id="性能优化">性能优化</h3><p>在这里还接手了两个性能优化的工作：js延迟加载和商品详情懒加载。</p>
<p>js延迟加载的库已经开源到<code>Github</code>，<a href="https://github.com/youzan/tiny-loader.js" target="_blank" rel="external">tiny-loader.js</a>，用上这个页面的加载速度降了<code>0.21s</code>，这个组件会在页面<code>load</code>事件以后进行静态资源的下载，减少<code>js</code>对页面打开速度的影响，页面有些<code>js</code>或者<code>CSS</code>可能并不需要立即加载出来，可以使用这个组件来延迟<code>js</code>的加载。</p>
<p>商品详情懒加载则是用到了<code>textarea</code>去懒加载HTML，页面加载时并不会商品详情的内容，而是将其用到的<code>html</code>放在<code>textarea</code>标签内，当用户滚动到相应位置时再去将<code>html</code>插入到对应的节点。</p>
<p>之前是做PC端的网页，也没有太多去考虑这方面的性能，而现在做<code>WAP</code>端就不一样了，用户的网络环境可能各不相同，在移动网络下，希望能更快的把内容呈现给用户才是我们的目标。</p>
<h3 id="工程化">工程化</h3><p>目前在做代码规范统一的相关工作，使用到了<code>git</code>的<code>pre-commit</code>钩子，在代码<code>commit</code>之前，调用<code>eslint</code>检测<code>diff</code>文件是否符合代码规范，不符合规范，则不让<code>commit</code>代码。除此这些，还在这边开始接触PHP，虽然只是简单的功能，但是一个好的开头，后面也会不断去深入后端的知识，成为一个全栈工程师。</p>
<hr>
<h2 id="最后">最后</h2><p>最后想说的是：<code>革命尚未胜利，同志仍需努力</code>，后面需要学习的还有很多，踏踏实实的，走好每一步。有你有赞，要来的抓紧啦。</p>
<p>下面就是和有赞的小伙伴一起去参加浙大毅行的合照：</p>
<p><img src="http://7mnm9p.com1.z0.glb.clouddn.com/yixing.jpg" alt="enter image description here"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/生活/">生活</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/生活/">生活</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/24/youzan/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/24/youzan/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/20/javascript-topsort/" title="JavaScript 拓扑排序" itemprop="url">JavaScript 拓扑排序</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-06-20T06:07:42.000Z" itemprop="datePublished"> 發表於 2015-06-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>最近在学习数据结构，就试着用<code>JavaScript</code>来实现一些基本数据结构。本文介绍的主要是拓扑排序<code>JavaScript</code>实现。</p>
<p>拓扑排序是对有向无圈图（DAG）的一种排序，它使得如果存在一条从v<sub>i</sub>到v<sub>j</sub>的路径，那么在排序中v<sub>j</sub>必须出现在v<sub>i</sub>后面。</p>
<blockquote>
<p>如果图是有圈的，那么拓扑排序是不可能的。因为对于两个圈上的两个顶点v和w，v先于w，w又同时先于v。</p>
</blockquote>
<p>拓扑排序的实现原理：</p>
<ol>
<li>从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出</li>
<li>从图中删除该顶点和所有以它为起点的有向边</li>
<li>重复 1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。</li>
</ol>
<p><img src="http://img.blog.csdn.net/20150507001759702" alt="enter image description here"></p>
<p>以上得到拓扑排序后的结果是 <code>{ 1, 2, 4, 3, 5 }</code></p>
<p>下面是<code>JavaScript</code>的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EdgeNode</span> <span class="params">(id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">  <span class="keyword">this</span>.afters = [];</span><br><span class="line">  <span class="keyword">this</span>.indegree = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">topsort</span> <span class="params">(edges)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nodes = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">var</span> queue = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// build data structres</span></span><br><span class="line">  edges.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(edge)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fromEdge = edge[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> fromStr = fromEdge.toString();</span><br><span class="line">    <span class="keyword">var</span> fromNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(fromNode = nodes[fromStr])) &#123;</span><br><span class="line">      fromNode = nodes[fromStr] = <span class="keyword">new</span> EdgeNode(fromEdge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    edge.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(toEdge)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// since from and to are in same array, we'll always see from again, so make sure we skip it..</span></span><br><span class="line">      <span class="keyword">if</span> (toEdge == fromEdge) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> toEdgeStr = toEdge.toString();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!nodes[toEdgeStr]) &#123;</span><br><span class="line">        nodes[toEdgeStr] = <span class="keyword">new</span> EdgeNode(toEdge);</span><br><span class="line">      &#125;</span><br><span class="line">      nodes[toEdgeStr].indegree++;</span><br><span class="line">      fromNode.afters.push(toEdge);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// topsort</span></span><br><span class="line">  <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(nodes);</span><br><span class="line">  keys.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes[key].indegree === <span class="number">0</span>) &#123;</span><br><span class="line">      queue.push(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">while</span> (queue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> vertex = queue.shift();</span><br><span class="line">    result.push(nodes[vertex].id);</span><br><span class="line"></span><br><span class="line">    nodes[vertex].afters.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(after)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> afterStr = after.toString();</span><br><span class="line"></span><br><span class="line">      nodes[afterStr].indegree--;</span><br><span class="line">      <span class="keyword">if</span> (nodes[afterStr].indegree === <span class="number">0</span>) &#123;</span><br><span class="line">        queue.push(afterStr);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> edges = [</span><br><span class="line">    [<span class="string">'two'</span>, <span class="string">'three'</span>],</span><br><span class="line">    [<span class="string">'four'</span>, <span class="string">'six'</span>],</span><br><span class="line">    [<span class="string">'one'</span>, <span class="string">'three'</span>],</span><br><span class="line">    [<span class="string">'two'</span>, <span class="string">'four'</span>],</span><br><span class="line">    [<span class="string">'six'</span>, <span class="string">'nine'</span>],</span><br><span class="line">    [<span class="string">'five'</span>, <span class="string">'seven'</span>],</span><br><span class="line">    [<span class="string">'five'</span>, <span class="string">'eight'</span>],</span><br><span class="line">    [<span class="string">'five'</span>, <span class="string">'nine'</span>],</span><br><span class="line">    [<span class="string">'seven'</span>, <span class="string">'eight'</span>],</span><br><span class="line">    [<span class="string">'eight'</span>, <span class="string">'nine'</span>],</span><br><span class="line">    [<span class="string">'one'</span>, <span class="string">'two'</span>],</span><br><span class="line">    [<span class="string">'four'</span>, <span class="string">'five'</span>],</span><br><span class="line">    [<span class="string">'four'</span>, <span class="string">'six'</span>],</span><br><span class="line">    [<span class="string">'three'</span>, <span class="string">'six'</span>],</span><br><span class="line">    [<span class="string">'six'</span>, <span class="string">'seven'</span>],</span><br><span class="line">    [<span class="string">'three'</span>, <span class="string">'four'</span>]</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> sorted = topsort(edges);</span><br><span class="line"><span class="built_in">console</span>.log(sorted);</span><br></pre></td></tr></table></figure>
<p>以上参考链接：</p>
<ul>
<li><a href="https://github.com/samuelneff/topsort/blob/master/lib/topsort.js" target="_blank" rel="external">samuelneff/topsort</a></li>
<li><a href="http://songlee24.github.io/2015/05/07/topological-sorting/" target="_blank" rel="external">拓扑排序（Topological Sorting）</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScript/">JavaScript</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/20/javascript-topsort/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/06/20/javascript-topsort/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/16/javascript-sort/" title="JavaScript实现数据结构中的排序算法" itemprop="url">JavaScript实现数据结构中的排序算法</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-06-16T03:07:42.000Z" itemprop="datePublished"> 發表於 2015-06-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文主要是用<code>JavaScript</code>实现数据结构中的各种排序算法，例如：插入排序<br>、希尔排序、合并排序等。</p>
<h2 id="插入排序">插入排序</h2><p>插入排序应该算是最简单和容易理解的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。具有<code>n</code>个元素时它需要经过<code>n-1</code>趟排序。对于<code>p = 1</code>到<code>p = n-1</code>趟，插入排序保证从位置<code>0</code>到位置<code>p</code>上的元素为已排序状态。它就是基于这个事实来排序的。</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/0/0f/Insertion-sort-example-300px.gif/220px-Insertion-sort-example-300px.gif" alt="enter image description here"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span> <span class="params">(arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1~n-1趟排序</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = arr[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; tmp; j--) &#123;</span><br><span class="line">      arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">12</span>, <span class="number">290</span>, <span class="number">219</span>, <span class="number">278</span>, <span class="number">21</span>, <span class="number">43</span>, <span class="number">89</span>, <span class="number">78</span>, <span class="number">4432</span>];</span><br><span class="line"><span class="built_in">console</span>.log(insertSort(arr));</span><br></pre></td></tr></table></figure>
<p>如果目标是把<code>n</code>个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需<code>(n-1)</code>次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有<code>n(n-1)/2</code>次。插入排序的赋值操作是比较操作的次数减去(n-1)次。平均来说插入排序算法复杂度为<code>O(n2)</code>。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。</p>
<h2 id="希尔排序">希尔排序</h2><p>希尔排序的名称源自于它的发明者<code>Donald Shell</code>。它又称之为<code>缩小增量排序</code>。它其实是插入排序的一种更高效的版本。</p>
<p>希尔排序的原理是使用一个增量序列：h<sub>1</sub>、h<sub>2</sub>、…、h<sub>n</sub>。希尔排序的原理是在使用增量h<sub>k</sub>的一趟排序之后，对于每一个i我们有A[i] ≤ A[i + h<sub>k</sub>]，所有相隔h<sub>k</sub>的元素都被排序。此时称文件为h<sub>k</sub>-排序。但是对于不同的增量序列，排序的性能也会有所影响。我们一般使h<sub>n</sub> = Math.floor(N / 2)和h<sub>k</sub>=Math.floor(h<sub>k-1</sub> / 2)。算法实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span> <span class="params">(arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 增量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> increment = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>); increment &gt; <span class="number">0</span>; increment = <span class="built_in">Math</span>.floor(increment / <span class="number">2</span>)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = increment; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> tmp = arr[i];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &gt;= increment; j -= increment) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; arr[j - increment]) &#123;</span><br><span class="line">          arr[j] = arr[j - increment];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">12</span>, <span class="number">290</span>, <span class="number">219</span>, <span class="number">278</span>, <span class="number">21</span>, <span class="number">43</span>, <span class="number">89</span>, <span class="number">78</span>, <span class="number">4432</span>];</span><br><span class="line"><span class="built_in">console</span>.log(shellSort(arr));</span><br></pre></td></tr></table></figure>
<h2 id="堆排序">堆排序</h2><p>二叉堆我们可以利用数组来实现，要进行排序，我们第一步时执行建堆操作，然后我们再依次执行<code>deleteMin</code>操作就可以得到我们的排好序的元素。我们可以使用最小堆，每次<code>deleteMin</code>时向一个临时数组中插入元素。这种情况的问题是多了一倍的空间需求。为了避免使用第二个数组，在每次<code>deleteMin</code>之后，堆缩小1，位于堆中最后的单元就可以用于存放刚刚删除的元素。但这样元素会按递减的顺序排列。为了达到递增的效果，我们这里要使用最大堆。</p>
<p>下面是<code>js</code>实现的堆排序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leftChild</span> <span class="params">(i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span> <span class="params">(arr, i, j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = arr[i];</span><br><span class="line">  arr[i] = arr[j];</span><br><span class="line">  arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">precDown</span> <span class="params">(arr, i, len)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = i;</span><br><span class="line">  <span class="keyword">var</span> child;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (tmp = arr[index]; leftChild(index) &lt; len; index = child) &#123;</span><br><span class="line">    child = leftChild(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child !== len - <span class="number">1</span> &amp;&amp; arr[child + <span class="number">1</span>] &gt; arr[child]) &#123;</span><br><span class="line">      child++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tmp &lt; arr[child]) &#123;</span><br><span class="line">      arr[index] = arr[child];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[index] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span> <span class="params">(arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// build max heap</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    precDown(arr, i, len)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// delete max element</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    swap(arr, <span class="number">0</span>, i);</span><br><span class="line">    precDown(arr, <span class="number">0</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">42</span>, <span class="number">53</span>, <span class="number">2432</span>, <span class="number">422</span>, <span class="number">5443</span>, <span class="number">89</span>];</span><br><span class="line"><span class="built_in">console</span>.log(heapSort(arr));</span><br></pre></td></tr></table></figure>
<p>堆排序的算法复杂度是<code>O(NlogN)</code></p>
<h2 id="归并排序">归并排序</h2><p>归并排序其实使用到了算法设计思想里面的分治法，分而治之。分治法是按照以下方案来工作的：</p>
<ol>
<li>将问题的实例划分为同一问题的几个较小的实例，最好拥有同样的规模</li>
<li>对这些较小的实例求解</li>
<li>如果必要的话，合并这些较小问题的解，以得到原始问题的解</li>
</ol>
<p>归并排序的思想就是将需要排序的数组<code>A[0...n-1]</code>一分为二，<code>A[0...Math.floor(n/2)-1]</code>和<code>A[Math.floor(n - 1)...n-1]</code>，并对每个子数组递归排序，然后将这两个排好序的子数组合并为一个有序数组。归并排序最主要的部分就是<code>merge</code>过程。下面看<code>js</code>实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span> <span class="params">(left, right)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">var</span> leftIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> rightIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (leftIndex &lt; left.length &amp;&amp; rightIndex &lt; right.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[leftIndex] &lt; right[rightIndex]) &#123;</span><br><span class="line">      result.push(left[leftIndex++]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(right[rightIndex++]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span> <span class="params">(arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> left = arr.slice(<span class="number">0</span>, middle);</span><br><span class="line">  <span class="keyword">var</span> right = arr.slice(middle);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">21</span>, <span class="number">53</span>, <span class="number">643</span>, <span class="number">654</span>, <span class="number">24</span>, <span class="number">892</span>, <span class="number">5338</span>];</span><br><span class="line"><span class="built_in">console</span>.log(mergeSort(arr));</span><br></pre></td></tr></table></figure>
<p>归并算法的运行时间为<code>O(NlogN)</code>，但是它很难用于主存排序，主要问题在于合并两个排序的表需要线性附加内存，在整个算法中还要将数据拷贝到临时数组再拷贝回来这样一些附加的工作，其结果严重放慢了排序的速度。</p>
<h2 id="快速排序">快速排序</h2><p>正如它的名字，快速排序是在时间中最快的已知排序算法，它的平均运行时间是O(NlogN)。快速排序也是一种分治的递归算法。将数组S排序的基本算法由下列简单的四步组成：</p>
<ol>
<li>如果S中元素个数是0或1，则返回</li>
<li>取S中任一元素<code>v</code>，称之为<code>枢纽元</code></li>
<li>将<code>S - {v}</code>分成两个不相交的集合：S<sub>1</sub> = {x∈S - {v} | x ≤ v}和S<sub>2</sub> = {x∈S - {v} | x ≥ v}</li>
<li>返回{quicksort(S<sub>1</sub>)}，继续v，继而quicksort(S<sub>2</sub>)</li>
</ol>
<p>由于对枢纽元的处理会导致第三步中的分割不唯一，因此，我们希望把等于枢纽元的大约一半的关键字分到S<sub>1</sub>中，而另外一半分到S<sub>2</sub>中，那怎么去选择一个好的枢纽元呢？</p>
<h3 id="选取枢纽元">选取枢纽元</h3><h4 id="一种错误的方法">一种错误的方法</h4><p>通常的，没有经过充分考虑的选择是将第一个元素用作枢纽元。如果输入是随机的，那么这是可以接受的，但是如果输入是预排序或是反序的，那么这样的枢纽元就会产生一个劣质的分割，因为所有的元素不是都被划入S<sub>1</sub>就是被划入S<sub>2</sub>。</p>
<h4 id="一种安全的作法">一种安全的作法</h4><p>一种安全的方针是随机选取枢纽元。但是另一方面，随机数的生成一般是昂贵的，根本减少不了算法奇遇部分的平均运行时间。</p>
<h4 id="三数中值分割法">三数中值分割法</h4><p>一组N个数的中值是第<code>Math.ceil(N/2)</code>个最大的数。枢纽元的最好的选择是数组的中值。不幸的是，这很难算出，且会减慢快速排序的速度。因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为枢纽元。例如，输入为<code>8, 1, 4, 9, 6, 3, 5, 2, 7, 0</code>，它的左边元素是8，右边元素是0，中心位置为<code>Math.floor((left + right) / 2)</code>上的元素是6，于是枢纽元<code>v=6</code>。</p>
<p>下面来看看具体实现了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span> <span class="params">(arr, i, j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = arr[i];</span><br><span class="line">  arr[i] = arr[j];</span><br><span class="line">  arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">median3</span> <span class="params">(arr, left, right)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> center = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (arr[left] &gt; arr[center]) &#123;</span><br><span class="line">    swap(arr, left, center);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[left] &gt; arr[right]) &#123;</span><br><span class="line">    swap(arr, left, right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[center] &gt; arr[right]) &#123;</span><br><span class="line">    swap(arr, center, right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  swap(arr, center, right - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> arr[right - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">qSort</span> <span class="params">(arr, left, right)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 枢纽元</span></span><br><span class="line">  <span class="keyword">var</span> pivot = median3(arr, left, right);</span><br><span class="line">  <span class="keyword">var</span> i = left;</span><br><span class="line">  <span class="keyword">var</span> j = right - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[++i] &lt; pivot) &#123;&#125;</span><br><span class="line">    <span class="keyword">while</span> (arr[--j] &gt; pivot) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">      swap(arr, i, j);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(arr, i, right - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (left &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">    qSort(arr, left, i - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">    qSort(arr, i + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span> <span class="params">(arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> qSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">21</span>, <span class="number">53</span>, <span class="number">643</span>, <span class="number">654</span>, <span class="number">24</span>, <span class="number">892</span>, <span class="number">5338</span>];</span><br><span class="line"><span class="built_in">console</span>.log(quickSort(arr));</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScript/">JavaScript</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/16/javascript-sort/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/06/16/javascript-sort/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/07/es6-object/" title="每天学点ES6－对象" itemprop="url">每天学点ES6－对象</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-06-07T09:59:42.000Z" itemprop="datePublished"> 發表於 2015-06-07</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文内容来自于：<a href="https://leanpub.com/understandinges6/read#leanpub-auto-objectis" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-objectis</a>。内容有删减，有不懂的地方可以看原文哟。</p>
<p><code>ES6</code>对对象也进行了很多扩展，比如属性和方法的简写方式、<code>Object.assign()</code>等。下面来一一介绍<code>ES6</code>中对象的扩展。</p>
<h2 id="属性和方法的简写">属性和方法的简写</h2><p>在<code>ES5</code>或者更早时，对象直接量其实就是简单的<code>名－值</code>对集合，这意味着当属性值被初始化时可能会有一些重复。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span><span class="params">(name, age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        age: age</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createPerson()</code>创建了一个对象，这个对象的属性名称和函数的参数名称是一样的。其结果是导致了<code>name</code>和<code>age</code>的复制，尽管每个表示一个过程的不同方面。</p>
<p>在<code>ES6</code>中，当属性名和局部变量名是一样时，我们可以省略它后面的冒号和值。例如，上面的例子可以重写为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span><span class="params">(name, age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name,</span><br><span class="line">        age</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个对象直接量的一个属性只有名称没有值时，<code>JavaScript</code>引擎会在周围作用域中寻找和属性名有相同名称的变量。如果找到，值就被赋给对象直接量中相同名的属性。所以在这个例子中，对象直接量的属性<code>name</code>被赋值为局部变量<code>name</code>的值。</p>
<p>除了属性可以简写外，方法也是可以简写的。在<code>ES5</code>或之前，我们定义方法必须像下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但在<code>ES6</code>中，通过省略冒号和<code>function</code>关键字，使语法变得更加简洁。你可以重写之前的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="计算属性名">计算属性名</h2><p>在<code>JavaScript</code>中，我们定义属性时，有两种方式：中括号<code>[]</code>或<code>.</code>的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">obj.foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">obj[<span class="string">'a'</span>+<span class="string">'bc'</span>] = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p><code>.</code>运算符具有很大的局限性，比如<code>first name</code>这种属性只能通过中括号的方式来定义。中括号的方式允许我们使用变量或者在使用标识符时会导致语法错误的字符串直接量来定义属性。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;,</span><br><span class="line">    lastName = <span class="string">"last name"</span>;</span><br><span class="line"></span><br><span class="line">person[<span class="string">"first name"</span>] = <span class="string">"Nicholas"</span>;</span><br><span class="line">person[lastName] = <span class="string">"Zakas"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"first name"</span>]);      <span class="comment">// "Nicholas"</span></span><br><span class="line"><span class="built_in">console</span>.log(person[lastName]);          <span class="comment">// "Zakas"</span></span><br></pre></td></tr></table></figure>
<p>这两种方式只能通过中括号的方式来定义的。在<code>ES5</code>中，你可以在对象直接量中使用字符串直接量作为属性，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="string">"first name"</span>: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"first name"</span>]);      <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>
<p>但是当我们的属性名存在一个变量中或者需要计算时，使用对象直接量是无法定义属性的。但是在<code>ES6</code>中计算属性名语法，同样是通过中括号的方式。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lastName = <span class="string">"last name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="string">"first name"</span>: <span class="string">"Nicholas"</span>,</span><br><span class="line">    [lastName]: <span class="string">"Zakas"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"first name"</span>]);      <span class="comment">// "Nicholas"</span></span><br><span class="line"><span class="built_in">console</span>.log(person[lastName]);          <span class="comment">// "Zakas"</span></span><br></pre></td></tr></table></figure>
<p>在对象直接量中的中括号表明属性名是需要被计算的，它的内容被计算为字符串。</p>
<h2 id="Object-assign()">Object.assign()</h2><p>对于对象构成最流行的模式之一可能是<code>mixin</code>，一个对象从另一个对象中接收属性和方法。许多<code>JavaScript</code>库都有一个类似下面的<code>mixin</code>方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span><span class="params">(receiver, supplier)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(supplier).forEach(<span class="function"><span class="keyword">function</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">        receiver[key] = supplier[key];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> receiver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mixin()</code>方法遍历<code>supplier</code>对象的自有属性，并将其拷贝到<code>receiver</code>。这就使得<code>receiver</code>没有通过继承就获得了新的行为。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventTarget</span><span class="params">()</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">EventTarget.prototype = &#123;</span><br><span class="line">    constructor: EventTarget,</span><br><span class="line">    emit: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123; <span class="comment">/*...*/</span> &#125;,</span><br><span class="line">    on: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line">mixin(myObject, EventTarget.prototype);</span><br><span class="line"></span><br><span class="line">myObject.emit(<span class="string">"somethingChanged"</span>);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>myObject</code>从<code>EventTarget.prototype</code>接收了新的行为。</p>
<p>为此在<code>ES6</code>中添加了<code>Object.assign()</code>，它和<code>mixin()</code>的行为一样。但不同之处在于，<code>mixin()</code>使用赋值运算符<code>=</code>来拷贝，它不能拷贝访问属性<code>accessor properties</code>到接受者作为访问属性。<code>Object.assign()</code>是可以做到这点的。</p>
<p>我们可以使用<code>Object.assign()</code>重写上面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventTarget</span><span class="params">()</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">EventTarget.prototype = &#123;</span><br><span class="line">    constructor: EventTarget,</span><br><span class="line">    emit: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123; <span class="comment">/*...*/</span> &#125;,</span><br><span class="line">    on: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(myObject, EventTarget.prototype);</span><br><span class="line"></span><br><span class="line">myObject.emit(<span class="string">"somethingChanged"</span>);</span><br></pre></td></tr></table></figure>
<p><code>Object.assign()</code>可以接受任意多个提供属性的对象，接收者则按顺序从提供者接收属性，这可能会导致第二个提供者会覆盖第一个提供者提供给接收者的属性。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiver = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(receiver, &#123;</span><br><span class="line">        type: <span class="string">"js"</span>,</span><br><span class="line">        name: <span class="string">"file.js"</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        type: <span class="string">"css"</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(receiver.type);     <span class="comment">// "css"</span></span><br><span class="line"><span class="built_in">console</span>.log(receiver.name);     <span class="comment">// "file.js"</span></span><br></pre></td></tr></table></figure>
<p>下面再看看<code>Object.assign()</code>用于访问属性的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiver = &#123;&#125;,</span><br><span class="line">    supplier = &#123;</span><br><span class="line">        get name() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"file.js"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(receiver, supplier);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(receiver, <span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value);      <span class="comment">// "file.js"</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.get);        <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="重复对象字面量属性">重复对象字面量属性</h2><p>在<code>ES5</code>的严格模式中，引入了一个对重复对象字面量属性的检查，它会抛出一个错误如果发现了重复属性。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    name: <span class="string">"Greg"</span>        <span class="comment">// syntax error in ES5 strict mode</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是在<code>ES6</code>中，重复属性检查已经被移除了。不管是<code>strict</code>和<code>nostrict</code>模式都不会取检查重复属性，它会取给定名称的最后一个属性作为实际值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    name: <span class="string">"Greg"</span>        <span class="comment">// not an error in ES6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name);       <span class="comment">// "Greg"</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>person.name</code>的值为<code>Greg</code>，因为它是赋给该属性的最后一个值。</p>
<h2 id="改变原型">改变原型</h2><p>原型是<code>JavaScript</code>继承时的基础，因此，<code>ES6</code>使得原型更强大。<code>ES5</code>中添加了<code>Object.getPrototypeOf()</code>方法来检索任何给定对象的原型。在<code>ES6</code>中添加了相反操作的方法，<code>Object.setPrototypeOf()</code>，它允许我们改变任何给定对象的原型。</p>
<p>在<code>ES6</code>之前，我们无法在对象创建后来改变其原型，<code>ES6</code>的<code>Object.setPrototypeOf()</code>打破了这一情况。<code>Object.setPrototypeOf()</code>接收两个参数，第一个参数为要改变原型的对象，第二个参数为被设置为第一个对象的原型的对象。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Woof"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prototype is person</span></span><br><span class="line"><span class="keyword">let</span> friend = <span class="built_in">Object</span>.create(person);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting());                      <span class="comment">// "Hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set prototype to dog</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting());                      <span class="comment">// "Woof"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog);     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这段代码中，我们有两个基本对象：<code>person</code>和<code>dog</code>，两个对象都有一个<code>getGreeting()</code>的方法，对象<code>friend</code>首先从<code>person</code>中继承，意味着调用<code>getGreeting()</code>会输出<code>Hello</code>。当我们改变<code>friend</code>的原型为<code>dog</code>时，此时<code>getGreeting()</code>输出<code>Woof</code>。</p>
<p>一个对象的原型的实际值是存储在一个内部属性<code>[[Prototype]]</code>中。<code>Object.getPrototypeOf()</code>方法返回存储在<code>[[Prototype]]</code>的值，而<code>Object.setPrototypeOf()</code>改变存储在<code>[[Prototype]]</code>上的值。</p>
<h2 id="super引用"><code>super</code>引用</h2><p>在<code>ES6</code>中我们可以通过<code>super</code>引用来调用原型上的方法。例如，如果你想覆盖一个对象实例上的方法，但它同样需要去调用相同名字的原型方法，在<code>ES5</code>中我们可以通过以下方式来实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Woof"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prototype is person</span></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    __proto__: person,</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="comment">// same as this.__proto__.getGreeting.call(this)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).getGreeting.call(<span class="keyword">this</span>) + <span class="string">", hi!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting());                      <span class="comment">// "Hello, hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.__proto__ === person);               <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set prototype to dog</span></span><br><span class="line">friend.__proto__ = dog;</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting());                      <span class="comment">// "Woof, hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.__proto__ === dog);                  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog);     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到是通过<code>Object.getPrototypeOf(this).getGreeting.call(this)</code>的方式来实现的，但是在<code>ES6</code>中，我们不用这么复杂，只需要<code>super</code>就行了，下面是重写后的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    __proto__: person,</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="comment">// same as Object.getPrototypeOf(this).getGreeting.call(this)</span></span><br><span class="line">        <span class="comment">// or this.__proto__.getGreeting.call(this)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上就是本文的全部内容啦。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScript/">JavaScript</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/07/es6-object/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/06/07/es6-object/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/06/es6-function/" title="每天学点ES6－函数" itemprop="url">每天学点ES6－函数</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-06-06T01:59:42.000Z" itemprop="datePublished"> 發表於 2015-06-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文翻译自：<a href="https://leanpub.com/understandinges6/read#leanpub-auto-objectis" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-objectis</a>，内容有删减，仅作为阅读笔记。</p>
<p><code>ES6</code>中的函数增加了很多新特性，使得在<code>JavaScript</code>中编程不容易出错，且比以往任何时候还要强大。<code>ES6</code>的函数主要带来了以下扩展：参数的默认值、<code>rest</code>参数、解构参数、扩展（Spread）运算符、<code>name</code>属性、箭头函数等。下面就一一介绍。</p>
<h2 id="参数默认值">参数默认值</h2><p>在<code>JavaScript</code>中，我们可以给函数传入任意多个参数，而不需要管它实际定义的形参个数。这允许我们定义的函数可以处理参数不同的情况，我们可以为没有指定的参数默认值。在<code>ES5</code>中我们可以经常看到下面这样的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span><span class="params">(url, timeout, callback)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    timeout = timeout || <span class="number">2000</span>;</span><br><span class="line">    callback = callback || <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the rest of the function</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>timeout</code>和<code>callback</code>都是可选的，因为在没有传相应的参数时，它们有默认值<code>2000</code>和<code>function() {}</code>。我们经常用这种方式来实现默认参数。</p>
<p><code>ES6</code>中对函数进行了扩展，添加了<code>参数默认值</code>，在没有传入相应参数时，会使用你在定义函数时给定的默认值，而不是像<code>ES5</code>中那样对每个参数还要做一次判断。在<code>ES6</code>中我们可以这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function makeRequest(url, timeout = 2000, callback = function() &#123;&#125;) &#123;</span><br><span class="line"></span><br><span class="line">    // the rest of the function</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样只有我们的第一个参数是期望传入的，而其他两个参数都有默认值，这使得函数更加简洁，我们不需要去判断是否某个参数没有被传入，就像<code>timeout = timeout || 2000;</code>这样。当<code>makeRequest()</code>调用时传入了所有的三个参数时，默认参数就不会被使用了。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uses default timeout and callback</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// uses default callback</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// doesn't use defaults</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>, <span class="number">500</span>, <span class="function"><span class="keyword">function</span><span class="params">(body)</span> </span>&#123;</span><br><span class="line">    doSomething(body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>任何参数有默认值时我们认为它是可选的，而那些没有默认值的参数我们认为是必须的参数。</p>
<h2 id="Rest参数">Rest参数</h2><p>上面也说到<code>JavaScript</code>中是可以传入任意多个参数，有时候我们没有必要指定所有的参数。在以前我们可以通过<code>arguments</code>函数的所有参数，虽然这在大多数情况下可以工作的很好，但是还是会有一点小累赘。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = first,</span><br><span class="line">        i = <span class="number">1</span>,</span><br><span class="line">        len = <span class="built_in">arguments</span>.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">        result += <span class="built_in">arguments</span>[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数将所有传入的参数相加，例如我们可以<code>sum(1)</code>或者<code>sum(1, 2, 3, 4)</code>都是可以的。但这个函数我们有几件事情要注意。第一、函数不能明显的看出可以处理一个以上的参数。第二、因为我们指定了一个<code>first</code>参数，那我们就必须从<code>arguments</code>的索引1开始，而不是索引0。当然记住正确的索引并不是很困难，但是还是需要我们关注的一件事。<code>ES6</code>为我们提供了<code>rest</code>参数来解决这个问题。</p>
<p><code>rest</code>参数由三个<code>.</code>加上参数名字来表示，那个参数名字成为一个数组包含了参数的其余部分。例如，<code>sum()</code>函数可以使用<code>rest</code>参数重写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(first, ...numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = first,</span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        len = numbers.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">        result += numbers[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个版本的函数中，我们可以看到<code>numbers</code>包含了除<code>first</code>参数之外的剩余参数。这意味着我们可以从<code>0</code>开始遍历<code>numbers</code>，而不需要有任何顾虑。我们也可以很容易的看出函数可以处理任意多个参数。</p>
<p>对于<code>rest</code>参数有一个限制就是，在<code>rest</code>参数后不能再跟其他函数，否则会语法错误。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Syntax error: Can't have a named parameter after rest parameters</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(first, ...numbers, last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = first,</span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        len = numbers.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">        result += numbers[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参数解构">参数解构</h2><p>在前面我们学过变量解构，解构同样也可以使用在函数的参数中。</p>
<p>通常我们会使用一个<code>options</code>对象作为一个参数来代替传入多个参数，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span><span class="params">(name, value, options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    options = options || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> secure = options.secure,</span><br><span class="line">        path = options.path,</span><br><span class="line">        domain = options.domain,</span><br><span class="line">        expires = options.expires;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>, &#123;</span><br><span class="line">    secure: <span class="literal">true</span>,</span><br><span class="line">    expires: <span class="number">60000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>除了<code>name</code>和<code>value</code>是必须的之外，其他数据没有顺序优先级，这里我们使用了一个<code>options</code>对象来代替，而不是额外的命名参数。这种方式是<code>OK</code>的，但是给我们的函数带来了不透明性。</p>
<p>使用参数解构，之前的函数可以被重写为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span><span class="params">(name, value, &#123; secure, path, domain, expires &#125;)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>, &#123;</span><br><span class="line">    secure: <span class="literal">true</span>,</span><br><span class="line">    expires: <span class="number">60000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个例子和前面的不同之处在于使用了参数解构取出了必要的数据。这样使得更清楚的知道需要什么样的参数。参数解构和变量解构一样，如果没有传入相应数据时，其值为<code>undefined</code>。</p>
<p>有一点需要注意的是，当我们在上面的函数中没有传入第三个参数时，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error!</span></span><br><span class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>);</span><br></pre></td></tr></table></figure>
<p>这个代码是会报错的，在内部执行时其实是像下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span><span class="params">(name, value, options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> &#123; secure, path, domain, expires &#125; = options;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为变量解构时，当右边的表达式为<code>null</code>或<code>undefined</code>时是会报错的。不过我们可以通过传入一个默认的空对象来解决这个问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span><span class="params">(name, value, &#123; secure, path, domain, expires &#125; = &#123;&#125;)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展运算符">扩展运算符</h2><p>扩展运算符和<code>rest</code>参数正好相反，<code>rest</code>参数允许我们将多个独立的参数合并成一个数组，而扩展运算符允许我们将一个数组分割，每个元素作为独立参数传入到函数中。我们可以考虑<code>Math.max()</code>方法，我们可以传入任意多个参数，然后返回最大的那个参数值。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value1 = <span class="number">25</span>,</span><br><span class="line">    value2 = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(value1, value2));      <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<p>当只有几个参数时我们很好处理，但是当我们的值存在一个数组中时我们应该怎么办呢？在<code>ES5</code>中我们可以通过<code>apply</code>来操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values));  <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<p><code>ES6</code>的扩展运算符使这种情况变得更加简单。你可以通过在数组名前面加上<code>...</code>传入函数中，就像<code>rest</code>参数那样。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// equivalent to</span></span><br><span class="line"><span class="comment">// console.log(Math.max(25, 50, 75, 100));</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values));           <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<p>你也可以混合使用扩展运算符和其他参数。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [-<span class="number">25</span>, -<span class="number">50</span>, -<span class="number">75</span>, -<span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values, <span class="number">0</span>));        <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h2 id="name属性"><code>name</code>属性</h2><p><code>ES6</code>为所有函数添加了一个<code>name</code>属性，在<code>ES6</code>的程序中所有的函数的<code>name</code>属性都确保有一个合适的值。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doAnotherThing = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doSomething.name);          <span class="comment">// "doSomething"</span></span><br><span class="line"><span class="built_in">console</span>.log(doAnotherThing.name);       <span class="comment">// "doAnotherThing"</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，<code>doSomething()</code>函数的<code>name</code>属性值为<code>doSomething</code>，因为他是一个函数声明。在匿名函数表达式中，<code>doAnotherThing()</code>的<code>name</code>属性值为<code>doAnotherThing</code>。</p>
<p>下面看个更详细的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    get firstName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Nicholas"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doSomething.name);      <span class="comment">// "doSomethingElse"</span></span><br><span class="line"><span class="built_in">console</span>.log(person.sayName.name);   <span class="comment">// "sayName"</span></span><br><span class="line"><span class="built_in">console</span>.log(person.firstName.name); <span class="comment">// "get firstName"</span></span><br></pre></td></tr></table></figure>
<p>对于函数名还有几种特殊情况。对于使用<code>bind()</code>创建的函数会在它们的函数名前加上<code>bound</code>前缀。对于使用<code>Function</code>构造函数创建的函数它的名字为<code>anonymous</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doSomething.bind().name);   <span class="comment">// "bound doSomething"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>()).name);     <span class="comment">// "anonymous"</span></span><br></pre></td></tr></table></figure>
<h2 id="new-target，[[Call]]和[[Construct]]"><code>new.target</code>，<code>[[Call]]</code>和<code>[[Construct]]</code></h2><p>在<code>ES5</code>甚至更早，函数服务于双重目的，通过<code>new</code>来调用或没有<code>new</code>。当使用<code>new</code>时，函数内的<code>this</code>值是返回的新对象。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> notAPerson = Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person);        <span class="comment">// "[Object object]"</span></span><br><span class="line"><span class="built_in">console</span>.log(notAPerson);    <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure>
<p>当没有使用<code>new</code>调用<code>Person()</code>时，返回<code>undefined</code>。这里很明显的是这段代码的意图是使用<code>Person</code>和<code>new</code>来创建一个对象。在<code>ES6</code>中，在函数双重角色的困惑上做了一些改变。</p>
<p>第一、规范定义了两个不同的仅在内部使用的方法，每个函数都有：<code>[[Call]]</code>和<code>[[Construct]]</code>。当一个函数没有通过<code>new</code>来调用时，<code>[[Call]]</code>方法会被执行。当一个函数通过<code>new</code>来调用时，<code>[[Construct]]</code>被调用。<code>[[Construct]]</code>方法有责任创建一个新的对象。被称之为<code>new target</code>，然后执行函数体，<code>this</code>的值被设置为<code>new target</code>。有一个<code>[[Construct]]</code>方法的函数被称之为<code>构造函数</code>。</p>
<blockquote>
<p>要注意的是不是所有的函数都有<code>[[Construct]]</code>，也不是所有的函数能通过<code>new</code>来调用。箭头函数，将在后面介绍到，没有<code>[[Construct]]</code>方法。</p>
</blockquote>
<p>在<code>ES5</code>中，最流行的方式来决定一个函数能否通过<code>new</code>来调用是使用<code>instanceof</code>操作符。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;   <span class="comment">// using new</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> notAPerson = Person(<span class="string">"Nicholas"</span>);  <span class="comment">// throws error</span></span><br></pre></td></tr></table></figure>
<p>在这里，<code>this</code>的值会被检查是否为构造函数的实例，如果是的话，它继续正常执行。如果不是，就会抛出一个异常。这个能工作是因为<code>[[Construct]]</code>方法创建了<code>Person</code>的一个新实例，并将它赋给了<code>this</code>。不幸的是，这种方式不是完全可信的，<code>this</code>的值可以不通过<code>new</code>的方式也可以为<code>Person</code>的实例，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;   <span class="comment">// using new</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">"Michael"</span>);    <span class="comment">// works!</span></span><br></pre></td></tr></table></figure>
<p>我们这里通过<code>Person.call()</code>，并且传递<code>person</code>对象作为第一个参数，这就使得无法区分<code>this</code>是通过<code>new</code>创建的还是其他方式。</p>
<p>为了解决这个问题，<code>ES6</code>引入了<code>new.target</code>元属性。当一个函数的<code>[[Construct]]</code>被调用，<code>new.target</code>会成为新创建对象的实例，这个值也会在函数内成为<code>this</code>的值。如果<code>[[Call]]</code>被执行，<code>new.target</code>为<code>undefined</code>。这意味着我们现在可以通过检查<code>new.target</code>是否被定义安全的检查函数是否是通过<code>new</code>的方式被调用。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;   <span class="comment">// using new</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">"Michael"</span>);    <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<h2 id="箭头函数">箭头函数</h2><p><code>ES6</code>中新添加了一个箭头函数，就如它的名字，函数通过一种新的语法，使用箭头<code>=&gt;</code>来定义。然而，箭头函数在有些方面和传统的<code>JavaScript</code>函数是不同的：</p>
<ul>
<li>词法的<code>this</code>绑定：在该函数内的<code>this</code>是通过定义箭头函数的地方决定，而不是使用它的地方决定。</li>
<li>不能当作构造函数：箭头函数没有<code>[[Construct]]</code>方法，因此它不能作为构造函数。当箭头函数与<code>new</code>一起使用时将会抛出异常。</li>
<li>不可以改变<code>this</code>值：在函数内的<code>this</code>的值是不能改变的，它在函数的整个生命周期中保持相同的值。</li>
<li>没有<code>arguments</code>对象：你不能通过<code>arguments</code>对象来获取参数，你必须使用命名参数或者<code>rest</code>参数等。</li>
</ul>
<p>其中有一些原因来表明这些不同为什么存在。首先，<code>this</code>的绑定在<code>JavaScript</code>是一个常见的错误根源。在一个函数内对<code>this</code>值的跟踪是非常容易丢失的，这可能会导致意想不到的后果。第二，通过限制箭头函数在执行代码时只有单一的<code>this</code>值，<code>JavaScript</code>引擎能更好的优化操作。</p>
<h3 id="语法">语法</h3><p>箭头函数的语法有多种风格，这取决于你试图完成什么。所有的变种（箭头函数的多种风格）都是以函数参数开始，跟着箭头，跟着函数体。参数和函数体取决于使用可以采取不同的形式。例如，下面的箭头函数接受一个单一参数和简单的返回它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reflect = value =&gt; value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// effectively equivalent to:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reflect = <span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当箭头函数只有一个参数时，我们只需直接使用这个参数而不需要其他的语法。然后箭头函数的右边会被计算和返回。即使我们这没有一个明确的<code>return</code>声明，箭头函数会返回传入的第一个参数。</p>
<p>如果你传入的参数个数大于1时，你就需要圆括号将参数用括号扩起来啦。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = (num1, num2) =&gt; num1 + num2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// effectively equivalent to:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span><span class="params">(num1, num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sum()</code>函数将两个参数相加并返回结果。不同之处在于我们的参数放在圆括号内，且用<code>,</code>分隔。</p>
<p>需要注意的是，当我们的箭头函数没有参数时，我们必须包含一个空圆括号。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName = () =&gt; <span class="string">"Nicholas"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// effectively equivalent to:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Nicholas"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当你需要提供一个更传统的函数体时，可能包含多个表达式，那么我们可以将这些语句放在花括号<code>{}</code>内，并且定义一个明确的返回值。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = (num1, num2) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// effectively equivalent to:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span><span class="params">(num1, num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当你需要创建一个什么也不做的函数时，我们需要包括花括号，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doNothing = () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// effectively equivalent to:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doNothing = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>还有一点需要注意的是，因为花括号被用于包含函数体，当我们需要从箭头函数返回一个对象直接量时，我们需要将直接量放在圆括号内。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getTempItem = id =&gt; (&#123; id: id, name: <span class="string">"Temp"</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// effectively equivalent to:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getTempItem = <span class="function"><span class="keyword">function</span><span class="params">(id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        id: id,</span><br><span class="line">        name: <span class="string">"Temp"</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="词法的this绑定">词法的<code>this</code>绑定</h3><p>在<code>JavaScript</code>中最常见出错的地方就是<code>this</code>在函数内的绑定。因为<code>this</code>的值可以根据调用它的上下文在单个函数内改变，这就可能错误的使用影响某个对象，但你的意图是另外一个对象。考虑以下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line"></span><br><span class="line">    id: <span class="string">"123456"</span>,</span><br><span class="line"></span><br><span class="line">    init: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.doSomething(event.type);     <span class="comment">// error</span></span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    doSomething: <span class="function"><span class="keyword">function</span><span class="params">(type)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type  + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们知道<code>this.doSomething</code>中的<code>this</code>对象其实是指向<code>document</code>的，但我们的本意其实是<code>PageHandler</code>对象。如果你试图运行代码，会得到一个错误。你可能会使用<code>bind</code>或<code>var me = this</code>的方式来解决这个问题。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind way</span></span><br><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line"></span><br><span class="line">    id: <span class="string">"123456"</span>,</span><br><span class="line"></span><br><span class="line">    init: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, (<span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.doSomething(event.type);     <span class="comment">// no error</span></span><br><span class="line">        &#125;).bind(<span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    doSomething: <span class="function"><span class="keyword">function</span><span class="params">(type)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type  + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var me = this;</span></span><br><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line"></span><br><span class="line">    id: <span class="string">"123456"</span>,</span><br><span class="line"></span><br><span class="line">    init: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">var</span> me = <span class="keyword">this</span>;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span><br><span class="line">            me.doSomething(event.type);     <span class="comment">// no error</span></span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    doSomething: <span class="function"><span class="keyword">function</span><span class="params">(type)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type  + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在代码如你预期的那样执行了，但是我们总会觉得有些奇怪。通过调用<code>bind(this)</code>，你实际上是创建了一个新的函数，新函数的<code>this</code>被绑定到了<code>PageHandler</code>。</p>
<p>但是在箭头函数内，它具有隐式<code>this</code>绑定，这意味着箭头函数内的<code>this</code>值总是与定义箭头函数的作用域的<code>this</code>具有相同的值。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line"></span><br><span class="line">    id: <span class="string">"123456"</span>,</span><br><span class="line"></span><br><span class="line">    init: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>,</span><br><span class="line">                event =&gt; <span class="keyword">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    doSomething: <span class="function"><span class="keyword">function</span><span class="params">(type)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type  + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在<code>this</code>的值和<code>init()</code>内的<code>this</code>值是一样的，它就能用<code>bind</code>的方式实现一样的功能了。</p>
<p>箭头函数被设计为“一次性“函数，所以它不能用于定义新的类型。它和普通的函数不同，它没有<code>prototype</code>属性。如果你尝试在箭头函数上使用<code>new</code>操作符，就会报错。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyType = () =&gt; &#123;&#125;,</span><br><span class="line">    object = <span class="keyword">new</span> MyType();  <span class="comment">// error - you can't use arrow functions with 'new'</span></span><br></pre></td></tr></table></figure>
<p>因为<code>this</code>的值是静态绑定到箭头函数上，你不能通过<code>apply()</code>、<code>call()</code>或<code>bind()</code>的方式来改变<code>this</code>的值。</p>
<h3 id="词法arguments绑定">词法<code>arguments</code>绑定</h3><p>尽管箭头函数自身没有<code>arguments</code>对象，但是它能获取到包含它的函数的<code>arguments</code>对象。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArrowFunctionReturningFirstArg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> () =&gt; <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrowFunction = createArrowFunctionReturningFirstArg(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arrowFunction());</span><br></pre></td></tr></table></figure>
<h3 id="识别箭头函数">识别箭头函数</h3><p>尽管语法不同，箭头函数同样也是函数，它也可以被识别：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> comparator = (a, b) =&gt; a - b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> comparator);                 <span class="comment">// "function"</span></span><br><span class="line"><span class="built_in">console</span>.log(comparator <span class="keyword">instanceof</span> <span class="built_in">Function</span>);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>至此，就是本文的全部内容啦。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScript/">JavaScript</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/06/es6-function/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/06/06/es6-function/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/04/es6-string/" title="每天学点ES6－字符串" itemprop="url">每天学点ES6－字符串</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-06-04T05:19:42.000Z" itemprop="datePublished"> 發表於 2015-06-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><code>ES6</code>中对字符串进行了很多扩展，包括加强了<code>Unicode</code>的支持、</p>
<h2 id="更好的Unicode支持">更好的Unicode支持</h2><p>在<code>ES6</code>之前，<code>JavaScript</code>的字符串是完全基于16位字符编码的想法。所有字符串的属性和方法，例如：<code>length</code>和<code>charAt()</code>，都是基于16位序列代表单个字符的想法。<code>ES5</code>还允许<code>Javascript</code>引擎决定使用哪种编码方式，<code>UCS-2</code>或<code>UTF-16</code>。</p>
<p>对于<code>Unicode</code>的既定目标，保持在16位是不可能的为全世界的每一个字符提供一个全局唯一的标识符。这些全局唯一标志服被称之为<code>code point</code>，且从0开始。一个字符串编码有责任编码一个<code>code point</code>为<code>code unit</code>，且保持内部一致。</p>
<p>第一个<code>2^16</code>个<code>code point</code>在<code>UTF-16</code>中被表示为单一的16位<code>code unit</code>。这被称之为<code>Basic Multilingual Plane (BMP)</code>。超出该范围的被认为是在一个辅助平面，<code>code point</code>已不能仅仅用16位来表示了。<code>UTF-16</code>通过引入<code>surrogate pairs(代理对)</code>来解决这个问题，一个<code>code point</code>可以由两个16位的<code>code unit</code>来表示。这意味着字符串中的任何单个字符可以由一个<code>code unit</code>或两个来表示。</p>
<p>在<code>ES5</code>中所有的操作都是基于16位的<code>code unit</code>，这意味着你在处理包含<code>代理对</code>的字符串时会出现意想不到的结果。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"𠮷"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(text.length);           <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/</span>.test(text));      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(text.charAt(<span class="number">0</span>));        <span class="comment">// ""</span></span><br><span class="line"><span class="built_in">console</span>.log(text.charAt(<span class="number">1</span>));        <span class="comment">// ""</span></span><br><span class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">0</span>));    <span class="comment">// 55362</span></span><br><span class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">1</span>));    <span class="comment">// 57271</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，单个<code>Unicode</code>字符是使用<code>代理对</code>来表示的，<code>JavaScript</code>字符操作会认为字符串由两个16位的字符组成。这意味着<code>length</code>为2，通过正则表达式匹配单个字符也失败了，<code>charAt()</code>也无法读取字符。<code>charCodeAt()</code>方法为每个<code>code unit</code>返回了正确的16为数字。</p>
<p>在<code>ES6</code>中强制使用<code>UTF-16</code>来编码字符串。</p>
<h3 id="codePointAt()">codePointAt()</h3><p><code>codePointAt()</code>接受<code>code unit</code>的位置，并返回一个整数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"𠮷a"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">0</span>));    <span class="comment">// 55362</span></span><br><span class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">1</span>));    <span class="comment">// 57271</span></span><br><span class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">2</span>));    <span class="comment">// 97</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(text.codePointAt(<span class="number">0</span>));   <span class="comment">// 134071</span></span><br><span class="line"><span class="built_in">console</span>.log(text.codePointAt(<span class="number">1</span>));   <span class="comment">// 57271</span></span><br><span class="line"><span class="built_in">console</span>.log(text.codePointAt(<span class="number">2</span>));   <span class="comment">// 97</span></span><br></pre></td></tr></table></figure>
<p>当字符为<code>BMP</code>范围内的字符时，<code>codePointAt()</code>和<code>charCodeAt()</code>的行为是一样的，在非<code>BMP</code>字符时，<code>charCodeAt()</code>仅仅返回了位置<code>0</code>的<code>code unit</code>，但是<code>codePointAt()</code>返回了整个<code>code point</code>，即使横跨多个<code>code unit</code>。对于位置1和位置2的，它俩返回值是相同的。</p>
<p>用以下方法可以判断是否为16位，还是32位：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span><span class="params">(c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(is32Bit(<span class="string">"𠮷"</span>));         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(is32Bit(<span class="string">"a"</span>));          <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="String-fromCodePoint()">String.fromCodePoint()</h3><p><code>String.fromCodePoint()</code>就是和<code>codePointAt()</code>做相反的操作了。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">134071</span>));  <span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure>
<h3 id="编码非BMP字符">编码非<code>BMP</code>字符</h3><p>在<code>ES5</code>中允许字符包含用编码序列代表的16位<code>Unicode</code>字符。编码序列是通过<code>\u</code>加上4个16进制值，例如<code>\u0061</code>代表字符<code>a</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"\u0061"</span>);      <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure>
<p>但是当你用编码序列来代表大于<code>FFFF</code>的字符时，你会得到意想不到的结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"\u20BB7"</span>);</span><br></pre></td></tr></table></figure>
<p>因为<code>Unicode</code>编码序列总是包含4个16进制字符，<code>ECMAScript</code>计算<code>\u20BB7</code>为两个字符：<code>\u20BB</code>和<code>7</code>。第一个字符为非打印的，第二个为数字7。</p>
<p><code>ES6</code>通过引入扩展的<code>Unicode</code>编码序列解决了这个问题，将16进制数字包含在花括号内。这使得任何数量的十六进制字符可以指定为单个字符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"\u&#123;20BB7&#125;"</span>);     <span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure>
<p>通过下面的函数可以判断是否支持这种写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">supportsExtendedEscape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">"'\\u&#123;00FF1&#125;'"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式u修饰符">正则表达式<code>u</code>修饰符</h3><p>正则表达式也是基于16位的<code>code unit</code>来代表单个字符，这就对于<code>𠮷</code>在<code>/^.$/</code>的正则表达式中不能匹配，<code>ES6</code>为正则表达式定义了一个新的修饰符，<code>u</code>也即<code>Unicode</code>。当一个正则表达式设置了<code>u</code>修饰符时，它将切换模式为工作在字符串，而不是<code>code unit</code>。这意味着正则表达式在包含<code>代理对</code>的字符串中不会迷惑。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"𠮷"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(text.length);           <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/</span>.test(text));      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/u</span>.test(text));     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在添加了<code>u</code>修饰符的正则表达式能以字符的方式来匹配字符串，而不是<code>code unit</code>。</p>
<h2 id="新增的String方法">新增的<code>String</code>方法</h2><h3 id="includes()">includes()</h3><p>如果给定字符在字符串的任何位置被找到，则返回<code>true</code>，否则返回<code>false</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">"Hello world!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"ello"</span>));</span><br></pre></td></tr></table></figure>
<h3 id="startsWith()">startsWith()</h3><p>如果字符串以给定字符开始，则返回<code>true</code>，否则返回<code>false</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">"Hello world!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"Hello"</span>));</span><br></pre></td></tr></table></figure>
<h3 id="endsWith()">endsWith()</h3><p>如果字符串以给定字符结束，则返回<code>true</code>，否则返回<code>false</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">"Hello world!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"world!"</span>));</span><br></pre></td></tr></table></figure>
<h3 id="repeat()">repeat()</h3><p>该方法接受一个数字作为参数，表示将原字符串重复的次数。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"cookfront"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式修饰符y">正则表达式修饰符<code>y</code></h2><p><code>ES6</code>引入了新的正则表达式修饰符<code>y</code>，也即<code>粘连</code>，它与<code>g</code>修饰符比较类似，但是不同之处在于，<code>g</code>修饰符只确保剩余位置中存在匹配，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始，这也就是<code>粘连</code>的涵义。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"hello1 hello2 hello3"</span>,</span><br><span class="line">    pattern = <span class="regexp">/hello\d\s?/</span>,</span><br><span class="line">    result = pattern.exec(text),</span><br><span class="line">    globalPattern = <span class="regexp">/hello\d\s?/g</span>,</span><br><span class="line">    globalResult = globalPattern.exec(text),</span><br><span class="line">    stickyPattern = <span class="regexp">/hello\d\s?/y</span>,</span><br><span class="line">    stickyResult = stickyPattern.exec(text);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]);         <span class="comment">// "hello1 "</span></span><br><span class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]);   <span class="comment">// "hello1 "</span></span><br><span class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]);   <span class="comment">// "hello1 "</span></span><br><span class="line"></span><br><span class="line">pattern.lastIndex = <span class="number">1</span>;</span><br><span class="line">globalPattern.lastIndex = <span class="number">1</span>;</span><br><span class="line">stickyPattern.lastIndex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">result = pattern.exec(text);</span><br><span class="line">globalResult = globalPattern.exec(text);</span><br><span class="line">stickyResult = stickyPattern.exec(text);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]);         <span class="comment">// "hello1 "</span></span><br><span class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]);   <span class="comment">// "hello2 "</span></span><br><span class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]);   <span class="comment">// Error! stickyResult is null</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，使用了三个正则表达式，一个使用了<code>y</code>修饰符，一个使用了<code>g</code>修饰符，一个没有使用修饰符。第一次匹配时我们可以看到结果都为<code>hello1</code>，匹配后我们将<code>lastIndex</code>置为1，即从第二个字符开始匹配，我们可以看到第二次匹配的结果没有修饰符的还是匹配<code>hello1</code>，<code>g</code>修饰符的匹配<code>hello2</code>，<code>y</code>修饰符在从第二个字符开始没有匹配任何东西所以返回<code>null</code>。我们也可以看出了<code>y</code>修饰符号隐含了头部匹配的标志<code>^</code>。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScript/">JavaScript</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/04/es6-string/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/06/04/es6-string/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/02/es6-destructing/" title="每天学点ES6－变量解构" itemprop="url">每天学点ES6－变量解构</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-06-02T04:59:42.000Z" itemprop="datePublished"> 發表於 2015-06-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在<code>ES5</code>时，我们经常会在代码中看到类似下面这样的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">(options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = options.a;</span><br><span class="line">  <span class="keyword">var</span> b = options.b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了变量解构，我们就不用这么麻烦了，用一行代码就能实现，特别是在有多个变量时，这样写还是很烦的。用变量结构我们可以像下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">(options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> &#123;a, b&#125; = options;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量解构包括<code>对象解构</code>和<code>数组解构</code>，下面一一讲解。</p>
<h2 id="对象解构">对象解构</h2><p>对象解构的语法是使用一个对象直接量在赋值操作符的左边，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  a: <span class="string">'a'</span>,</span><br><span class="line">  b: <span class="string">'b'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;a: localA, b: localB&#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(localA);</span><br><span class="line"><span class="built_in">console</span>.log(localB);</span><br></pre></td></tr></table></figure>
<p>上面的代码中，<code>options.a</code>的值会存储在变量<code>localA</code>中，<code>options.b</code>会存储在变量<code>localB</code>中。在对象解构时，左边的对象直接量中，<code>key</code>对应了需要在对象中解构的属性，<code>value</code>则为存储属性值的变量名。</p>
<p>如果你想使用对象中相同的属性名，你可以省略左边对象直接量中的冒号和后面的值，例如，对于上面的例子，你可以这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  a: <span class="string">'a'</span>,</span><br><span class="line">  b: <span class="string">'b'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;a, b&#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure>
<p>当给定的属性名不存在对象中时，局部变量会得到<code>undefined</code>的值，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  a: <span class="string">'a'</span>,</span><br><span class="line">  b: <span class="string">'b'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;a, b, c&#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>对象解构也是可以嵌套的，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  a: <span class="string">'a'</span>,</span><br><span class="line">  b: <span class="string">'b'</span>,</span><br><span class="line">  c: &#123;</span><br><span class="line">    d: <span class="string">'d'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;a, b, c: &#123;d&#125;&#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(d);</span><br></pre></td></tr></table></figure>
<h2 id="数组解构">数组解构</h2><p>数组解构和对象解构差不多，是使用一个数组直接量在赋值操作符的左边，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [a, b, c] = arr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br></pre></td></tr></table></figure>
<p>要注意的是，数组解构时要按照元素在数组中的顺序。还有一点是数组解构不会修改原数组。</p>
<p>数组解构也是可以嵌套解构的，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [ <span class="string">"red"</span>, [ <span class="string">"green"</span>, <span class="string">"lightgreen"</span> ], <span class="string">"blue"</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [ firstColor, [ secondColor ] ] = colors;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstColor);        <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor);       <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure>
<p>以上就是变量结构的内容了。</p>
<p>参考链接：</p>
<ol>
<li><a href="https://leanpub.com/understandinges6/read" target="_blank" rel="external">https://leanpub.com/understandinges6/read</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="external">http://es6.ruanyifeng.com/#docs/destructuring</a></li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScript/">JavaScript</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/02/es6-destructing/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/06/02/es6-destructing/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/28/es6-let-const/" title="每天学点ES6－let和const" itemprop="url">每天学点ES6－let和const</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-05-28T04:59:42.000Z" itemprop="datePublished"> 發表於 2015-05-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>今天学习的比较简单，主要学习<code>ES6</code>的<code>let</code>和<code>const</code>。</p>
<p>我们知道在<code>ES6</code>之前，是没有块级作用域这一说的，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span><span class="params">(condition)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">var</span> value = <span class="string">"blue"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// other code</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// value exists here with a value of undefined</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// value exists here with a value of undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会觉得在<code>else</code>里面无法访问到<code>value</code>变量，其实在<code>js</code>内部会造成变量提升，这意味着我们可以在<code>else</code>里面访问到<code>value</code>变量，只是它未初始化，所以其变量值为<code>undefined</code>。实际解析时代码可能像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span><span class="params">(condition)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        value = <span class="string">"blue"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// other code</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>let</code>和<code>const</code>为我们带来了<code>块级作用域</code>，这意味着它只能在代码块内才能访问到，出了代码块就会抛出异常了，还有一点重要的是，<code>let</code>和<code>const</code>不会造成<code>变量提升</code>。</p>
<h2 id="let">let</h2><p><code>let</code>定义变量时和<code>var</code>有两个区别：块级作用域、不会变量提升和不能定义在块中已有标识符同名的变量。</p>
<p>我们用<code>let</code>来重新定义上面的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span><span class="params">(condition)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="string">"blue"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// other code</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// value doesn't exist here</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// value doesn't exist here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当用<code>let</code>定义<code>value</code>时，我们只能在<code>if</code>里面才能访问到<code>value</code>了，<code>value</code>变量也不会变量提升，从而我们在<code>else</code>里面不能访问到<code>value</code>。</p>
<p><code>let</code>最常用的场景应该是<code>for</code>循环了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="块级作用域">块级作用域</h3><p>块级作用域就不用多说，就是用<code>let</code>定义的变量只在定义它的块中有效，出了这个块你就不能访问到它了。</p>
<h3 id="变量提升">变量提升</h3><p>变量提升应该是在面试的时候会经常考到，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">var</span> value = <span class="string">'something'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fn);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test2();</span><br></pre></td></tr></table></figure>
<p>我们用<code>let</code>重新定义上面的<code>test()</code>函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">let</span> value = <span class="string">'something'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>此时浏览器就会抱怨了，在<code>let</code>定义前是无法访问到我们的变量的。</p>
<h3 id="同名变量">同名变量</h3><p>用<code>var</code>定义变量时，我们可以多次对它进行定义，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>这样的代码是不会报错的，在<code>let</code>定义的<code>相同块</code>中定义同名变量时就会报错了，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>要注意的是要与<code>let</code>定义时在相同的块中，下面的代码是不会出错的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (something) &#123;</span><br><span class="line">  let a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="const">const</h2><p><code>const</code>除了具有<code>let</code>的块级作用域和不会变量提升外，还有就是它定义的是常量，在用<code>const</code>定义变量后，我们就不能修改它了，对变量的修改会默默的失败（在<code>iojs</code>中会抛出异常，在Chrome下会默默的失败）。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(PI);</span><br><span class="line"></span><br><span class="line">PI = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(PI);</span><br></pre></td></tr></table></figure>
<p>参考链接：<a href="https://leanpub.com/understandinges6/read" target="_blank" rel="external">Understanding ECMAScript 6</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScript/">JavaScript</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/28/es6-let-const/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/05/28/es6-let-const/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/27/ios-nsurlsession/" title="iOS NSURLSession" itemprop="url">iOS NSURLSession</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-05-27T10:07:42.000Z" itemprop="datePublished"> 發表於 2015-05-27</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><code>NSURLSession</code>是<code>iOS7</code>中新的网络接口，负责处理数据的加载以及文件和数据在客户端与服务端之间的上传和下载。本文将从以下几个方面介绍：</p>
<ul>
<li>NSURLSessionConfiguration：在使用<code>NSURLSession</code>首先要创建一个<code>NSURLSessionConfiguration</code>来配置我们的<code>NSURLSession</code></li>
<li>NSURLSession</li>
<li>NSURLSessionTask：<ul>
<li>NSURLSessionDataTask：处理一般的 NSData 数据对象，比如通过GET或POST方式从服务器获取JSON或XML返回等等，但不支持后台获取</li>
<li>NSURLSessionUploadTask：用于上传文件，支持后台上传</li>
<li>NSURLSessionDownloadTask：用于下载文件，支持后台下载</li>
</ul>
</li>
</ul>
<h2 id="NSURLSessionConfiguration">NSURLSessionConfiguration</h2><p>一个<code>NSURLSessionConfiguration</code>对象定义了当使用<code>NSURLSession</code>对象上传和下载数据时的行为和使用策略。当你需要上传和下载数据时，创建一个配置对象总是你必须采取的第一步。从指定可用网络，到 cookie，安全性，缓存策略，再到使用自定义协议，启动事件的设置，以及用于移动设备优化的几个新属性，你会发现使用 <code>NSURLSessionConfiguration</code>可以找到几乎任何你想要进行配置的选项。</p>
<p><code>NSURLSession</code>在初始化时会把配置它的<code>NSURLSessionConfiguration</code>对象进行一次 copy，并保存到自己的<code>configuration</code>属性中，而且这个属性是只读的。因此之后再修改最初配置<code>session</code>的那个<code>configuration</code>对象对于<code>session</code>是没有影响的。也就是说，<code>configuration</code>只在初始化时被读取一次，之后都是不会变化的。</p>
<p><code>NSURLSessionConfiguration</code>提供了三个工厂方法来创建我们的<code>Session Configuration</code>对象：</p>
<ul>
<li><code>+ defaultSessionConfiguration</code>：该方法返回创建的一个默认<code>Session Configuration</code>对象。默认的<code>Session Configuration</code>会使用磁盘来缓存数据并在用户的<code>keychain</code>中存储凭证。它同样会存储<code>cookie</code>。</li>
<li><code>+ ephemeralSessionConfiguration</code>：返回一个<code>session configuration</code>，且不会使用缓存，<code>cookie</code>和凭证。使用<code>ephemeral sessions</code>主要的优点就是隐私。因此，它可以用于实现像秘密浏览这种功能。</li>
<li><code>+ backgroundSessionConfigurationWithIdentifier:</code>：返回一个后台的<code>session configuration</code>。后台<code>session</code>不同于常规的，普通的<code>session</code>，它甚至可以在应用程序挂起，退出或者崩溃的情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外恢复后台传输的守护进程（daemon）提供上下文。</li>
</ul>
<p>对于<code>NSURLSessionConfiguration</code>的属性配置，可以看这篇文章：<a href="http://objccn.io/issue-5-4/" target="_blank" rel="external">http://objccn.io/issue-5-4/</a>。</p>
<h2 id="NSURLSession">NSURLSession</h2><p>创建好了<code>NSURLSessionConfiguration</code>对象，我们就可以使用它来创建我们的<code>NSURLSession</code>对象了。<code>NSURLSession</code>提供了三个工厂方法来创建我们的<code>session</code>对象：</p>
<ul>
<li><code>+ sessionWithConfiguration:</code>：使用指定的<code>session configuration</code>来创建一个<code>session</code>，且会创建一个序列的<code>NSOperationQueue</code>对象来处理所有的委托方法和完成处理程序的调用</li>
<li><code>+ sessionWithConfiguration:delegate:delegateQueue:</code>：使用指定的<code>session configuration</code>、<code>delegate</code>和<code>operation queue.</code>来创建<code>session</code>。这个方法可以更细粒度的创建<code>session</code>，可以设定回调的<code>delegate</code>（注意这个回调delegate会被强引用），并且可以设定<code>delegate</code>在哪个<code>OperationQueue</code>回调，如果我们将其设置为<code>[NSOperationQueue mainQueue]</code>就能在主线程进行回调非常的方便。</li>
<li><code>+ sharedSession</code>：返回一个共享的单例<code>session</code>对象</li>
</ul>
<h2 id="NSURLSessionTask">NSURLSessionTask</h2><p>通过上面创建的<code>session</code>，我们就可以安排三种类型的任务：检索数据到存储器的数据任务、下载文件到硬盘的下载任务和从硬盘上传文件的上传任务。</p>
<p><code>NSURLSessionTask</code>是一个抽象类，其下有 3 个实体子类可以直接使用：<code>NSURLSessionDataTask</code>、<code>NSURLSessionUploadTask</code>、<code>NSURLSessionDownloadTask</code>。这 3 个子类封装了现代程序三个最基本的网络任务：获取数据，比如 JSON 或者 XML，上传文件和下载文件。</p>
<p>所有的<code>task</code>都是可以取消，暂停或者恢复的。当一个 download task 取消时，可以通过选项来创建一个恢复数据（resume data），然后可以传递给下一次新创建的<code>download task</code>，以便继续之前的下载。</p>
<p>这里的<code>task</code>不同于其他的<code>alloc-init</code>初始化方法，它是需要通过<code>session</code>来创建的，<code>NSURLSession</code>提供了多个方法来创建<code>task</code>：</p>
<p><strong>Data Task：</strong></p>
<ul>
<li><code>- dataTaskWithURL:</code></li>
<li><code>- dataTaskWithURL:completionHandler:</code></li>
<li><code>- dataTaskWithRequest:</code></li>
<li><code>- dataTaskWithRequest:completionHandler:</code></li>
</ul>
<p>实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">NSURL *url = [NSURL URLWithString:@<span class="string">"http://demo.com"</span>];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line"></span><br><span class="line">NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration];</span><br><span class="line">NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;</span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">&#125;];</span><br><span class="line">[dataTask resume];</span><br></pre></td></tr></table></figure>
<p><strong>Download Task：</strong></p>
<ul>
<li><code>- downloadTaskWithURL:</code></li>
<li><code>- downloadTaskWithURL:completionHandler:</code></li>
<li><code>- downloadTaskWithRequest:</code></li>
<li><code>- downloadTaskWithRequest:completionHandler:</code></li>
<li><code>- downloadTaskWithResumeData:</code></li>
<li><code>- downloadTaskWithResumeData:completionHandler:</code></li>
</ul>
<p>实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSURL *URL = [NSURL URLWithString:@<span class="string">"http://example.com/file.zip"</span>];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:URL];</span><br><span class="line"></span><br><span class="line">NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithRequest:request                                                    completionHandler:^(NSURL *location, NSURLResponse *response, NSError *error) &#123;</span><br><span class="line">        NSString *documentsPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];</span><br><span class="line">        NSURL *documentsDirectoryURL = [NSURL fileURLWithPath:documentsPath];</span><br><span class="line">        NSURL *newFileLocation = [documentsDirectoryURL URLByAppendingPathComponent:[[response URL] lastPathComponent]];</span><br><span class="line">        [[NSFileManager defaultManager] copyItemAtURL:location toURL:newFileLocation error:nil];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[downloadTask resume];</span><br></pre></td></tr></table></figure>
<p><strong>Upload Task：</strong></p>
<ul>
<li><code>- uploadTaskWithRequest:fromData:</code></li>
<li><code>- uploadTaskWithRequest:fromData:completionHandler:</code></li>
<li><code>- uploadTaskWithRequest:fromFile:</code></li>
<li><code>- uploadTaskWithRequest:fromFile:completionHandler:</code></li>
<li><code>- uploadTaskWithStreamedRequest:</code></li>
</ul>
<p>实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSURL *URL = [NSURL URLWithString:@<span class="string">"http://example.com/upload"</span>];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:URL];</span><br><span class="line">NSData *data = ...;</span><br><span class="line"></span><br><span class="line">NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">NSURLSessionUploadTask *uploadTask = [session uploadTaskWithRequest:request fromData:data completionHandler:</span><br><span class="line">     ^(NSData *data, NSURLResponse *response, NSError *error) &#123;</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">     &#125;];</span><br><span class="line">[uploadTask resume];</span><br></pre></td></tr></table></figure>
<p>以上就是本文的全部内容啦。如有不对还请指出。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/27/ios-nsurlsession/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/05/27/ios-nsurlsession/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/18/ios-uiview/" title="iOS UIView 学习" itemprop="url">iOS UIView 学习</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-05-18T03:47:42.000Z" itemprop="datePublished"> 發表於 2015-05-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文主要翻译自：<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009503-CH1-SW2" target="_blank" rel="external">View Programming Guide for iOS</a>，内容有删减。</p>
<p><code>UIView</code>类在屏幕上定义了一个矩形区域和一些在那个区域处理内容的接口。在运行时，一个<code>view</code>对象处理那个区域任何内容的渲染，还处理与这些内容的任何交互。<code>UIView</code>类它自己提供了用一个背景颜色填充它的矩形区域的基本行为。更复杂的内容可以通过继承<code>UIView</code>来呈现，并自身实现必要的绘制和事件处理代码。<code>UIKit</code>框架还包括一组标准的子类，从简单的按钮到复杂的表格可以使用。例如，一个<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UILabel_Class/index.html#//apple_ref/occ/cl/UILabel" target="_blank" rel="external">UILabel</a>对象绘制一个文本字符串，一个<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImageView_Class/index.html#//apple_ref/occ/cl/UIImageView" target="_blank" rel="external">UIImageView</a>对象绘制一张图片。</p>
<p>因为<code>view</code>对象是你的应用与用户交互的主要方式，所以它们具有许多职责。这里仅仅是几个：</p>
<ul>
<li>绘制和动画<ul>
<li>视图使用例如<code>UIKit</code>，<code>Core Graphics</code>和<code>OpenGL ES</code>的技术在它们的矩形区域绘制内容</li>
<li>一些视图属性可以动画到新的值</li>
</ul>
</li>
<li>布局和子视图管理<ul>
<li>一个视图可能包含0个或多个子视图</li>
<li>每一个视图定义了相对于它的父视图的它们自己默认的尺寸调整行为</li>
<li>视图可以根据需要限定的它的子视图的尺寸和位置</li>
</ul>
</li>
<li>事件处理<ul>
<li>视图是一个应答器，并能处理触摸事件以及由<code>UIResponder</code>类定义的其它事件</li>
<li>视图可以使用<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instm/UIView/addGestureRecognizer:" target="_blank" rel="external">addGestureRecognizer:</a>方法安装手势识别以处理常见的手势</li>
</ul>
</li>
</ul>
<p>视图可以嵌入其他视图，并创建复杂的视觉层次。这在被嵌入的视图（被称为subview）和父视图做嵌入（被称为superview）之间创建了一种<code>父－子</code>关系。通常情况下，一个<code>subview</code>的可见区域不会在它的<code>superview</code>的边界被剪切，但是在<code>iOS</code>中你可以使用<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instp/UIView/clipsToBounds" target="_blank" rel="external">clipsToBounds</a>来更新这种行为。一个父视图可以包含任意多个<code>subview</code>，但每个<code>subview</code>只有一个<code>superview</code>，该<code>superview</code>负责适当定位其子视图。</p>
<h2 id="视图绘制周期">视图绘制周期</h2><p><code>UIView</code>类使用一个按需绘制的模式来呈现内容。当一个视图第一次出现在屏幕上时，系统要求它绘制它的内容。系统捕捉内容的快照，并使用快照作为视图的可视化表示。如果你从未改变过视图内容，视图的绘制代码可能永远不会被再次调用。快照图片对于涉及视图的大部分操作中被重用。如果你更改了内容，你通知系统视图被改变了。视图重复绘制视图和捕捉新结果的快照。</p>
<p>当视图内容改变的时候，你不需要直接重绘这些变化。相反，你使用<code>setNeedsDisplay</code>或<code>setNeedsDisplayInRect:</code>中任何一个方法使视图失效。这些方法告诉系统视图中的内容被改变了，需要在下次机会被重绘。</p>
<p>当到了渲染视图内容的时候，实际的绘制过程取决于视图和它的配置。系统视图通常实现私有绘图方法来呈现其内容。这些相同的系统视图通常暴露接口，使用接口你可以配置视图的实际外观。对于自定义的<code>UIView</code>子类，你通常覆盖你视图的<code>drawRect:</code>方法，并使用该方法来绘制视图的内容。也有其他的方式来提供视图的内容，例如，直接设计内容底部的<code>layer</code>，但是覆盖<code>drawRect:</code>方法是最常用的技术。</p>
<p>下面再来看下上面提到的三个方法：</p>
<ul>
<li><code>- setNeedsDisplay</code></li>
</ul>
<p><strong>声明：</strong></p>
<p>SWIFT</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">setNeedsDisplay</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>OBJECTIVE-C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setNeedsDisplay</span><br></pre></td></tr></table></figure>
<p>你可以使用该方法或<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instm/UIView/setNeedsDisplayInRect:" target="_blank" rel="external">setNeedsDisplayInRect:</a>方法来通知系统你的视图内容需要被重绘了。这个方法发起请求并立即返回。视图并不是真的在重绘直到下一个绘制周期，在该点所有失效的视图被更新。</p>
<p>你应该只在视图的内容和外观改变时使用该方法来请求视图重绘。如果你只是简单地更改视图的几何结构，视图通常不会重新绘制。作为代替，它的现有内容基于视图的<code>contentMode</code>属性的值进行调整。重新显示现有的内容通过避免重绘并没有改变的内容而提供了性能。</p>
<ul>
<li><code>- setNeedsDisplayInRect:</code></li>
</ul>
<p><strong>声明：</strong></p>
<p>SWIFT</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">setNeedsDisplayInRect</span><span class="params">(_ invalidRect: CGRect)</span></span></span><br></pre></td></tr></table></figure>
<p>OBJECTIVE-C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setNeedsDisplayInRect:(CGRect)invalidRect</span><br></pre></td></tr></table></figure>
<ul>
<li><code>- drawRect:</code></li>
</ul>
<p><strong>声明：</strong></p>
<p>SWIFT</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">drawRect</span><span class="params">(_ rect: CGRect)</span></span></span><br></pre></td></tr></table></figure>
<p>OBJECTIVE-C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(CGRect)rect</span><br></pre></td></tr></table></figure>
<p><strong>参数：</strong></p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>rect</td>
<td>视图的边界部分。你的视图在第一绘制时，该矩形是通常是视图的整个可见边界。然而，在随后的绘制操作中，矩形可能被指定为视图的一部分。</td>
</tr>
</tbody>
</table>
<p>该方法的默认实现不做任何事情。使用技术，例如<code>Core Graphics</code>和<code>UIKit</code>来绘制它们的视图内容时，子类应该覆盖该方法并在该方法中实现它们的绘制代码。如果你的视图通过其他方式来设置它的内容，则你不需要覆盖该方法。例如，你不需要覆盖该方法如果你的视图仅显示一个背景颜色时或者你的视图通过底层的<code>layer</code>对象直接设置它们的内容。</p>
<p>在该方法被调用时，<code>UIKit</code>已经正确的为您的视图配置好绘制环境，你可以简单的调用任何绘制方法和功能来渲染你的内容。具体来说，<code>UIKit</code>创建和配置了一个图形上下文来绘制和调整在那个上下文中的转换，从而它的原点匹配你视图边界矩形的原点。你可以通过<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKitFunctionReference/index.html#//apple_ref/c/func/UIGraphicsGetCurrentContext" target="_blank" rel="external">UIGraphicsGetCurrentContext</a>函数来获取到该图形上下文的引用，但是不要建立一个强引用到该图形上下文，因为它会因为<code>drawRect:</code>方法的调用被改变。</p>
<p>需要注意的是，你永远不要直接调用该方法。我们可以通过<code>setNeedsDisplay</code>和<code>setNeedsDisplayInRect:</code>方法来告诉视图需要重绘。</p>
<h2 id="Content_Mode">Content Mode</h2><p>每个视图有一个内容模式，它控制视图在响应视图的几何结构改变时如何回收其内容，以及是否回收其内容。当视图第一次显示时，它和平常一样渲染内容，且结果在底层的位图中被捕获。在那之后，更改视图的几何形状并不总是导致位图重新被创建。作为替代，<code>contentMode</code>属性的值决定了位图是否应该缩放以适应新的边界，或简单的固定到一个角落或视图的边缘。</p>
<p>当你做以下事情时，一个视图的内容模式被应用：</p>
<ul>
<li>改变视图的<code>frame</code>或<code>bounds</code>矩形的宽度或高度</li>
<li>分配一个包括一个伸缩因子的变换到视图的<code>transform</code>属性</li>
</ul>
<p>默认情况下，对于大多数视图的<code>contentMode</code>属性被设置为<code>UIViewContentModeScaleToFill</code>，这将导致视图的内容被伸缩以适应新的框架尺寸。下面的图显示了几个<code>contentMode</code>属性值之间的比较：</p>
<p><img src="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/scale_aspect.jpg" alt="enter image description here"></p>
<p>内容模式有利于回收利用视图的内容，但是你也可以设置内容模式为<code>UIViewContentModeRedraw</code>，当你需要你的自定义视图在伸缩或调整操作时重绘它们自己。设置你的视图的内容模式为该值时，会强制系统调用你视图的<code>drawRect:</code>方法以响应几何尺寸的改变。一般情况下，只要有可能你应该避免使用这个值，你当然不应该在标准的系统视图中使用它。</p>
<h2 id="内置动画支持（Built-In_Animation_Support）">内置动画支持（Built-In Animation Support）</h2><p>在每一个视图后面有一个<code>layer</code>对象的一个好处是，你可以轻松动画许多视图相关的改变。动画是一种将信息传达给用户的非常有用的方式，在您的应用程序的设计过程中应该始终考虑它。<code>UIView</code>类的许多属性是可动画的——也就是说，半自动的支持从一个值到另一个值的动画。为了对这些动画属性之一执行动画，你所要做的是：</p>
<ol>
<li>告诉<code>UIKit</code>你要执行的动画</li>
<li>改变属性的值</li>
</ol>
<p><code>UIView</code>对象上你可以设置动画的属性为以下这些：</p>
<ul>
<li>frame：使用这个来动画视图的位置和尺寸</li>
<li>bounds：使用这个来动画视图的尺寸</li>
<li>center：使用这个来动画视图的位置</li>
<li>transform：使用这个来旋转或伸缩视图</li>
<li>alpha：使用这个来改变视图的透明性</li>
<li>backgroundColor：使用这个来改变视图的背景色</li>
<li>contentStretch：使用这个来改变视图如何伸缩</li>
</ul>
<h2 id="视图几何结构和坐标系统（View_Geometry_and_Coordinate_Systems）">视图几何结构和坐标系统（View Geometry and Coordinate Systems）</h2><p>在<code>UIKit</code>中默认的坐标系统有一个原点在左上角，且坐标轴向原点处往右和下延伸。坐标值是使用浮点数来代表，这使得精确布局和内容定位不考虑底层的屏幕分辨率。下图展示了相对于屏幕的坐标系统。</p>
<p><img src="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/native_coordinate_system.jpg" alt="enter image description here"></p>
<p>因为每个视图和<code>window</code>定义了它们自己的局部坐标系统，你需要知道在任何给定时间是哪个坐标系在起作用。任何时候你在视图中绘制或改变它的几何结构时，你这样做，相对于一些坐标系统。在正在绘制的情况下，你指定相对于视图自己的坐标系统的坐标。在几何结构改变的情况下，你指定相对于<code>superview</code>坐标系统的坐标。<code>UIWindow</code>和<code>UIView</code>类都包含了方法来帮助你从一个坐标系统转换为另一个。</p>
<h3 id="frame、bounds和center属性之间的关系"><code>frame</code>、<code>bounds</code>和<code>center</code>属性之间的关系</h3><p>一个视图对象使用<code>frame</code>、<code>bounds</code>和<code>center</code>属性来跟踪它的尺寸和位置：</p>
<ul>
<li>frame：<code>frame</code>属性包含了框架矩形，它指定了视图相对于<code>superview</code>坐标系统的尺寸和位置</li>
<li>bounds：<code>bounds</code>属性包含了边界矩形，它指定了视图相对于它的局部坐标系统的尺寸和位置</li>
<li>center：<code>center</code>属性包含了视图在<code>superview</code>坐标系统的中电</li>
</ul>
<p>你使用<code>center</code>和<code>frame</code>属性主要用于操作当前视图的几何结构。例如，当你在构建你的视图层级或在运行时改变一个视图的位置和尺寸时，你可以使用这些属性。如果你仅仅只是想改变视图的位置，<code>center</code>属性是首选的方法。<code>center</code>属性的值始终是有效的，即使伸缩或旋转因素被添加到视图的变换中。在同样情况下，对于<code>frame</code>属性则不正确，这被认为是无效的，如果视图的变换不等于恒等变换。</p>
<p>你使用<code>bounds</code>属性主要在绘制期间。边界矩形是在视图自己的局部坐标系统中的表示。该矩形的默认原点为<code>(0, 0)</code>，且它的尺寸匹配框架矩形的尺寸。任何你在该矩形中绘制的东西是视图可见内容的一部分。如果你改变边界矩形的原点，任何你在新的矩形中绘制的东西称为视图可见内容的一部分。</p>
<p>下图显示了这三个属性之间的关系：</p>
<p><img src="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/frame_bounds_rects.jpg" alt="enter image description here"></p>
<p>虽然你改变<code>frame</code>、<code>bounds</code>和<code>center</code>属性独立于其他，但是改变其中一个属性会按以下方式来改变其他属性：</p>
<ul>
<li>当你设置<code>frame</code>属性，<code>bounds</code>属性中的尺寸值也相应改变以匹配框架矩形的新尺寸。<code>center</code>属性的值也同样改变以匹配框架矩形中xin的中点。</li>
<li>当你设置<code>center</code>属性，在<code>frame</code>属性中的原点值也会相应改变。</li>
<li>当你设置<code>bounds</code>属性的尺寸时，<code>frame</code>属性中的尺寸值也相应改变以匹配边界矩形中的新尺寸。</li>
</ul>
<p>默认情况下，一个视图的框架（frame）不会被其<code>superview</code>的框架剪切。你可以改变这种行为，通过设置<code>superview</code>的<code>clipToBounds</code>属性为<code>YES</code>。</p>
<h3 id="坐标系统转换">坐标系统转换</h3><p>坐标系统转换提供了一种方式来更快和更简单的更新你的视图。一个仿射变换是一个数学矩阵，它指定了点如何从一个坐标系统映射到另一个坐标系统。你可以应用仿射变换到你的整个视图，以改变尺寸、位置或相对于其<code>superview</code>的方向。你也可以使用仿射变换在你的绘制代码中，去以单个块的渲染内容来执行相同类型的操作。如何应用仿射变换取决于上下文：</p>
<ul>
<li>要改变你的整个视图，改变你视图中<code>transform</code>属性的仿射变换。</li>
<li>要改变你视图的<code>drawRect:</code>方法的指定块的内容，改变关联当前活跃图形上下文的仿射变换。</li>
</ul>
<p>通常，您可以修改视图的<code>transform</code>属性，当你想要实现动画时。例如，你可以使用该属性创建一个你视图围绕中点旋转的动画。你不能使用该属性永久改变你的视图，例如改变视图在它的<code>superview</code>坐标空间的尺寸和位置。对于那种类型的改变，你应该改变框架矩形作为替代。</p>
<p>在你的<code>drawRect:</code>方法中，你可以使用仿射变换来定位和适应你计划绘制的元素。而不是固定在你视图某个位置的一个对象的位置，去创建相对于一个固定点的每个对象是非常简单的，通常<code>(0, 0)</code>，使用一个<code>transform</code>来定位该对象在立即绘制之前。在那种方式，该对象的位置在你的视图中改变，所有你所要做的就是修改变换，这是更快，更便宜的，相对于重新创建一个对象在它的新位置。你可以通过使用<code>CGContextGetCTM</code>函数来检索关联图形上下文的仿射变换，且你可以使用相关的<code>Core Graphics</code>函数在绘制期间设置和修改变换。</p>
<p><code>当前变换矩阵（current transformation matrix (CTM)）</code>是在任何给定时间当前正在使用的仿射变换。当操作整个视图的几何结构时，<code>CTM</code>是储存在你视图的<code>transform</code>属性的仿射变换。在你的<code>drawRect:</code>方法中，<code>CTM</code>是关联当前活跃图形上下文的仿射变换。</p>
<p>每个子视图的坐标系建立在其祖先的坐标系上。所以当你修改一个视图的<code>transform</code>属性时，这些改变会影响视图和它的所有子视图。然而，这些改变只影响视图在屏幕上的最后渲染。因为任何视图绘制它的内容和布局它的子视图是相对于它自己的边界，它在绘制和布局期间会忽略它的<code>superview</code>的变换。</p>
<h2 id="创建和管理视图层次">创建和管理视图层次</h2><p>管理视图层次是开发应用程序用户界面的重要组成部分。你的视图的组织影响你的应用程序的外观和应用程序如何响应变化和事件。例如，在视图层次中的<code>父－子</code>关系决定了哪个对象可能处理某个指定的触摸事件。同样的，<code>父－子</code>关系定义了每个视图如何响应界面方向改变。</p>
<h3 id="添加和移除子视图">添加和移除子视图</h3><p><code>Interface Builder</code>是建立视图层次的最方便的方式，因为你以图形化的方式组装视图，可以看到视图之间的关系，同样可以看到这些视图如何在运行时显示。当使用<code>Interface Builder</code>，你保存你的结果视图层级在一个<code>nib</code>文件中，你可以在运行时加载相应需要的视图。</p>
<p>如果你更愿意以程序的方式来创建你的视图，你创建和初始化它们，然后使用以下方法安排它们到层次：</p>
<ul>
<li>要添加一个子视图到父亲，在父视图上调用<code>addSubview:</code>。该方法添加子视图到父视图的子视图列表的末尾。</li>
<li>要插入一个子视图到父视图的子视图列表的中间，可以在父视图上调用任何和<code>insertSubview:...</code>相关的方法。</li>
<li>要重排父视图中现有的子视图，调用父视图的<code>bringSubviewToFront:</code>、<code>sendSubviewToBack:</code>或<code>exchangeSubviewAtIndex:withSubviewAtIndex:</code>方法。使用这些方法比移除子视图或重新插入它们更快。</li>
<li>要从父视图中移除一个子视图，在子视图上调用<code>removeFromSuperview</code>方法。</li>
</ul>
<p>添加一个子视图到另一个视图中最常见的例子发生在<code>application:didFinishLaunchingWithOptions:</code>方法中。下面显示了一个该方法的版本，它将视图从应用程序的主视图控制器安装到应用程序的<code>window</code>。<code>window</code>和视图控制器都是储存在应用程序的主<code>nib</code>文件中，它会在该方法调用前被加载。然而，由视图控制器管理的视图层级实际上不会加载，直到<code>view</code>属性被访问。</p>
<p>添加一个子视图到<code>window</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    <span class="comment">// Add the view controller's view to the window and display.</span></span><br><span class="line">    [window addSubview:viewController.view];</span><br><span class="line">    [window makeKeyAndVisible];</span><br><span class="line"><span class="keyword">return</span> YES; &#125;</span><br></pre></td></tr></table></figure>
<p>另一个常见的地方你可能添加子视图到视图层级中是在视图控制器的<code>loadView</code>和<code>viewDidLoad</code>方法中。如果你正在利用程序构建视图，你讲创建视图的代码放在视图控制器的<code>loadView</code>方法中。无论你是使用程序的方式，还是使用<code>nib</code>文件加载的方式来创建视图，你可能会在<code>viewDidLoad</code>方法中包含额外的视图配置代码。</p>
<p>添加视图到已存在的视图层级：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">      [super viewDidLoad];</span><br><span class="line">      self.title = NSLocalizedString(@<span class="string">"TransitionsTitle"</span>, @<span class="string">""</span>);</span><br><span class="line"><span class="comment">// create the container view which we will use for transition animation (centered horizontally)</span></span><br><span class="line">      CGRect frame = CGRectMake(round((self.view.bounds.size.width - kImageWidth) /</span><br><span class="line">   <span class="number">2.0</span>),</span><br><span class="line">                                                        kTopPlacement, kImageWidth,</span><br><span class="line">   kImageHeight);</span><br><span class="line">      self.containerView = [[[UIView alloc] initWithFrame:frame] autorelease];</span><br><span class="line">      [self.view addSubview:self.containerView];</span><br><span class="line">      <span class="comment">// The container view can represent the images for accessibility.</span></span><br><span class="line">      [self.containerView setIsAccessibilityElement:YES];</span><br><span class="line">      [self.containerView setAccessibilityLabel:NSLocalizedString(@<span class="string">"ImagesTitle"</span>,</span><br><span class="line">  @<span class="string">""</span>)];</span><br><span class="line">      <span class="comment">// create the initial image view</span></span><br><span class="line">      frame = CGRectMake(<span class="number">0.0</span>, <span class="number">0.0</span>, kImageWidth, kImageHeight);</span><br><span class="line">      self.mainView = [[[UIImageView alloc] initWithFrame:frame] autorelease];</span><br><span class="line">      self.mainView.image = [UIImage imageNamed:@<span class="string">"scene1.jpg"</span>];</span><br><span class="line">      [self.containerView addSubview:self.mainView];</span><br><span class="line">      <span class="comment">// create the alternate image view (to transition between)</span></span><br><span class="line">CGRect imageFrame = CGRectMake(<span class="number">0.0</span>, <span class="number">0.0</span>, kImageWidth, kImageHeight); self.flipToView = [[[UIImageView alloc] initWithFrame:imageFrame] autorelease];</span><br><span class="line">      self.flipToView.image = [UIImage imageNamed:@<span class="string">"scene2.jpg"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你添加子视图到另一个视图，<code>UIKit</code>通知父视图和子视图这些改变。如果你实现了自定义视图，你可以覆盖以下方法来拦截这些通知：<code>willMoveToSuperview:</code>、<code>willMoveToWindow:</code>、<code>willRemoveSubview:</code>、<code>didAddSubview:</code>、<code>didMoveToSuperview</code>或<code>didMoveToWindow</code>。您可以使用这些通知以更新与您的视图层次中相关的任何状态信息或执行其他任务。</p>
<h3 id="隐藏视图">隐藏视图</h3><p>为了在视觉上隐藏视图，你可以通过设置<code>hidden</code>属性为<code>YES</code>或者设置<code>alpha</code>属性为<code>0.0</code>。一个隐藏的视图不从系统接收触摸事件。然而，隐藏的视图仍然参与到自动调整大小和其他关联视图层级的布局操作。因此，当你需要从视图层级移除视图，隐藏视图通常是一个方便的选择，特别是如果你计划在某个点再重新显示视图。</p>
<p>如果你想动画一个视图，从可见过渡到隐藏（或者相反），你必须使用视图的<code>alpha</code>属性。因为<code>hidden</code>属性不是一个可动画的属性，所以你在上面做的改变会立即发生。</p>
<h3 id="在视图层级中定位视图">在视图层级中定位视图</h3><p>有两种方法在视图层级中定位视图：</p>
<ul>
<li>在适合的位置存储任何有关视图的指针，例如，在拥有该视图的视图控制器。</li>
<li>分配一个唯一的整数到每个视图的<code>tag</code>属性，然后使用<code>viewWithTag:</code>来定位它。</li>
</ul>
<p>储存相关视图的引用是最常见定位视图的方式，且使得访问这些视图非常容易。如果你使用<code>Interface Builder</code>来创建你的视图，你可以在你的<code>nib</code>文件中使用<code>outlets</code>连接对象到另一个。对于你用程序创建的视图，你可以在私有成员变量中保存这些视图的引用。无论你是使用<code>outlets</code>还是私有成员变量，你负责在需要时保留视图，或者释放它们。保证对象保留和释放最好的办法是使用声明的属性。</p>
<p>标签是减少硬编码依赖和支持动态和灵活的解决方案的有效方式。而不是保存视图的指针，你可以使用<code>tag</code>来定位它。标签也是引用视图的一种更持久的方式。</p>
<h3 id="平移，缩放和旋转视图">平移，缩放和旋转视图</h3><p>每个视图有一个关联的仿射变换，你可以使用它来平移、伸缩和旋转视图的内容。视图变换改变视图的最终渲染外观，且通常用于实现滚动，动画，或其他视觉效果。</p>
<p><code>UIView</code>的<code>transform</code>属性包含了一个应用变换的<code>CGAffineTransform</code>结构。默认情况下，这个属性被设置为恒等变换，不修改视图的外观。你可以在任何时候给该属性赋一个新的变换。例如，将一个视图旋转45度，你可以使用以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// M_PI/4.0 is one quarter of a half circle, or 45 degrees.</span></span><br><span class="line">CGAffineTransform xform = CGAffineTransformMakeRotation(M_PI/<span class="number">4.0</span>);</span><br><span class="line">self.view.transform = xform;</span><br></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/rotated_view.jpg" alt="enter image description here"></p>
<h2 id="在视图层级中转换坐标">在视图层级中转换坐标</h2><p>在不同的时间，特别是处理事件时，应用程序可能需要从一个框架的引用到另一个之间转换坐标值。例如，触摸事件是在<code>window</code>坐标系统中报告每一次触摸的位置，但是视图对象通常在视图的局部坐标系统中需要这些信息。<code>UIView</code>类定义了以下方法来转换坐标：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">convertPoint:fromView:</span><br><span class="line">convertRect:fromView:</span><br><span class="line">convertPoint:toView:</span><br><span class="line">convertRect:toView:</span><br></pre></td></tr></table></figure>
<p><code>convert...:fromView:</code>方法从其他视图坐标系统转换坐标到当前视图的局部坐标系统。相反的，<code>convert...:toView:</code>方法从当前视图坐标系统转换坐标到指定的视图的坐标系统。如果对于任何方法你指定<code>nil</code>为引用的视图，是从包含当前视图的<code>window</code>的坐标系统中转换。</p>
<p>除了<code>UIView</code>的转换方法，<code>UIWindow</code>类也同样定义了几个转换方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">convertPoint:fromWindow:</span><br><span class="line">convertRect:fromWindow:</span><br><span class="line">convertPoint:toWindow:</span><br><span class="line">convertRect:toWindow:</span><br></pre></td></tr></table></figure>
<h2 id="实现自定义视图的清单">实现自定义视图的清单</h2><p>自定义视图的工作是呈现内容和管理与这些内容的交互。一个成功的自定义视图的实现包含了不仅绘制和事件处理。在实现自定义视图时，下面的清单包括了你应该覆盖的比较重要的方法：</p>
<ul>
<li>为你的视图定义相应的初始化方法：<ul>
<li>对于你想用程序创建的视图，覆盖<code>initWithFrame:</code>方法，或者定义一个自定义初始化方法</li>
<li>对于你想从<code>nib</code>文件加载的视图，覆盖<code>initWithCoder:</code>方法。</li>
</ul>
</li>
<li>实现一个<code>dealloc</code>方法处理任何自定义数据的清理工作。</li>
<li>要处理自定义的绘制，覆盖<code>drawRect:</code>方法，并在其中实现你的绘制代码。</li>
<li>设置视图的<code>autoresizingMask</code>属性以定义它的自动调整大小行为。</li>
<li>如果你的视图类管理一个或多个完整的子视图，做以下几点：<ul>
<li>在你的视图初始化阶段创建这些子视图</li>
<li>对于每个子视图在创建时设置<code>autoresizingMask</code>属性</li>
<li>如果你的子视图需要自定义布局，覆盖<code>layoutSubviews</code>方法，并在其中实现你的布局代码</li>
</ul>
</li>
<li>为了处理触摸相关的事件，做以下几点：<ul>
<li>使用<code>addGestureRecognizer:</code>方法附加任何合适的手势识别到视图中</li>
<li>对于你要自己处理触摸的情况下，覆盖<code>touchesBegan:withEvent:</code>、<code>touchesMoved:withEvent:</code>、<code>touchesEnded:withEvent:</code>和<code>touchesCancelled:withEvent:</code>方法</li>
</ul>
</li>
<li>如果你想你视图的绘制版本看起来不同于屏幕上的版本，实现<code>drawRect:forViewPrintFormatter:</code>方法</li>
</ul>
<h2 id="动画">动画</h2><h3 id="使用基于块的方法开始动画">使用基于块的方法开始动画</h3><p>在iOS4和以后，你可以使用基于块的类方法来初始化动画。有几个基于块的方法为动画块提供了不同级别的配置。它们为：</p>
<ul>
<li><code>animateWithDuration:animations:</code></li>
<li><code>animateWithDuration:animations:completion:</code></li>
<li><code>animateWithDuration:delay:options:animations:completion:</code></li>
</ul>
<p>因为它们是类方法，使用它们创建的动画块不依赖于单个视图。因此，你可以使用该方法来创建一个包含改变多个视图的动画。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[UIView animateWithDuration:<span class="number">1.0</span> animations:^&#123;</span><br><span class="line">          firstView.alpha = <span class="number">0.0</span>;</span><br><span class="line">          secondView.alpha = <span class="number">1.0</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>如果你想对动画有更多的配置，那就要使用<code>animateWithDuration:delay:options:animations:completion:</code>了，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)showHideView:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">// Fade out the view right away</span></span><br><span class="line">      [UIView animateWithDuration:<span class="number">1.0</span></span><br><span class="line">          delay: <span class="number">0.0</span></span><br><span class="line">          options: UIViewAnimationOptionCurveEaseIn</span><br><span class="line">          animations:^&#123;</span><br><span class="line">               thirdView.alpha = <span class="number">0.0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          completion:^(BOOL finished)&#123;</span><br><span class="line">            <span class="comment">// Wait one second and then fade in the view</span></span><br><span class="line">        [UIView animateWithDuration:<span class="number">1.0</span></span><br><span class="line">             delay: <span class="number">1.0</span></span><br><span class="line">             options:UIViewAnimationOptionCurveEaseOut</span><br><span class="line">             animations:^&#123;</span><br><span class="line">                thirdView.alpha = <span class="number">1.0</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             completion:nil];</span><br><span class="line">          &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建在视图间过渡的动画">创建在视图间过渡的动画</h3><p>当在视图层级中添加、移除、隐藏和展示视图时，视图间过渡帮助你隐藏立即的改变。你可以使用视图过渡去实现以下类型的改变：</p>
<ul>
<li>更改现有视图的可见子视图</li>
<li>在你的视图层级中替换某个视图为另外一个视图</li>
</ul>
<h4 id="改变一个视图的子视图">改变一个视图的子视图</h4><p>在iOS4及以后，你可以使用<code>transitionWithView:duration:options:animations:completion:</code>方法来为视图初始化一个过渡动画。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)displayNewPage:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    [UIView transitionWithView:self.view</span><br><span class="line">        duration:<span class="number">1.0</span></span><br><span class="line">        options:UIViewAnimationOptionTransitionCurlUp</span><br><span class="line">        animations:^&#123;</span><br><span class="line">            currentTextView.hidden = YES;</span><br><span class="line">            swapTextView.hidden = NO;</span><br><span class="line">        &#125;</span><br><span class="line">        completion:^(BOOL finished)&#123;</span><br><span class="line">            <span class="comment">// Save the old text and then swap the views.</span></span><br><span class="line">            [self saveNotes:temp];</span><br><span class="line">            UIView*    temp = currentTextView;</span><br><span class="line">      currentTextView = swapTextView;</span><br><span class="line">      swapTextView = temp;</span><br><span class="line">&#125;]; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="替换视图为不同的视图">替换视图为不同的视图</h4><p>在iOS4及以后，你可以使用<code>transitionFromView:toView:duration:options:completion:</code>方法在视图间过渡。这个方法实际会将第一个视图从你的层级中移除，然后插入另外一个，因此，你应该确保如果你想保持第一个视图时，你有一个到第一个视图的引用。如果你想隐藏视图来代替从视图层级中移除，传递<code>UIViewAnimationOptionShowHideTransitionViews</code>关键字作为选项。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)toggleMainViews:(id)sender &#123;</span><br><span class="line">    [UIView transitionFromView:(displayingPrimary ? primaryView : secondaryView)</span><br><span class="line">    toView:(displayingPrimary ? secondaryView : primaryView)</span><br><span class="line">    duration:<span class="number">1.0</span></span><br><span class="line">    options:(displayingPrimary ? UIViewAnimationOptionTransitionFlipFromRight : UIViewAnimationOptionTransitionFlipFromLeft)</span><br><span class="line">  completion:^(BOOL finished) &#123;</span><br><span class="line">      <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">          displayingPrimary = !displayingPrimary;</span><br><span class="line">      &#125;</span><br><span class="line">  )];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/18/ios-uiview/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/05/18/ios-uiview/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分類</p>
		<ul>
		
		  
			<li><a href="/categories/CSS/" title="CSS">CSS<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript/" title="JavaScript">JavaScript<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/生活/" title="生活">生活<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">標簽</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/JavaScript/" title="JavaScript">JavaScript<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/CSS3/" title="CSS3">CSS3<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS/" title="iOS">iOS<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Flexbox/" title="Flexbox">Flexbox<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/生活/" title="生活">生活<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Transform/" title="Transform">Transform<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Media-Query/" title="Media Query">Media Query<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Animation/" title="Animation">Animation<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/selector/" title="selector">selector<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情鏈接</p>
    <ul>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 訂閱</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> keep coding <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/https://github.com/cookfront" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:cookfront@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="http://cookfront.github.io/about" target="_blank" title="cookfront@gmail.com">cookfront@gmail.com</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"cookfront"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 









<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?1e9fdadfaa36dffc9a8914a1220e8161";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回頂部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>

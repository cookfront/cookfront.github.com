
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Cookfront&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="cookfront@gmail.com">
    

    
    <meta name="description" content="Cookfront&apos;s Blog，前端开发，HTML，CSS，JavaScript，jQuery，HTML5，CSS3，Sass Compass，Node.js">
<meta property="og:type" content="website">
<meta property="og:title" content="Cookfront's Blog">
<meta property="og:url" content="http://cookfront.github.io/index.html">
<meta property="og:site_name" content="Cookfront's Blog">
<meta property="og:description" content="Cookfront&apos;s Blog，前端开发，HTML，CSS，JavaScript，jQuery，HTML5，CSS3，Sass Compass，Node.js">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cookfront's Blog">
<meta name="twitter:description" content="Cookfront&apos;s Blog，前端开发，HTML，CSS，JavaScript，jQuery，HTML5，CSS3，Sass Compass，Node.js">

    
    <link rel="alternative" href="/atom.xml" title="Cookfront&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Cookfront&#39;s Blog" title="Cookfront&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Cookfront&#39;s Blog">Cookfront&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:cookfront.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/06/es6-function/" title="每天学点ES6－函数" itemprop="url">每天学点ES6－函数</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-06-06T01:59:42.000Z" itemprop="datePublished"> 發表於 2015-06-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文翻译自：<a href="https://leanpub.com/understandinges6/read#leanpub-auto-objectis" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-objectis</a>，内容有删减，仅作为阅读笔记。</p>
<p><code>ES6</code>中的函数增加了很多新特性，使得在<code>JavaScript</code>中编程不容易出错，且比以往任何时候还要强大。<code>ES6</code>的函数主要带来了以下扩展：参数的默认值、<code>rest</code>参数、解构参数、扩展（Spread）运算符、<code>name</code>属性、箭头函数等。下面就一一介绍。</p>
<h2 id="参数默认值">参数默认值</h2><p>在<code>JavaScript</code>中，我们可以给函数传入任意多个参数，而不需要管它实际定义的形参个数。这允许我们定义的函数可以处理参数不同的情况，我们可以为没有指定的参数默认值。在<code>ES5</code>中我们可以经常看到下面这样的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span><span class="params">(url, timeout, callback)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    timeout = timeout || <span class="number">2000</span>;</span><br><span class="line">    callback = callback || <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the rest of the function</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>timeout</code>和<code>callback</code>都是可选的，因为在没有传相应的参数时，它们有默认值<code>2000</code>和<code>function() {}</code>。我们经常用这种方式来实现默认参数。</p>
<p><code>ES6</code>中对函数进行了扩展，添加了<code>参数默认值</code>，在没有传入相应参数时，会使用你在定义函数时给定的默认值，而不是像<code>ES5</code>中那样对每个参数还要做一次判断。在<code>ES6</code>中我们可以这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function makeRequest(url, timeout = 2000, callback = function() &#123;&#125;) &#123;</span><br><span class="line"></span><br><span class="line">    // the rest of the function</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样只有我们的第一个参数是期望传入的，而其他两个参数都有默认值，这使得函数更加简洁，我们不需要去判断是否某个参数没有被传入，就像<code>timeout = timeout || 2000;</code>这样。当<code>makeRequest()</code>调用时传入了所有的三个参数时，默认参数就不会被使用了。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uses default timeout and callback</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// uses default callback</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// doesn't use defaults</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>, <span class="number">500</span>, <span class="function"><span class="keyword">function</span><span class="params">(body)</span> </span>&#123;</span><br><span class="line">    doSomething(body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>任何参数有默认值时我们认为它是可选的，而那些没有默认值的参数我们认为是必须的参数。</p>
<h2 id="Rest参数">Rest参数</h2><p>上面也说到<code>JavaScript</code>中是可以传入任意多个参数，有时候我们没有必要指定所有的参数。在以前我们可以通过<code>arguments</code>函数的所有参数，虽然这在大多数情况下可以工作的很好，但是还是会有一点小累赘。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = first,</span><br><span class="line">        i = <span class="number">1</span>,</span><br><span class="line">        len = <span class="built_in">arguments</span>.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">        result += <span class="built_in">arguments</span>[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数将所有传入的参数相加，例如我们可以<code>sum(1)</code>或者<code>sum(1, 2, 3, 4)</code>都是可以的。但这个函数我们有几件事情要注意。第一、函数不能明显的看出可以处理一个以上的参数。第二、因为我们指定了一个<code>first</code>参数，那我们就必须从<code>arguments</code>的索引1开始，而不是索引0。当然记住正确的索引并不是很困难，但是还是需要我们关注的一件事。<code>ES6</code>为我们提供了<code>rest</code>参数来解决这个问题。</p>
<p><code>rest</code>参数由三个<code>.</code>加上参数名字来表示，那个参数名字成为一个数组包含了参数的其余部分。例如，<code>sum()</code>函数可以使用<code>rest</code>参数重写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(first, ...numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = first,</span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        len = numbers.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">        result += numbers[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个版本的函数中，我们可以看到<code>numbers</code>包含了除<code>first</code>参数之外的剩余参数。这意味着我们可以从<code>0</code>开始遍历<code>numbers</code>，而不需要有任何顾虑。我们也可以很容易的看出函数可以处理任意多个参数。</p>
<p>对于<code>rest</code>参数有一个限制就是，在<code>rest</code>参数后不能再跟其他函数，否则会语法错误。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Syntax error: Can't have a named parameter after rest parameters</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(first, ...numbers, last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = first,</span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        len = numbers.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">        result += numbers[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参数解构">参数解构</h2><p>在前面我们学过变量解构，解构同样也可以使用在函数的参数中。</p>
<p>通常我们会使用一个<code>options</code>对象作为一个参数来代替传入多个参数，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span><span class="params">(name, value, options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    options = options || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> secure = options.secure,</span><br><span class="line">        path = options.path,</span><br><span class="line">        domain = options.domain,</span><br><span class="line">        expires = options.expires;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>, &#123;</span><br><span class="line">    secure: <span class="literal">true</span>,</span><br><span class="line">    expires: <span class="number">60000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>除了<code>name</code>和<code>value</code>是必须的之外，其他数据没有顺序优先级，这里我们使用了一个<code>options</code>对象来代替，而不是额外的命名参数。这种方式是<code>OK</code>的，但是给我们的函数带来了不透明性。</p>
<p>使用参数解构，之前的函数可以被重写为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span><span class="params">(name, value, &#123; secure, path, domain, expires &#125;)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>, &#123;</span><br><span class="line">    secure: <span class="literal">true</span>,</span><br><span class="line">    expires: <span class="number">60000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个例子和前面的不同之处在于使用了参数解构取出了必要的数据。这样使得更清楚的知道需要什么样的参数。参数解构和变量解构一样，如果没有传入相应数据时，其值为<code>undefined</code>。</p>
<p>有一点需要注意的是，当我们在上面的函数中没有传入第三个参数时，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error!</span></span><br><span class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>);</span><br></pre></td></tr></table></figure>
<p>这个代码是会报错的，在内部执行时其实是像下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span><span class="params">(name, value, options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> &#123; secure, path, domain, expires &#125; = options;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为变量解构时，当右边的表达式为<code>null</code>或<code>undefined</code>时是会报错的。不过我们可以通过传入一个默认的空对象来解决这个问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span><span class="params">(name, value, &#123; secure, path, domain, expires &#125; = &#123;&#125;)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展运算符">扩展运算符</h2><p>扩展运算符和<code>rest</code>参数正好相反，<code>rest</code>参数允许我们将多个独立的参数合并成一个数组，而扩展运算符允许我们将一个数组分割，每个元素作为独立参数传入到函数中。我们可以考虑<code>Math.max()</code>方法，我们可以传入任意多个参数，然后返回最大的那个参数值。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value1 = <span class="number">25</span>,</span><br><span class="line">    value2 = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(value1, value2));      <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<p>当只有几个参数时我们很好处理，但是当我们的值存在一个数组中时我们应该怎么办呢？在<code>ES5</code>中我们可以通过<code>apply</code>来操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values));  <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<p><code>ES6</code>的扩展运算符使这种情况变得更加简单。你可以通过在数组名前面加上<code>...</code>传入函数中，就像<code>rest</code>参数那样。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// equivalent to</span></span><br><span class="line"><span class="comment">// console.log(Math.max(25, 50, 75, 100));</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values));           <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<p>你也可以混合使用扩展运算符和其他参数。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [-<span class="number">25</span>, -<span class="number">50</span>, -<span class="number">75</span>, -<span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values, <span class="number">0</span>));        <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h2 id="name属性"><code>name</code>属性</h2><p><code>ES6</code>为所有函数添加了一个<code>name</code>属性，在<code>ES6</code>的程序中所有的函数的<code>name</code>属性都确保有一个合适的值。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doAnotherThing = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doSomething.name);          <span class="comment">// "doSomething"</span></span><br><span class="line"><span class="built_in">console</span>.log(doAnotherThing.name);       <span class="comment">// "doAnotherThing"</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，<code>doSomething()</code>函数的<code>name</code>属性值为<code>doSomething</code>，因为他是一个函数声明。在匿名函数表达式中，<code>doAnotherThing()</code>的<code>name</code>属性值为<code>doAnotherThing</code>。</p>
<p>下面看个更详细的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    get firstName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Nicholas"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doSomething.name);      <span class="comment">// "doSomethingElse"</span></span><br><span class="line"><span class="built_in">console</span>.log(person.sayName.name);   <span class="comment">// "sayName"</span></span><br><span class="line"><span class="built_in">console</span>.log(person.firstName.name); <span class="comment">// "get firstName"</span></span><br></pre></td></tr></table></figure>
<p>对于函数名还有几种特殊情况。对于使用<code>bind()</code>创建的函数会在它们的函数名前加上<code>bound</code>前缀。对于使用<code>Function</code>构造函数创建的函数它的名字为<code>anonymous</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doSomething.bind().name);   <span class="comment">// "bound doSomething"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>()).name);     <span class="comment">// "anonymous"</span></span><br></pre></td></tr></table></figure>
<h2 id="new-target，[[Call]]和[[Construct]]"><code>new.target</code>，<code>[[Call]]</code>和<code>[[Construct]]</code></h2><p>在<code>ES5</code>甚至更早，函数服务于双重目的，通过<code>new</code>来调用或没有<code>new</code>。当使用<code>new</code>时，函数内的<code>this</code>值是返回的新对象。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> notAPerson = Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person);        <span class="comment">// "[Object object]"</span></span><br><span class="line"><span class="built_in">console</span>.log(notAPerson);    <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure>
<p>当没有使用<code>new</code>调用<code>Person()</code>时，返回<code>undefined</code>。这里很明显的是这段代码的意图是使用<code>Person</code>和<code>new</code>来创建一个对象。在<code>ES6</code>中，在函数双重角色的困惑上做了一些改变。</p>
<p>第一、规范定义了两个不同的仅在内部使用的方法，每个函数都有：<code>[[Call]]</code>和<code>[[Construct]]</code>。当一个函数没有通过<code>new</code>来调用时，<code>[[Call]]</code>方法会被执行。当一个函数通过<code>new</code>来调用时，<code>[[Construct]]</code>被调用。<code>[[Construct]]</code>方法有责任创建一个新的对象。被称之为<code>new target</code>，然后执行函数体，<code>this</code>的值被设置为<code>new target</code>。有一个<code>[[Construct]]</code>方法的函数被称之为<code>构造函数</code>。</p>
<blockquote>
<p>要注意的是不是所有的函数都有<code>[[Construct]]</code>，也不是所有的函数能通过<code>new</code>来调用。箭头函数，将在后面介绍到，没有<code>[[Construct]]</code>方法。</p>
</blockquote>
<p>在<code>ES5</code>中，最流行的方式来决定一个函数能否通过<code>new</code>来调用是使用<code>instanceof</code>操作符。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;   <span class="comment">// using new</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> notAPerson = Person(<span class="string">"Nicholas"</span>);  <span class="comment">// throws error</span></span><br></pre></td></tr></table></figure>
<p>在这里，<code>this</code>的值会被检查是否为构造函数的实例，如果是的话，它继续正常执行。如果不是，就会抛出一个异常。这个能工作是因为<code>[[Construct]]</code>方法创建了<code>Person</code>的一个新实例，并将它赋给了<code>this</code>。不幸的是，这种方式不是完全可信的，<code>this</code>的值可以不通过<code>new</code>的方式也可以为<code>Person</code>的实例，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;   <span class="comment">// using new</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">"Michael"</span>);    <span class="comment">// works!</span></span><br></pre></td></tr></table></figure>
<p>我们这里通过<code>Person.call()</code>，并且传递<code>person</code>对象作为第一个参数，这就使得无法区分<code>this</code>是通过<code>new</code>创建的还是其他方式。</p>
<p>为了解决这个问题，<code>ES6</code>引入了<code>new.target</code>元属性。当一个函数的<code>[[Construct]]</code>被调用，<code>new.target</code>会成为新创建对象的实例，这个值也会在函数内成为<code>this</code>的值。如果<code>[[Call]]</code>被执行，<code>new.target</code>为<code>undefined</code>。这意味着我们现在可以通过检查<code>new.target</code>是否被定义安全的检查函数是否是通过<code>new</code>的方式被调用。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;   <span class="comment">// using new</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">"Michael"</span>);    <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<h2 id="箭头函数">箭头函数</h2><p><code>ES6</code>中新添加了一个箭头函数，就如它的名字，函数通过一种新的语法，使用箭头<code>=&gt;</code>来定义。然而，箭头函数在有些方面和传统的<code>JavaScript</code>函数是不同的：</p>
<ul>
<li>词法的<code>this</code>绑定：在该函数内的<code>this</code>是通过定义箭头函数的地方决定，而不是使用它的地方决定。</li>
<li>不能当作构造函数：箭头函数没有<code>[[Construct]]</code>方法，因此它不能作为构造函数。当箭头函数与<code>new</code>一起使用时将会抛出异常。</li>
<li>不可以改变<code>this</code>值：在函数内的<code>this</code>的值是不能改变的，它在函数的整个生命周期中保持相同的值。</li>
<li>没有<code>arguments</code>对象：你不能通过<code>arguments</code>对象来获取参数，你必须使用命名参数或者<code>rest</code>参数等。</li>
</ul>
<p>其中有一些原因来表明这些不同为什么存在。首先，<code>this</code>的绑定在<code>JavaScript</code>是一个常见的错误根源。在一个函数内对<code>this</code>值的跟踪是非常容易丢失的，这可能会导致意想不到的后果。第二，通过限制箭头函数在执行代码时只有单一的<code>this</code>值，<code>JavaScript</code>引擎能更好的优化操作。</p>
<h3 id="语法">语法</h3><p>箭头函数的语法有多种风格，这取决于你试图完成什么。所有的变种（箭头函数的多种风格）都是以函数参数开始，跟着箭头，跟着函数体。参数和函数体取决于使用可以采取不同的形式。例如，下面的箭头函数接受一个单一参数和简单的返回它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reflect = value =&gt; value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// effectively equivalent to:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reflect = <span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当箭头函数只有一个参数时，我们只需直接使用这个参数而不需要其他的语法。然后箭头函数的右边会被计算和返回。即使我们这没有一个明确的<code>return</code>声明，箭头函数会返回传入的第一个参数。</p>
<p>如果你传入的参数个数大于1时，你就需要圆括号将参数用括号扩起来啦。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = (num1, num2) =&gt; num1 + num2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// effectively equivalent to:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span><span class="params">(num1, num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sum()</code>函数将两个参数相加并返回结果。不同之处在于我们的参数放在圆括号内，且用<code>,</code>分隔。</p>
<p>需要注意的是，当我们的箭头函数没有参数时，我们必须包含一个空圆括号。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName = () =&gt; <span class="string">"Nicholas"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// effectively equivalent to:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Nicholas"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当你需要提供一个更传统的函数体时，可能包含多个表达式，那么我们可以将这些语句放在花括号<code>{}</code>内，并且定义一个明确的返回值。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = (num1, num2) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// effectively equivalent to:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span><span class="params">(num1, num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当你需要创建一个什么也不做的函数时，我们需要包括花括号，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doNothing = () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// effectively equivalent to:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doNothing = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>还有一点需要注意的是，因为花括号被用于包含函数体，当我们需要从箭头函数返回一个对象直接量时，我们需要将直接量放在圆括号内。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getTempItem = id =&gt; (&#123; id: id, name: <span class="string">"Temp"</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// effectively equivalent to:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getTempItem = <span class="function"><span class="keyword">function</span><span class="params">(id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        id: id,</span><br><span class="line">        name: <span class="string">"Temp"</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="词法的this绑定">词法的<code>this</code>绑定</h3><p>在<code>JavaScript</code>中最常见出错的地方就是<code>this</code>在函数内的绑定。因为<code>this</code>的值可以根据调用它的上下文在单个函数内改变，这就可能错误的使用影响某个对象，但你的意图是另外一个对象。考虑以下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line"></span><br><span class="line">    id: <span class="string">"123456"</span>,</span><br><span class="line"></span><br><span class="line">    init: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.doSomething(event.type);     <span class="comment">// error</span></span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    doSomething: <span class="function"><span class="keyword">function</span><span class="params">(type)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type  + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们知道<code>this.doSomething</code>中的<code>this</code>对象其实是指向<code>document</code>的，但我们的本意其实是<code>PageHandler</code>对象。如果你试图运行代码，会得到一个错误。你可能会使用<code>bind</code>或<code>var me = this</code>的方式来解决这个问题。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind way</span></span><br><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line"></span><br><span class="line">    id: <span class="string">"123456"</span>,</span><br><span class="line"></span><br><span class="line">    init: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, (<span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.doSomething(event.type);     <span class="comment">// no error</span></span><br><span class="line">        &#125;).bind(<span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    doSomething: <span class="function"><span class="keyword">function</span><span class="params">(type)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type  + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var me = this;</span></span><br><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line"></span><br><span class="line">    id: <span class="string">"123456"</span>,</span><br><span class="line"></span><br><span class="line">    init: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">var</span> me = <span class="keyword">this</span>;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span><br><span class="line">            me.doSomething(event.type);     <span class="comment">// no error</span></span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    doSomething: <span class="function"><span class="keyword">function</span><span class="params">(type)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type  + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在代码如你预期的那样执行了，但是我们总会觉得有些奇怪。通过调用<code>bind(this)</code>，你实际上是创建了一个新的函数，新函数的<code>this</code>被绑定到了<code>PageHandler</code>。</p>
<p>但是在箭头函数内，它具有隐式<code>this</code>绑定，这意味着箭头函数内的<code>this</code>值总是与定义箭头函数的作用域的<code>this</code>具有相同的值。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line"></span><br><span class="line">    id: <span class="string">"123456"</span>,</span><br><span class="line"></span><br><span class="line">    init: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>,</span><br><span class="line">                event =&gt; <span class="keyword">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    doSomething: <span class="function"><span class="keyword">function</span><span class="params">(type)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type  + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在<code>this</code>的值和<code>init()</code>内的<code>this</code>值是一样的，它就能用<code>bind</code>的方式实现一样的功能了。</p>
<p>箭头函数被设计为“一次性“函数，所以它不能用于定义新的类型。它和普通的函数不同，它没有<code>prototype</code>属性。如果你尝试在箭头函数上使用<code>new</code>操作符，就会报错。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyType = () =&gt; &#123;&#125;,</span><br><span class="line">    object = <span class="keyword">new</span> MyType();  <span class="comment">// error - you can't use arrow functions with 'new'</span></span><br></pre></td></tr></table></figure>
<p>因为<code>this</code>的值是静态绑定到箭头函数上，你不能通过<code>apply()</code>、<code>call()</code>或<code>bind()</code>的方式来改变<code>this</code>的值。</p>
<h3 id="词法arguments绑定">词法<code>arguments</code>绑定</h3><p>尽管箭头函数自身没有<code>arguments</code>对象，但是它能获取到包含它的函数的<code>arguments</code>对象。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArrowFunctionReturningFirstArg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> () =&gt; <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrowFunction = createArrowFunctionReturningFirstArg(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arrowFunction());</span><br></pre></td></tr></table></figure>
<h3 id="识别箭头函数">识别箭头函数</h3><p>尽管语法不同，箭头函数同样也是函数，它也可以被识别：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> comparator = (a, b) =&gt; a - b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> comparator);                 <span class="comment">// "function"</span></span><br><span class="line"><span class="built_in">console</span>.log(comparator <span class="keyword">instanceof</span> <span class="built_in">Function</span>);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>至此，就是本文的全部内容啦。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScript/">JavaScript</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/06/es6-function/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/06/06/es6-function/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/04/es6-string/" title="每天学点ES6－字符串" itemprop="url">每天学点ES6－字符串</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-06-04T05:19:42.000Z" itemprop="datePublished"> 發表於 2015-06-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><code>ES6</code>中对字符串进行了很多扩展，包括加强了<code>Unicode</code>的支持、</p>
<h2 id="更好的Unicode支持">更好的Unicode支持</h2><p>在<code>ES6</code>之前，<code>JavaScript</code>的字符串是完全基于16位字符编码的想法。所有字符串的属性和方法，例如：<code>length</code>和<code>charAt()</code>，都是基于16位序列代表单个字符的想法。<code>ES5</code>还允许<code>Javascript</code>引擎决定使用哪种编码方式，<code>UCS-2</code>或<code>UTF-16</code>。</p>
<p>对于<code>Unicode</code>的既定目标，保持在16位是不可能的为全世界的每一个字符提供一个全局唯一的标识符。这些全局唯一标志服被称之为<code>code point</code>，且从0开始。一个字符串编码有责任编码一个<code>code point</code>为<code>code unit</code>，且保持内部一致。</p>
<p>第一个<code>2^16</code>个<code>code point</code>在<code>UTF-16</code>中被表示为单一的16位<code>code unit</code>。这被称之为<code>Basic Multilingual Plane (BMP)</code>。超出该范围的被认为是在一个辅助平面，<code>code point</code>已不能仅仅用16位来表示了。<code>UTF-16</code>通过引入<code>surrogate pairs(代理对)</code>来解决这个问题，一个<code>code point</code>可以由两个16位的<code>code unit</code>来表示。这意味着字符串中的任何单个字符可以由一个<code>code unit</code>或两个来表示。</p>
<p>在<code>ES5</code>中所有的操作都是基于16位的<code>code unit</code>，这意味着你在处理包含<code>代理对</code>的字符串时会出现意想不到的结果。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"𠮷"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(text.length);           <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/</span>.test(text));      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(text.charAt(<span class="number">0</span>));        <span class="comment">// ""</span></span><br><span class="line"><span class="built_in">console</span>.log(text.charAt(<span class="number">1</span>));        <span class="comment">// ""</span></span><br><span class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">0</span>));    <span class="comment">// 55362</span></span><br><span class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">1</span>));    <span class="comment">// 57271</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，单个<code>Unicode</code>字符是使用<code>代理对</code>来表示的，<code>JavaScript</code>字符操作会认为字符串由两个16位的字符组成。这意味着<code>length</code>为2，通过正则表达式匹配单个字符也失败了，<code>charAt()</code>也无法读取字符。<code>charCodeAt()</code>方法为每个<code>code unit</code>返回了正确的16为数字。</p>
<p>在<code>ES6</code>中强制使用<code>UTF-16</code>来编码字符串。</p>
<h3 id="codePointAt()">codePointAt()</h3><p><code>codePointAt()</code>接受<code>code unit</code>的位置，并返回一个整数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"𠮷a"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">0</span>));    <span class="comment">// 55362</span></span><br><span class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">1</span>));    <span class="comment">// 57271</span></span><br><span class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">2</span>));    <span class="comment">// 97</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(text.codePointAt(<span class="number">0</span>));   <span class="comment">// 134071</span></span><br><span class="line"><span class="built_in">console</span>.log(text.codePointAt(<span class="number">1</span>));   <span class="comment">// 57271</span></span><br><span class="line"><span class="built_in">console</span>.log(text.codePointAt(<span class="number">2</span>));   <span class="comment">// 97</span></span><br></pre></td></tr></table></figure>
<p>当字符为<code>BMP</code>范围内的字符时，<code>codePointAt()</code>和<code>charCodeAt()</code>的行为是一样的，在非<code>BMP</code>字符时，<code>charCodeAt()</code>仅仅返回了位置<code>0</code>的<code>code unit</code>，但是<code>codePointAt()</code>返回了整个<code>code point</code>，即使横跨多个<code>code unit</code>。对于位置1和位置2的，它俩返回值是相同的。</p>
<p>用以下方法可以判断是否为16位，还是32位：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span><span class="params">(c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(is32Bit(<span class="string">"𠮷"</span>));         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(is32Bit(<span class="string">"a"</span>));          <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="String-fromCodePoint()">String.fromCodePoint()</h3><p><code>String.fromCodePoint()</code>就是和<code>codePointAt()</code>做相反的操作了。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">134071</span>));  <span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure>
<h3 id="编码非BMP字符">编码非<code>BMP</code>字符</h3><p>在<code>ES5</code>中允许字符包含用编码序列代表的16位<code>Unicode</code>字符。编码序列是通过<code>\u</code>加上4个16进制值，例如<code>\u0061</code>代表字符<code>a</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"\u0061"</span>);      <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure>
<p>但是当你用编码序列来代表大于<code>FFFF</code>的字符时，你会得到意想不到的结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"\u20BB7"</span>);</span><br></pre></td></tr></table></figure>
<p>因为<code>Unicode</code>编码序列总是包含4个16进制字符，<code>ECMAScript</code>计算<code>\u20BB7</code>为两个字符：<code>\u20BB</code>和<code>7</code>。第一个字符为非打印的，第二个为数字7。</p>
<p><code>ES6</code>通过引入扩展的<code>Unicode</code>编码序列解决了这个问题，将16进制数字包含在花括号内。这使得任何数量的十六进制字符可以指定为单个字符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"\u&#123;20BB7&#125;"</span>);     <span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure>
<p>通过下面的函数可以判断是否支持这种写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">supportsExtendedEscape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">"'\\u&#123;00FF1&#125;'"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式u修饰符">正则表达式<code>u</code>修饰符</h3><p>正则表达式也是基于16位的<code>code unit</code>来代表单个字符，这就对于<code>𠮷</code>在<code>/^.$/</code>的正则表达式中不能匹配，<code>ES6</code>为正则表达式定义了一个新的修饰符，<code>u</code>也即<code>Unicode</code>。当一个正则表达式设置了<code>u</code>修饰符时，它将切换模式为工作在字符串，而不是<code>code unit</code>。这意味着正则表达式在包含<code>代理对</code>的字符串中不会迷惑。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"𠮷"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(text.length);           <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/</span>.test(text));      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/u</span>.test(text));     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在添加了<code>u</code>修饰符的正则表达式能以字符的方式来匹配字符串，而不是<code>code unit</code>。</p>
<h2 id="新增的String方法">新增的<code>String</code>方法</h2><h3 id="includes()">includes()</h3><p>如果给定字符在字符串的任何位置被找到，则返回<code>true</code>，否则返回<code>false</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">"Hello world!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"ello"</span>));</span><br></pre></td></tr></table></figure>
<h3 id="startsWith()">startsWith()</h3><p>如果字符串以给定字符开始，则返回<code>true</code>，否则返回<code>false</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">"Hello world!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"Hello"</span>));</span><br></pre></td></tr></table></figure>
<h3 id="endsWith()">endsWith()</h3><p>如果字符串以给定字符结束，则返回<code>true</code>，否则返回<code>false</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">"Hello world!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"world!"</span>));</span><br></pre></td></tr></table></figure>
<h3 id="repeat()">repeat()</h3><p>该方法接受一个数字作为参数，表示将原字符串重复的次数。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"cookfront"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式修饰符y">正则表达式修饰符<code>y</code></h2><p><code>ES6</code>引入了新的正则表达式修饰符<code>y</code>，也即<code>粘连</code>，它与<code>g</code>修饰符比较类似，但是不同之处在于，<code>g</code>修饰符只确保剩余位置中存在匹配，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始，这也就是<code>粘连</code>的涵义。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"hello1 hello2 hello3"</span>,</span><br><span class="line">    pattern = <span class="regexp">/hello\d\s?/</span>,</span><br><span class="line">    result = pattern.exec(text),</span><br><span class="line">    globalPattern = <span class="regexp">/hello\d\s?/g</span>,</span><br><span class="line">    globalResult = globalPattern.exec(text),</span><br><span class="line">    stickyPattern = <span class="regexp">/hello\d\s?/y</span>,</span><br><span class="line">    stickyResult = stickyPattern.exec(text);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]);         <span class="comment">// "hello1 "</span></span><br><span class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]);   <span class="comment">// "hello1 "</span></span><br><span class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]);   <span class="comment">// "hello1 "</span></span><br><span class="line"></span><br><span class="line">pattern.lastIndex = <span class="number">1</span>;</span><br><span class="line">globalPattern.lastIndex = <span class="number">1</span>;</span><br><span class="line">stickyPattern.lastIndex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">result = pattern.exec(text);</span><br><span class="line">globalResult = globalPattern.exec(text);</span><br><span class="line">stickyResult = stickyPattern.exec(text);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]);         <span class="comment">// "hello1 "</span></span><br><span class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]);   <span class="comment">// "hello2 "</span></span><br><span class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]);   <span class="comment">// Error! stickyResult is null</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，使用了三个正则表达式，一个使用了<code>y</code>修饰符，一个使用了<code>g</code>修饰符，一个没有使用修饰符。第一次匹配时我们可以看到结果都为<code>hello1</code>，匹配后我们将<code>lastIndex</code>置为1，即从第二个字符开始匹配，我们可以看到第二次匹配的结果没有修饰符的还是匹配<code>hello1</code>，<code>g</code>修饰符的匹配<code>hello2</code>，<code>y</code>修饰符在从第二个字符开始没有匹配任何东西所以返回<code>null</code>。我们也可以看出了<code>y</code>修饰符号隐含了头部匹配的标志<code>^</code>。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScript/">JavaScript</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/04/es6-string/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/06/04/es6-string/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/02/es6-destructing/" title="每天学点ES6－变量解构" itemprop="url">每天学点ES6－变量解构</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-06-02T04:59:42.000Z" itemprop="datePublished"> 發表於 2015-06-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在<code>ES5</code>时，我们经常会在代码中看到类似下面这样的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">(options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = options.a;</span><br><span class="line">  <span class="keyword">var</span> b = options.b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了变量解构，我们就不用这么麻烦了，用一行代码就能实现，特别是在有多个变量时，这样写还是很烦的。用变量结构我们可以像下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">(options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> &#123;a, b&#125; = options;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量解构包括<code>对象解构</code>和<code>数组解构</code>，下面一一讲解。</p>
<h2 id="对象解构">对象解构</h2><p>对象解构的语法是使用一个对象直接量在赋值操作符的左边，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  a: <span class="string">'a'</span>,</span><br><span class="line">  b: <span class="string">'b'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;a: localA, b: localB&#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(localA);</span><br><span class="line"><span class="built_in">console</span>.log(localB);</span><br></pre></td></tr></table></figure>
<p>上面的代码中，<code>options.a</code>的值会存储在变量<code>localA</code>中，<code>options.b</code>会存储在变量<code>localB</code>中。在对象解构时，左边的对象直接量中，<code>key</code>对应了需要在对象中解构的属性，<code>value</code>则为存储属性值的变量名。</p>
<p>如果你想使用对象中相同的属性名，你可以省略左边对象直接量中的冒号和后面的值，例如，对于上面的例子，你可以这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  a: <span class="string">'a'</span>,</span><br><span class="line">  b: <span class="string">'b'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;a, b&#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure>
<p>当给定的属性名不存在对象中时，局部变量会得到<code>undefined</code>的值，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  a: <span class="string">'a'</span>,</span><br><span class="line">  b: <span class="string">'b'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;a, b, c&#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>对象解构也是可以嵌套的，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  a: <span class="string">'a'</span>,</span><br><span class="line">  b: <span class="string">'b'</span>,</span><br><span class="line">  c: &#123;</span><br><span class="line">    d: <span class="string">'d'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;a, b, c: &#123;d&#125;&#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(d);</span><br></pre></td></tr></table></figure>
<h2 id="数组解构">数组解构</h2><p>数组解构和对象解构差不多，是使用一个数组直接量在赋值操作符的左边，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [a, b, c] = arr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br></pre></td></tr></table></figure>
<p>要注意的是，数组解构时要按照元素在数组中的顺序。还有一点是数组解构不会修改原数组。</p>
<p>数组解构也是可以嵌套解构的，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [ <span class="string">"red"</span>, [ <span class="string">"green"</span>, <span class="string">"lightgreen"</span> ], <span class="string">"blue"</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [ firstColor, [ secondColor ] ] = colors;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstColor);        <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor);       <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure>
<p>以上就是变量结构的内容了。</p>
<p>参考链接：</p>
<ol>
<li><a href="https://leanpub.com/understandinges6/read" target="_blank" rel="external">https://leanpub.com/understandinges6/read</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="external">http://es6.ruanyifeng.com/#docs/destructuring</a></li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScript/">JavaScript</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/02/es6-destructing/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/06/02/es6-destructing/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/28/es6-let-const/" title="每天学点ES6－let和const" itemprop="url">每天学点ES6－let和const</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-05-28T04:59:42.000Z" itemprop="datePublished"> 發表於 2015-05-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>今天学习的比较简单，主要学习<code>ES6</code>的<code>let</code>和<code>const</code>。</p>
<p>我们知道在<code>ES6</code>之前，是没有块级作用域这一说的，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span><span class="params">(condition)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">var</span> value = <span class="string">"blue"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// other code</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// value exists here with a value of undefined</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// value exists here with a value of undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会觉得在<code>else</code>里面无法访问到<code>value</code>变量，其实在<code>js</code>内部会造成变量提升，这意味着我们可以在<code>else</code>里面访问到<code>value</code>变量，只是它未初始化，所以其变量值为<code>undefined</code>。实际解析时代码可能像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span><span class="params">(condition)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        value = <span class="string">"blue"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// other code</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>let</code>和<code>const</code>为我们带来了<code>块级作用域</code>，这意味着它只能在代码块内才能访问到，出了代码块就会抛出异常了，还有一点重要的是，<code>let</code>和<code>const</code>不会造成<code>变量提升</code>。</p>
<h2 id="let">let</h2><p><code>let</code>定义变量时和<code>var</code>有两个区别：块级作用域、不会变量提升和不能定义在块中已有标识符同名的变量。</p>
<p>我们用<code>let</code>来重新定义上面的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span><span class="params">(condition)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="string">"blue"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// other code</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// value doesn't exist here</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// value doesn't exist here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当用<code>let</code>定义<code>value</code>时，我们只能在<code>if</code>里面才能访问到<code>value</code>了，<code>value</code>变量也不会变量提升，从而我们在<code>else</code>里面不能访问到<code>value</code>。</p>
<p><code>let</code>最常用的场景应该是<code>for</code>循环了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="块级作用域">块级作用域</h3><p>块级作用域就不用多说，就是用<code>let</code>定义的变量只在定义它的块中有效，出了这个块你就不能访问到它了。</p>
<h3 id="变量提升">变量提升</h3><p>变量提升应该是在面试的时候会经常考到，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">var</span> value = <span class="string">'something'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fn);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test2();</span><br></pre></td></tr></table></figure>
<p>我们用<code>let</code>重新定义上面的<code>test()</code>函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">let</span> value = <span class="string">'something'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>此时浏览器就会抱怨了，在<code>let</code>定义前是无法访问到我们的变量的。</p>
<h3 id="同名变量">同名变量</h3><p>用<code>var</code>定义变量时，我们可以多次对它进行定义，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>这样的代码是不会报错的，在<code>let</code>定义的<code>相同块</code>中定义同名变量时就会报错了，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>要注意的是要与<code>let</code>定义时在相同的块中，下面的代码是不会出错的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (something) &#123;</span><br><span class="line">  let a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="const">const</h2><p><code>const</code>除了具有<code>let</code>的块级作用域和不会变量提升外，还有就是它定义的是常量，在用<code>const</code>定义变量后，我们就不能修改它了，对变量的修改会默默的失败（在<code>iojs</code>中会抛出异常，在Chrome下会默默的失败）。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(PI);</span><br><span class="line"></span><br><span class="line">PI = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(PI);</span><br></pre></td></tr></table></figure>
<p>参考链接：<a href="https://leanpub.com/understandinges6/read" target="_blank" rel="external">Understanding ECMAScript 6</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScript/">JavaScript</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/28/es6-let-const/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/05/28/es6-let-const/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/27/ios-nsurlsession/" title="iOS NSURLSession" itemprop="url">iOS NSURLSession</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-05-27T10:07:42.000Z" itemprop="datePublished"> 發表於 2015-05-27</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><code>NSURLSession</code>是<code>iOS7</code>中新的网络接口，负责处理数据的加载以及文件和数据在客户端与服务端之间的上传和下载。本文将从以下几个方面介绍：</p>
<ul>
<li>NSURLSessionConfiguration：在使用<code>NSURLSession</code>首先要创建一个<code>NSURLSessionConfiguration</code>来配置我们的<code>NSURLSession</code></li>
<li>NSURLSession</li>
<li>NSURLSessionTask：<ul>
<li>NSURLSessionDataTask：处理一般的 NSData 数据对象，比如通过GET或POST方式从服务器获取JSON或XML返回等等，但不支持后台获取</li>
<li>NSURLSessionUploadTask：用于上传文件，支持后台上传</li>
<li>NSURLSessionDownloadTask：用于下载文件，支持后台下载</li>
</ul>
</li>
</ul>
<h2 id="NSURLSessionConfiguration">NSURLSessionConfiguration</h2><p>一个<code>NSURLSessionConfiguration</code>对象定义了当使用<code>NSURLSession</code>对象上传和下载数据时的行为和使用策略。当你需要上传和下载数据时，创建一个配置对象总是你必须采取的第一步。从指定可用网络，到 cookie，安全性，缓存策略，再到使用自定义协议，启动事件的设置，以及用于移动设备优化的几个新属性，你会发现使用 <code>NSURLSessionConfiguration</code>可以找到几乎任何你想要进行配置的选项。</p>
<p><code>NSURLSession</code>在初始化时会把配置它的<code>NSURLSessionConfiguration</code>对象进行一次 copy，并保存到自己的<code>configuration</code>属性中，而且这个属性是只读的。因此之后再修改最初配置<code>session</code>的那个<code>configuration</code>对象对于<code>session</code>是没有影响的。也就是说，<code>configuration</code>只在初始化时被读取一次，之后都是不会变化的。</p>
<p><code>NSURLSessionConfiguration</code>提供了三个工厂方法来创建我们的<code>Session Configuration</code>对象：</p>
<ul>
<li><code>+ defaultSessionConfiguration</code>：该方法返回创建的一个默认<code>Session Configuration</code>对象。默认的<code>Session Configuration</code>会使用磁盘来缓存数据并在用户的<code>keychain</code>中存储凭证。它同样会存储<code>cookie</code>。</li>
<li><code>+ ephemeralSessionConfiguration</code>：返回一个<code>session configuration</code>，且不会使用缓存，<code>cookie</code>和凭证。使用<code>ephemeral sessions</code>主要的优点就是隐私。因此，它可以用于实现像秘密浏览这种功能。</li>
<li><code>+ backgroundSessionConfigurationWithIdentifier:</code>：返回一个后台的<code>session configuration</code>。后台<code>session</code>不同于常规的，普通的<code>session</code>，它甚至可以在应用程序挂起，退出或者崩溃的情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外恢复后台传输的守护进程（daemon）提供上下文。</li>
</ul>
<p>对于<code>NSURLSessionConfiguration</code>的属性配置，可以看这篇文章：<a href="http://objccn.io/issue-5-4/" target="_blank" rel="external">http://objccn.io/issue-5-4/</a>。</p>
<h2 id="NSURLSession">NSURLSession</h2><p>创建好了<code>NSURLSessionConfiguration</code>对象，我们就可以使用它来创建我们的<code>NSURLSession</code>对象了。<code>NSURLSession</code>提供了三个工厂方法来创建我们的<code>session</code>对象：</p>
<ul>
<li><code>+ sessionWithConfiguration:</code>：使用指定的<code>session configuration</code>来创建一个<code>session</code>，且会创建一个序列的<code>NSOperationQueue</code>对象来处理所有的委托方法和完成处理程序的调用</li>
<li><code>+ sessionWithConfiguration:delegate:delegateQueue:</code>：使用指定的<code>session configuration</code>、<code>delegate</code>和<code>operation queue.</code>来创建<code>session</code>。这个方法可以更细粒度的创建<code>session</code>，可以设定回调的<code>delegate</code>（注意这个回调delegate会被强引用），并且可以设定<code>delegate</code>在哪个<code>OperationQueue</code>回调，如果我们将其设置为<code>[NSOperationQueue mainQueue]</code>就能在主线程进行回调非常的方便。</li>
<li><code>+ sharedSession</code>：返回一个共享的单例<code>session</code>对象</li>
</ul>
<h2 id="NSURLSessionTask">NSURLSessionTask</h2><p>通过上面创建的<code>session</code>，我们就可以安排三种类型的任务：检索数据到存储器的数据任务、下载文件到硬盘的下载任务和从硬盘上传文件的上传任务。</p>
<p><code>NSURLSessionTask</code>是一个抽象类，其下有 3 个实体子类可以直接使用：<code>NSURLSessionDataTask</code>、<code>NSURLSessionUploadTask</code>、<code>NSURLSessionDownloadTask</code>。这 3 个子类封装了现代程序三个最基本的网络任务：获取数据，比如 JSON 或者 XML，上传文件和下载文件。</p>
<p>所有的<code>task</code>都是可以取消，暂停或者恢复的。当一个 download task 取消时，可以通过选项来创建一个恢复数据（resume data），然后可以传递给下一次新创建的<code>download task</code>，以便继续之前的下载。</p>
<p>这里的<code>task</code>不同于其他的<code>alloc-init</code>初始化方法，它是需要通过<code>session</code>来创建的，<code>NSURLSession</code>提供了多个方法来创建<code>task</code>：</p>
<p><strong>Data Task：</strong></p>
<ul>
<li><code>- dataTaskWithURL:</code></li>
<li><code>- dataTaskWithURL:completionHandler:</code></li>
<li><code>- dataTaskWithRequest:</code></li>
<li><code>- dataTaskWithRequest:completionHandler:</code></li>
</ul>
<p>实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">NSURL *url = [NSURL URLWithString:@<span class="string">"http://demo.com"</span>];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line"></span><br><span class="line">NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration];</span><br><span class="line">NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;</span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">&#125;];</span><br><span class="line">[dataTask resume];</span><br></pre></td></tr></table></figure>
<p><strong>Download Task：</strong></p>
<ul>
<li><code>- downloadTaskWithURL:</code></li>
<li><code>- downloadTaskWithURL:completionHandler:</code></li>
<li><code>- downloadTaskWithRequest:</code></li>
<li><code>- downloadTaskWithRequest:completionHandler:</code></li>
<li><code>- downloadTaskWithResumeData:</code></li>
<li><code>- downloadTaskWithResumeData:completionHandler:</code></li>
</ul>
<p>实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSURL *URL = [NSURL URLWithString:@<span class="string">"http://example.com/file.zip"</span>];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:URL];</span><br><span class="line"></span><br><span class="line">NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithRequest:request                                                    completionHandler:^(NSURL *location, NSURLResponse *response, NSError *error) &#123;</span><br><span class="line">        NSString *documentsPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];</span><br><span class="line">        NSURL *documentsDirectoryURL = [NSURL fileURLWithPath:documentsPath];</span><br><span class="line">        NSURL *newFileLocation = [documentsDirectoryURL URLByAppendingPathComponent:[[response URL] lastPathComponent]];</span><br><span class="line">        [[NSFileManager defaultManager] copyItemAtURL:location toURL:newFileLocation error:nil];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[downloadTask resume];</span><br></pre></td></tr></table></figure>
<p><strong>Upload Task：</strong></p>
<ul>
<li><code>- uploadTaskWithRequest:fromData:</code></li>
<li><code>- uploadTaskWithRequest:fromData:completionHandler:</code></li>
<li><code>- uploadTaskWithRequest:fromFile:</code></li>
<li><code>- uploadTaskWithRequest:fromFile:completionHandler:</code></li>
<li><code>- uploadTaskWithStreamedRequest:</code></li>
</ul>
<p>实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSURL *URL = [NSURL URLWithString:@<span class="string">"http://example.com/upload"</span>];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:URL];</span><br><span class="line">NSData *data = ...;</span><br><span class="line"></span><br><span class="line">NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">NSURLSessionUploadTask *uploadTask = [session uploadTaskWithRequest:request fromData:data completionHandler:</span><br><span class="line">     ^(NSData *data, NSURLResponse *response, NSError *error) &#123;</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">     &#125;];</span><br><span class="line">[uploadTask resume];</span><br></pre></td></tr></table></figure>
<p>以上就是本文的全部内容啦。如有不对还请指出。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/27/ios-nsurlsession/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/05/27/ios-nsurlsession/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/18/ios-uiview/" title="iOS UIView 学习" itemprop="url">iOS UIView 学习</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-05-18T03:47:42.000Z" itemprop="datePublished"> 發表於 2015-05-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文主要翻译自：<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009503-CH1-SW2" target="_blank" rel="external">View Programming Guide for iOS</a>，内容有删减。</p>
<p><code>UIView</code>类在屏幕上定义了一个矩形区域和一些在那个区域处理内容的接口。在运行时，一个<code>view</code>对象处理那个区域任何内容的渲染，还处理与这些内容的任何交互。<code>UIView</code>类它自己提供了用一个背景颜色填充它的矩形区域的基本行为。更复杂的内容可以通过继承<code>UIView</code>来呈现，并自身实现必要的绘制和事件处理代码。<code>UIKit</code>框架还包括一组标准的子类，从简单的按钮到复杂的表格可以使用。例如，一个<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UILabel_Class/index.html#//apple_ref/occ/cl/UILabel" target="_blank" rel="external">UILabel</a>对象绘制一个文本字符串，一个<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImageView_Class/index.html#//apple_ref/occ/cl/UIImageView" target="_blank" rel="external">UIImageView</a>对象绘制一张图片。</p>
<p>因为<code>view</code>对象是你的应用与用户交互的主要方式，所以它们具有许多职责。这里仅仅是几个：</p>
<ul>
<li>绘制和动画<ul>
<li>视图使用例如<code>UIKit</code>，<code>Core Graphics</code>和<code>OpenGL ES</code>的技术在它们的矩形区域绘制内容</li>
<li>一些视图属性可以动画到新的值</li>
</ul>
</li>
<li>布局和子视图管理<ul>
<li>一个视图可能包含0个或多个子视图</li>
<li>每一个视图定义了相对于它的父视图的它们自己默认的尺寸调整行为</li>
<li>视图可以根据需要限定的它的子视图的尺寸和位置</li>
</ul>
</li>
<li>事件处理<ul>
<li>视图是一个应答器，并能处理触摸事件以及由<code>UIResponder</code>类定义的其它事件</li>
<li>视图可以使用<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instm/UIView/addGestureRecognizer:" target="_blank" rel="external">addGestureRecognizer:</a>方法安装手势识别以处理常见的手势</li>
</ul>
</li>
</ul>
<p>视图可以嵌入其他视图，并创建复杂的视觉层次。这在被嵌入的视图（被称为subview）和父视图做嵌入（被称为superview）之间创建了一种<code>父－子</code>关系。通常情况下，一个<code>subview</code>的可见区域不会在它的<code>superview</code>的边界被剪切，但是在<code>iOS</code>中你可以使用<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instp/UIView/clipsToBounds" target="_blank" rel="external">clipsToBounds</a>来更新这种行为。一个父视图可以包含任意多个<code>subview</code>，但每个<code>subview</code>只有一个<code>superview</code>，该<code>superview</code>负责适当定位其子视图。</p>
<h2 id="视图绘制周期">视图绘制周期</h2><p><code>UIView</code>类使用一个按需绘制的模式来呈现内容。当一个视图第一次出现在屏幕上时，系统要求它绘制它的内容。系统捕捉内容的快照，并使用快照作为视图的可视化表示。如果你从未改变过视图内容，视图的绘制代码可能永远不会被再次调用。快照图片对于涉及视图的大部分操作中被重用。如果你更改了内容，你通知系统视图被改变了。视图重复绘制视图和捕捉新结果的快照。</p>
<p>当视图内容改变的时候，你不需要直接重绘这些变化。相反，你使用<code>setNeedsDisplay</code>或<code>setNeedsDisplayInRect:</code>中任何一个方法使视图失效。这些方法告诉系统视图中的内容被改变了，需要在下次机会被重绘。</p>
<p>当到了渲染视图内容的时候，实际的绘制过程取决于视图和它的配置。系统视图通常实现私有绘图方法来呈现其内容。这些相同的系统视图通常暴露接口，使用接口你可以配置视图的实际外观。对于自定义的<code>UIView</code>子类，你通常覆盖你视图的<code>drawRect:</code>方法，并使用该方法来绘制视图的内容。也有其他的方式来提供视图的内容，例如，直接设计内容底部的<code>layer</code>，但是覆盖<code>drawRect:</code>方法是最常用的技术。</p>
<p>下面再来看下上面提到的三个方法：</p>
<ul>
<li><code>- setNeedsDisplay</code></li>
</ul>
<p><strong>声明：</strong></p>
<p>SWIFT</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">setNeedsDisplay</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>OBJECTIVE-C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setNeedsDisplay</span><br></pre></td></tr></table></figure>
<p>你可以使用该方法或<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instm/UIView/setNeedsDisplayInRect:" target="_blank" rel="external">setNeedsDisplayInRect:</a>方法来通知系统你的视图内容需要被重绘了。这个方法发起请求并立即返回。视图并不是真的在重绘直到下一个绘制周期，在该点所有失效的视图被更新。</p>
<p>你应该只在视图的内容和外观改变时使用该方法来请求视图重绘。如果你只是简单地更改视图的几何结构，视图通常不会重新绘制。作为代替，它的现有内容基于视图的<code>contentMode</code>属性的值进行调整。重新显示现有的内容通过避免重绘并没有改变的内容而提供了性能。</p>
<ul>
<li><code>- setNeedsDisplayInRect:</code></li>
</ul>
<p><strong>声明：</strong></p>
<p>SWIFT</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">setNeedsDisplayInRect</span><span class="params">(_ invalidRect: CGRect)</span></span></span><br></pre></td></tr></table></figure>
<p>OBJECTIVE-C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setNeedsDisplayInRect:(CGRect)invalidRect</span><br></pre></td></tr></table></figure>
<ul>
<li><code>- drawRect:</code></li>
</ul>
<p><strong>声明：</strong></p>
<p>SWIFT</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">drawRect</span><span class="params">(_ rect: CGRect)</span></span></span><br></pre></td></tr></table></figure>
<p>OBJECTIVE-C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(CGRect)rect</span><br></pre></td></tr></table></figure>
<p><strong>参数：</strong></p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>rect</td>
<td>视图的边界部分。你的视图在第一绘制时，该矩形是通常是视图的整个可见边界。然而，在随后的绘制操作中，矩形可能被指定为视图的一部分。</td>
</tr>
</tbody>
</table>
<p>该方法的默认实现不做任何事情。使用技术，例如<code>Core Graphics</code>和<code>UIKit</code>来绘制它们的视图内容时，子类应该覆盖该方法并在该方法中实现它们的绘制代码。如果你的视图通过其他方式来设置它的内容，则你不需要覆盖该方法。例如，你不需要覆盖该方法如果你的视图仅显示一个背景颜色时或者你的视图通过底层的<code>layer</code>对象直接设置它们的内容。</p>
<p>在该方法被调用时，<code>UIKit</code>已经正确的为您的视图配置好绘制环境，你可以简单的调用任何绘制方法和功能来渲染你的内容。具体来说，<code>UIKit</code>创建和配置了一个图形上下文来绘制和调整在那个上下文中的转换，从而它的原点匹配你视图边界矩形的原点。你可以通过<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKitFunctionReference/index.html#//apple_ref/c/func/UIGraphicsGetCurrentContext" target="_blank" rel="external">UIGraphicsGetCurrentContext</a>函数来获取到该图形上下文的引用，但是不要建立一个强引用到该图形上下文，因为它会因为<code>drawRect:</code>方法的调用被改变。</p>
<p>需要注意的是，你永远不要直接调用该方法。我们可以通过<code>setNeedsDisplay</code>和<code>setNeedsDisplayInRect:</code>方法来告诉视图需要重绘。</p>
<h2 id="Content_Mode">Content Mode</h2><p>每个视图有一个内容模式，它控制视图在响应视图的几何结构改变时如何回收其内容，以及是否回收其内容。当视图第一次显示时，它和平常一样渲染内容，且结果在底层的位图中被捕获。在那之后，更改视图的几何形状并不总是导致位图重新被创建。作为替代，<code>contentMode</code>属性的值决定了位图是否应该缩放以适应新的边界，或简单的固定到一个角落或视图的边缘。</p>
<p>当你做以下事情时，一个视图的内容模式被应用：</p>
<ul>
<li>改变视图的<code>frame</code>或<code>bounds</code>矩形的宽度或高度</li>
<li>分配一个包括一个伸缩因子的变换到视图的<code>transform</code>属性</li>
</ul>
<p>默认情况下，对于大多数视图的<code>contentMode</code>属性被设置为<code>UIViewContentModeScaleToFill</code>，这将导致视图的内容被伸缩以适应新的框架尺寸。下面的图显示了几个<code>contentMode</code>属性值之间的比较：</p>
<p><img src="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/scale_aspect.jpg" alt="enter image description here"></p>
<p>内容模式有利于回收利用视图的内容，但是你也可以设置内容模式为<code>UIViewContentModeRedraw</code>，当你需要你的自定义视图在伸缩或调整操作时重绘它们自己。设置你的视图的内容模式为该值时，会强制系统调用你视图的<code>drawRect:</code>方法以响应几何尺寸的改变。一般情况下，只要有可能你应该避免使用这个值，你当然不应该在标准的系统视图中使用它。</p>
<h2 id="内置动画支持（Built-In_Animation_Support）">内置动画支持（Built-In Animation Support）</h2><p>在每一个视图后面有一个<code>layer</code>对象的一个好处是，你可以轻松动画许多视图相关的改变。动画是一种将信息传达给用户的非常有用的方式，在您的应用程序的设计过程中应该始终考虑它。<code>UIView</code>类的许多属性是可动画的——也就是说，半自动的支持从一个值到另一个值的动画。为了对这些动画属性之一执行动画，你所要做的是：</p>
<ol>
<li>告诉<code>UIKit</code>你要执行的动画</li>
<li>改变属性的值</li>
</ol>
<p><code>UIView</code>对象上你可以设置动画的属性为以下这些：</p>
<ul>
<li>frame：使用这个来动画视图的位置和尺寸</li>
<li>bounds：使用这个来动画视图的尺寸</li>
<li>center：使用这个来动画视图的位置</li>
<li>transform：使用这个来旋转或伸缩视图</li>
<li>alpha：使用这个来改变视图的透明性</li>
<li>backgroundColor：使用这个来改变视图的背景色</li>
<li>contentStretch：使用这个来改变视图如何伸缩</li>
</ul>
<h2 id="视图几何结构和坐标系统（View_Geometry_and_Coordinate_Systems）">视图几何结构和坐标系统（View Geometry and Coordinate Systems）</h2><p>在<code>UIKit</code>中默认的坐标系统有一个原点在左上角，且坐标轴向原点处往右和下延伸。坐标值是使用浮点数来代表，这使得精确布局和内容定位不考虑底层的屏幕分辨率。下图展示了相对于屏幕的坐标系统。</p>
<p><img src="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/native_coordinate_system.jpg" alt="enter image description here"></p>
<p>因为每个视图和<code>window</code>定义了它们自己的局部坐标系统，你需要知道在任何给定时间是哪个坐标系在起作用。任何时候你在视图中绘制或改变它的几何结构时，你这样做，相对于一些坐标系统。在正在绘制的情况下，你指定相对于视图自己的坐标系统的坐标。在几何结构改变的情况下，你指定相对于<code>superview</code>坐标系统的坐标。<code>UIWindow</code>和<code>UIView</code>类都包含了方法来帮助你从一个坐标系统转换为另一个。</p>
<h3 id="frame、bounds和center属性之间的关系"><code>frame</code>、<code>bounds</code>和<code>center</code>属性之间的关系</h3><p>一个视图对象使用<code>frame</code>、<code>bounds</code>和<code>center</code>属性来跟踪它的尺寸和位置：</p>
<ul>
<li>frame：<code>frame</code>属性包含了框架矩形，它指定了视图相对于<code>superview</code>坐标系统的尺寸和位置</li>
<li>bounds：<code>bounds</code>属性包含了边界矩形，它指定了视图相对于它的局部坐标系统的尺寸和位置</li>
<li>center：<code>center</code>属性包含了视图在<code>superview</code>坐标系统的中电</li>
</ul>
<p>你使用<code>center</code>和<code>frame</code>属性主要用于操作当前视图的几何结构。例如，当你在构建你的视图层级或在运行时改变一个视图的位置和尺寸时，你可以使用这些属性。如果你仅仅只是想改变视图的位置，<code>center</code>属性是首选的方法。<code>center</code>属性的值始终是有效的，即使伸缩或旋转因素被添加到视图的变换中。在同样情况下，对于<code>frame</code>属性则不正确，这被认为是无效的，如果视图的变换不等于恒等变换。</p>
<p>你使用<code>bounds</code>属性主要在绘制期间。边界矩形是在视图自己的局部坐标系统中的表示。该矩形的默认原点为<code>(0, 0)</code>，且它的尺寸匹配框架矩形的尺寸。任何你在该矩形中绘制的东西是视图可见内容的一部分。如果你改变边界矩形的原点，任何你在新的矩形中绘制的东西称为视图可见内容的一部分。</p>
<p>下图显示了这三个属性之间的关系：</p>
<p><img src="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/frame_bounds_rects.jpg" alt="enter image description here"></p>
<p>虽然你改变<code>frame</code>、<code>bounds</code>和<code>center</code>属性独立于其他，但是改变其中一个属性会按以下方式来改变其他属性：</p>
<ul>
<li>当你设置<code>frame</code>属性，<code>bounds</code>属性中的尺寸值也相应改变以匹配框架矩形的新尺寸。<code>center</code>属性的值也同样改变以匹配框架矩形中xin的中点。</li>
<li>当你设置<code>center</code>属性，在<code>frame</code>属性中的原点值也会相应改变。</li>
<li>当你设置<code>bounds</code>属性的尺寸时，<code>frame</code>属性中的尺寸值也相应改变以匹配边界矩形中的新尺寸。</li>
</ul>
<p>默认情况下，一个视图的框架（frame）不会被其<code>superview</code>的框架剪切。你可以改变这种行为，通过设置<code>superview</code>的<code>clipToBounds</code>属性为<code>YES</code>。</p>
<h3 id="坐标系统转换">坐标系统转换</h3><p>坐标系统转换提供了一种方式来更快和更简单的更新你的视图。一个仿射变换是一个数学矩阵，它指定了点如何从一个坐标系统映射到另一个坐标系统。你可以应用仿射变换到你的整个视图，以改变尺寸、位置或相对于其<code>superview</code>的方向。你也可以使用仿射变换在你的绘制代码中，去以单个块的渲染内容来执行相同类型的操作。如何应用仿射变换取决于上下文：</p>
<ul>
<li>要改变你的整个视图，改变你视图中<code>transform</code>属性的仿射变换。</li>
<li>要改变你视图的<code>drawRect:</code>方法的指定块的内容，改变关联当前活跃图形上下文的仿射变换。</li>
</ul>
<p>通常，您可以修改视图的<code>transform</code>属性，当你想要实现动画时。例如，你可以使用该属性创建一个你视图围绕中点旋转的动画。你不能使用该属性永久改变你的视图，例如改变视图在它的<code>superview</code>坐标空间的尺寸和位置。对于那种类型的改变，你应该改变框架矩形作为替代。</p>
<p>在你的<code>drawRect:</code>方法中，你可以使用仿射变换来定位和适应你计划绘制的元素。而不是固定在你视图某个位置的一个对象的位置，去创建相对于一个固定点的每个对象是非常简单的，通常<code>(0, 0)</code>，使用一个<code>transform</code>来定位该对象在立即绘制之前。在那种方式，该对象的位置在你的视图中改变，所有你所要做的就是修改变换，这是更快，更便宜的，相对于重新创建一个对象在它的新位置。你可以通过使用<code>CGContextGetCTM</code>函数来检索关联图形上下文的仿射变换，且你可以使用相关的<code>Core Graphics</code>函数在绘制期间设置和修改变换。</p>
<p><code>当前变换矩阵（current transformation matrix (CTM)）</code>是在任何给定时间当前正在使用的仿射变换。当操作整个视图的几何结构时，<code>CTM</code>是储存在你视图的<code>transform</code>属性的仿射变换。在你的<code>drawRect:</code>方法中，<code>CTM</code>是关联当前活跃图形上下文的仿射变换。</p>
<p>每个子视图的坐标系建立在其祖先的坐标系上。所以当你修改一个视图的<code>transform</code>属性时，这些改变会影响视图和它的所有子视图。然而，这些改变只影响视图在屏幕上的最后渲染。因为任何视图绘制它的内容和布局它的子视图是相对于它自己的边界，它在绘制和布局期间会忽略它的<code>superview</code>的变换。</p>
<h2 id="创建和管理视图层次">创建和管理视图层次</h2><p>管理视图层次是开发应用程序用户界面的重要组成部分。你的视图的组织影响你的应用程序的外观和应用程序如何响应变化和事件。例如，在视图层次中的<code>父－子</code>关系决定了哪个对象可能处理某个指定的触摸事件。同样的，<code>父－子</code>关系定义了每个视图如何响应界面方向改变。</p>
<h3 id="添加和移除子视图">添加和移除子视图</h3><p><code>Interface Builder</code>是建立视图层次的最方便的方式，因为你以图形化的方式组装视图，可以看到视图之间的关系，同样可以看到这些视图如何在运行时显示。当使用<code>Interface Builder</code>，你保存你的结果视图层级在一个<code>nib</code>文件中，你可以在运行时加载相应需要的视图。</p>
<p>如果你更愿意以程序的方式来创建你的视图，你创建和初始化它们，然后使用以下方法安排它们到层次：</p>
<ul>
<li>要添加一个子视图到父亲，在父视图上调用<code>addSubview:</code>。该方法添加子视图到父视图的子视图列表的末尾。</li>
<li>要插入一个子视图到父视图的子视图列表的中间，可以在父视图上调用任何和<code>insertSubview:...</code>相关的方法。</li>
<li>要重排父视图中现有的子视图，调用父视图的<code>bringSubviewToFront:</code>、<code>sendSubviewToBack:</code>或<code>exchangeSubviewAtIndex:withSubviewAtIndex:</code>方法。使用这些方法比移除子视图或重新插入它们更快。</li>
<li>要从父视图中移除一个子视图，在子视图上调用<code>removeFromSuperview</code>方法。</li>
</ul>
<p>添加一个子视图到另一个视图中最常见的例子发生在<code>application:didFinishLaunchingWithOptions:</code>方法中。下面显示了一个该方法的版本，它将视图从应用程序的主视图控制器安装到应用程序的<code>window</code>。<code>window</code>和视图控制器都是储存在应用程序的主<code>nib</code>文件中，它会在该方法调用前被加载。然而，由视图控制器管理的视图层级实际上不会加载，直到<code>view</code>属性被访问。</p>
<p>添加一个子视图到<code>window</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    <span class="comment">// Add the view controller's view to the window and display.</span></span><br><span class="line">    [window addSubview:viewController.view];</span><br><span class="line">    [window makeKeyAndVisible];</span><br><span class="line"><span class="keyword">return</span> YES; &#125;</span><br></pre></td></tr></table></figure>
<p>另一个常见的地方你可能添加子视图到视图层级中是在视图控制器的<code>loadView</code>和<code>viewDidLoad</code>方法中。如果你正在利用程序构建视图，你讲创建视图的代码放在视图控制器的<code>loadView</code>方法中。无论你是使用程序的方式，还是使用<code>nib</code>文件加载的方式来创建视图，你可能会在<code>viewDidLoad</code>方法中包含额外的视图配置代码。</p>
<p>添加视图到已存在的视图层级：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">      [super viewDidLoad];</span><br><span class="line">      self.title = NSLocalizedString(@<span class="string">"TransitionsTitle"</span>, @<span class="string">""</span>);</span><br><span class="line"><span class="comment">// create the container view which we will use for transition animation (centered horizontally)</span></span><br><span class="line">      CGRect frame = CGRectMake(round((self.view.bounds.size.width - kImageWidth) /</span><br><span class="line">   <span class="number">2.0</span>),</span><br><span class="line">                                                        kTopPlacement, kImageWidth,</span><br><span class="line">   kImageHeight);</span><br><span class="line">      self.containerView = [[[UIView alloc] initWithFrame:frame] autorelease];</span><br><span class="line">      [self.view addSubview:self.containerView];</span><br><span class="line">      <span class="comment">// The container view can represent the images for accessibility.</span></span><br><span class="line">      [self.containerView setIsAccessibilityElement:YES];</span><br><span class="line">      [self.containerView setAccessibilityLabel:NSLocalizedString(@<span class="string">"ImagesTitle"</span>,</span><br><span class="line">  @<span class="string">""</span>)];</span><br><span class="line">      <span class="comment">// create the initial image view</span></span><br><span class="line">      frame = CGRectMake(<span class="number">0.0</span>, <span class="number">0.0</span>, kImageWidth, kImageHeight);</span><br><span class="line">      self.mainView = [[[UIImageView alloc] initWithFrame:frame] autorelease];</span><br><span class="line">      self.mainView.image = [UIImage imageNamed:@<span class="string">"scene1.jpg"</span>];</span><br><span class="line">      [self.containerView addSubview:self.mainView];</span><br><span class="line">      <span class="comment">// create the alternate image view (to transition between)</span></span><br><span class="line">CGRect imageFrame = CGRectMake(<span class="number">0.0</span>, <span class="number">0.0</span>, kImageWidth, kImageHeight); self.flipToView = [[[UIImageView alloc] initWithFrame:imageFrame] autorelease];</span><br><span class="line">      self.flipToView.image = [UIImage imageNamed:@<span class="string">"scene2.jpg"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你添加子视图到另一个视图，<code>UIKit</code>通知父视图和子视图这些改变。如果你实现了自定义视图，你可以覆盖以下方法来拦截这些通知：<code>willMoveToSuperview:</code>、<code>willMoveToWindow:</code>、<code>willRemoveSubview:</code>、<code>didAddSubview:</code>、<code>didMoveToSuperview</code>或<code>didMoveToWindow</code>。您可以使用这些通知以更新与您的视图层次中相关的任何状态信息或执行其他任务。</p>
<h3 id="隐藏视图">隐藏视图</h3><p>为了在视觉上隐藏视图，你可以通过设置<code>hidden</code>属性为<code>YES</code>或者设置<code>alpha</code>属性为<code>0.0</code>。一个隐藏的视图不从系统接收触摸事件。然而，隐藏的视图仍然参与到自动调整大小和其他关联视图层级的布局操作。因此，当你需要从视图层级移除视图，隐藏视图通常是一个方便的选择，特别是如果你计划在某个点再重新显示视图。</p>
<p>如果你想动画一个视图，从可见过渡到隐藏（或者相反），你必须使用视图的<code>alpha</code>属性。因为<code>hidden</code>属性不是一个可动画的属性，所以你在上面做的改变会立即发生。</p>
<h3 id="在视图层级中定位视图">在视图层级中定位视图</h3><p>有两种方法在视图层级中定位视图：</p>
<ul>
<li>在适合的位置存储任何有关视图的指针，例如，在拥有该视图的视图控制器。</li>
<li>分配一个唯一的整数到每个视图的<code>tag</code>属性，然后使用<code>viewWithTag:</code>来定位它。</li>
</ul>
<p>储存相关视图的引用是最常见定位视图的方式，且使得访问这些视图非常容易。如果你使用<code>Interface Builder</code>来创建你的视图，你可以在你的<code>nib</code>文件中使用<code>outlets</code>连接对象到另一个。对于你用程序创建的视图，你可以在私有成员变量中保存这些视图的引用。无论你是使用<code>outlets</code>还是私有成员变量，你负责在需要时保留视图，或者释放它们。保证对象保留和释放最好的办法是使用声明的属性。</p>
<p>标签是减少硬编码依赖和支持动态和灵活的解决方案的有效方式。而不是保存视图的指针，你可以使用<code>tag</code>来定位它。标签也是引用视图的一种更持久的方式。</p>
<h3 id="平移，缩放和旋转视图">平移，缩放和旋转视图</h3><p>每个视图有一个关联的仿射变换，你可以使用它来平移、伸缩和旋转视图的内容。视图变换改变视图的最终渲染外观，且通常用于实现滚动，动画，或其他视觉效果。</p>
<p><code>UIView</code>的<code>transform</code>属性包含了一个应用变换的<code>CGAffineTransform</code>结构。默认情况下，这个属性被设置为恒等变换，不修改视图的外观。你可以在任何时候给该属性赋一个新的变换。例如，将一个视图旋转45度，你可以使用以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// M_PI/4.0 is one quarter of a half circle, or 45 degrees.</span></span><br><span class="line">CGAffineTransform xform = CGAffineTransformMakeRotation(M_PI/<span class="number">4.0</span>);</span><br><span class="line">self.view.transform = xform;</span><br></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/rotated_view.jpg" alt="enter image description here"></p>
<h2 id="在视图层级中转换坐标">在视图层级中转换坐标</h2><p>在不同的时间，特别是处理事件时，应用程序可能需要从一个框架的引用到另一个之间转换坐标值。例如，触摸事件是在<code>window</code>坐标系统中报告每一次触摸的位置，但是视图对象通常在视图的局部坐标系统中需要这些信息。<code>UIView</code>类定义了以下方法来转换坐标：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">convertPoint:fromView:</span><br><span class="line">convertRect:fromView:</span><br><span class="line">convertPoint:toView:</span><br><span class="line">convertRect:toView:</span><br></pre></td></tr></table></figure>
<p><code>convert...:fromView:</code>方法从其他视图坐标系统转换坐标到当前视图的局部坐标系统。相反的，<code>convert...:toView:</code>方法从当前视图坐标系统转换坐标到指定的视图的坐标系统。如果对于任何方法你指定<code>nil</code>为引用的视图，是从包含当前视图的<code>window</code>的坐标系统中转换。</p>
<p>除了<code>UIView</code>的转换方法，<code>UIWindow</code>类也同样定义了几个转换方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">convertPoint:fromWindow:</span><br><span class="line">convertRect:fromWindow:</span><br><span class="line">convertPoint:toWindow:</span><br><span class="line">convertRect:toWindow:</span><br></pre></td></tr></table></figure>
<h2 id="实现自定义视图的清单">实现自定义视图的清单</h2><p>自定义视图的工作是呈现内容和管理与这些内容的交互。一个成功的自定义视图的实现包含了不仅绘制和事件处理。在实现自定义视图时，下面的清单包括了你应该覆盖的比较重要的方法：</p>
<ul>
<li>为你的视图定义相应的初始化方法：<ul>
<li>对于你想用程序创建的视图，覆盖<code>initWithFrame:</code>方法，或者定义一个自定义初始化方法</li>
<li>对于你想从<code>nib</code>文件加载的视图，覆盖<code>initWithCoder:</code>方法。</li>
</ul>
</li>
<li>实现一个<code>dealloc</code>方法处理任何自定义数据的清理工作。</li>
<li>要处理自定义的绘制，覆盖<code>drawRect:</code>方法，并在其中实现你的绘制代码。</li>
<li>设置视图的<code>autoresizingMask</code>属性以定义它的自动调整大小行为。</li>
<li>如果你的视图类管理一个或多个完整的子视图，做以下几点：<ul>
<li>在你的视图初始化阶段创建这些子视图</li>
<li>对于每个子视图在创建时设置<code>autoresizingMask</code>属性</li>
<li>如果你的子视图需要自定义布局，覆盖<code>layoutSubviews</code>方法，并在其中实现你的布局代码</li>
</ul>
</li>
<li>为了处理触摸相关的事件，做以下几点：<ul>
<li>使用<code>addGestureRecognizer:</code>方法附加任何合适的手势识别到视图中</li>
<li>对于你要自己处理触摸的情况下，覆盖<code>touchesBegan:withEvent:</code>、<code>touchesMoved:withEvent:</code>、<code>touchesEnded:withEvent:</code>和<code>touchesCancelled:withEvent:</code>方法</li>
</ul>
</li>
<li>如果你想你视图的绘制版本看起来不同于屏幕上的版本，实现<code>drawRect:forViewPrintFormatter:</code>方法</li>
</ul>
<h2 id="动画">动画</h2><h3 id="使用基于块的方法开始动画">使用基于块的方法开始动画</h3><p>在iOS4和以后，你可以使用基于块的类方法来初始化动画。有几个基于块的方法为动画块提供了不同级别的配置。它们为：</p>
<ul>
<li><code>animateWithDuration:animations:</code></li>
<li><code>animateWithDuration:animations:completion:</code></li>
<li><code>animateWithDuration:delay:options:animations:completion:</code></li>
</ul>
<p>因为它们是类方法，使用它们创建的动画块不依赖于单个视图。因此，你可以使用该方法来创建一个包含改变多个视图的动画。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[UIView animateWithDuration:<span class="number">1.0</span> animations:^&#123;</span><br><span class="line">          firstView.alpha = <span class="number">0.0</span>;</span><br><span class="line">          secondView.alpha = <span class="number">1.0</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>如果你想对动画有更多的配置，那就要使用<code>animateWithDuration:delay:options:animations:completion:</code>了，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)showHideView:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">// Fade out the view right away</span></span><br><span class="line">      [UIView animateWithDuration:<span class="number">1.0</span></span><br><span class="line">          delay: <span class="number">0.0</span></span><br><span class="line">          options: UIViewAnimationOptionCurveEaseIn</span><br><span class="line">          animations:^&#123;</span><br><span class="line">               thirdView.alpha = <span class="number">0.0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          completion:^(BOOL finished)&#123;</span><br><span class="line">            <span class="comment">// Wait one second and then fade in the view</span></span><br><span class="line">        [UIView animateWithDuration:<span class="number">1.0</span></span><br><span class="line">             delay: <span class="number">1.0</span></span><br><span class="line">             options:UIViewAnimationOptionCurveEaseOut</span><br><span class="line">             animations:^&#123;</span><br><span class="line">                thirdView.alpha = <span class="number">1.0</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             completion:nil];</span><br><span class="line">          &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建在视图间过渡的动画">创建在视图间过渡的动画</h3><p>当在视图层级中添加、移除、隐藏和展示视图时，视图间过渡帮助你隐藏立即的改变。你可以使用视图过渡去实现以下类型的改变：</p>
<ul>
<li>更改现有视图的可见子视图</li>
<li>在你的视图层级中替换某个视图为另外一个视图</li>
</ul>
<h4 id="改变一个视图的子视图">改变一个视图的子视图</h4><p>在iOS4及以后，你可以使用<code>transitionWithView:duration:options:animations:completion:</code>方法来为视图初始化一个过渡动画。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)displayNewPage:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    [UIView transitionWithView:self.view</span><br><span class="line">        duration:<span class="number">1.0</span></span><br><span class="line">        options:UIViewAnimationOptionTransitionCurlUp</span><br><span class="line">        animations:^&#123;</span><br><span class="line">            currentTextView.hidden = YES;</span><br><span class="line">            swapTextView.hidden = NO;</span><br><span class="line">        &#125;</span><br><span class="line">        completion:^(BOOL finished)&#123;</span><br><span class="line">            <span class="comment">// Save the old text and then swap the views.</span></span><br><span class="line">            [self saveNotes:temp];</span><br><span class="line">            UIView*    temp = currentTextView;</span><br><span class="line">      currentTextView = swapTextView;</span><br><span class="line">      swapTextView = temp;</span><br><span class="line">&#125;]; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="替换视图为不同的视图">替换视图为不同的视图</h4><p>在iOS4及以后，你可以使用<code>transitionFromView:toView:duration:options:completion:</code>方法在视图间过渡。这个方法实际会将第一个视图从你的层级中移除，然后插入另外一个，因此，你应该确保如果你想保持第一个视图时，你有一个到第一个视图的引用。如果你想隐藏视图来代替从视图层级中移除，传递<code>UIViewAnimationOptionShowHideTransitionViews</code>关键字作为选项。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)toggleMainViews:(id)sender &#123;</span><br><span class="line">    [UIView transitionFromView:(displayingPrimary ? primaryView : secondaryView)</span><br><span class="line">    toView:(displayingPrimary ? secondaryView : primaryView)</span><br><span class="line">    duration:<span class="number">1.0</span></span><br><span class="line">    options:(displayingPrimary ? UIViewAnimationOptionTransitionFlipFromRight : UIViewAnimationOptionTransitionFlipFromLeft)</span><br><span class="line">  completion:^(BOOL finished) &#123;</span><br><span class="line">      <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">          displayingPrimary = !displayingPrimary;</span><br><span class="line">      &#125;</span><br><span class="line">  )];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/18/ios-uiview/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/05/18/ios-uiview/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/04/18/objectivec-block/" title="Objective-C基础学习之block" itemprop="url">Objective-C基础学习之block</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-04-18T10:07:42.000Z" itemprop="datePublished"> 發表於 2015-04-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>以下学习内容是翻译自Apple的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/ProgrammingWithObjectiveC.pdf" target="_blank" rel="external">Programming with Objective-C</a>，内容有部分删减，主要是自己一个学习和理解的过程，如有翻译不当，还请谅解。</p>
<p><code>Block</code>是被添加到<code>C</code>、<code>Objective-C</code>和<code>C++</code>的语言级别的特性，它允许你创建不同的代码片段，这些代码片段可以作为值传入到方法或函数中。<code>Blocks</code>是<code>Objective-C</code>对象，这意味着它可以被添加到类似<code>NSArray</code>和<code>NSDictionary</code>的集合中。他们同样有从封闭作用域中捕获值的能力，使他们类似于其他编程语言的<code>closures</code>和<code>lambdas</code>。</p>
<h2 id="Block语法">Block语法</h2><p>定义一个<code>block</code>是使用<code>^</code>符号，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^&#123;</span><br><span class="line">     NSLog(@<span class="string">"This is a block"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像函数和方法的定义，大括号表明了<code>block</code>的开始和结束。在这个例子中，<code>block</code>没有返回任何值，也没有任何参数。</p>
<p>以同样的方式，您可以使用一个函数指针来引用一个C函数，你可以定义一个变量来记录一个<code>block</code>，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^simpleBlock)(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<p>这个例子定义了一个变量：<code>simpleBlock</code>，该变量用于引用一个<code>block</code>，且该<code>block</code>没有参数且不返回值，这意味着您可以像下面这样将<code>block</code>字面赋给<code>simpleBlock</code>变量，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">simpleBlock = ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"This is a block"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要注意的是大括号末尾的分号。您同样可以结合变量定义和赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^simpleBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"This is a block"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后你就可以像下面这样来调用<code>block</code>了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simpleBlock();</span><br></pre></td></tr></table></figure>
<h2 id="带参数和返回值的Block">带参数和返回值的Block</h2><p><code>Block</code>是可以接受参数和返回值的，就像函数和方法那样。</p>
<p>作为一个例子，考虑一个变量引用到一个<code>block</code>，该<code>block</code>返回两个值的乘积：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (^multiplyTwoValues)(<span class="keyword">double</span>, <span class="keyword">double</span>);</span><br></pre></td></tr></table></figure>
<p>关联的<code>block</code>字面可能是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^ (<span class="keyword">double</span> firstValue, <span class="keyword">double</span> secondValue) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstValue * secondValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你声明和定义好了<code>block</code>，你可以调用它就像一个函数一样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (^multiplyTwoValues)(<span class="keyword">double</span>, <span class="keyword">double</span>) =</span><br><span class="line">                          ^(<span class="keyword">double</span> firstValue, <span class="keyword">double</span> secondValue) &#123;</span><br><span class="line">                              <span class="keyword">return</span> firstValue * secondValue;</span><br><span class="line">                          &#125;;</span><br><span class="line"><span class="keyword">double</span> result = multiplyTwoValues(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">NSLog(@<span class="string">"The result is %f"</span>, result);</span><br></pre></td></tr></table></figure>
<h2 id="Block能从封闭作用域中捕获值">Block能从封闭作用域中捕获值</h2><p>如果你在一个方法中定义了一个<code>block</code>，例如，它能从该方法的作用域中捕获任何能访问到的值，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testMethod &#123;</span><br><span class="line">    <span class="keyword">int</span> anInteger = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"Integer is: %i"</span>, anInteger);</span><br><span class="line">&#125;;</span><br><span class="line">    testBlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>anInteger</code>是定义在<code>block</code>之外的，但是当<code>block</code>定义时该变量被捕获到了。</p>
<p>只有值被捕获了，除非你指定。这意味着当你在定义<code>block</code>和调用<code>block</code>之间改变该变量的外在值时，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> anInteger = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"Integer is: %i"</span>, anInteger);</span><br><span class="line">&#125;;</span><br><span class="line">anInteger = <span class="number">84</span>;</span><br><span class="line">testBlock();</span><br></pre></td></tr></table></figure>
<p>被<code>block</code>捕获的值并没有受到影响。这意味着同样会输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer is: <span class="number">42</span></span><br></pre></td></tr></table></figure>
<h3 id="使用__block来共享存储">使用__block来共享存储</h3><p>如果你需要能够在<code>block</code>中改变捕获变量的值，你可以使用<code>__block</code>存储类型修饰符对原变量声明。这意味着该变量所在的存储是在原始变量的词法作用域和任何定义在该作用域的<code>block</code>之间共享。</p>
<p>作为一个例子，你可以重写之前都例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> anInteger = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"Integer is: %i"</span>, anInteger);</span><br><span class="line">&#125;;</span><br><span class="line">anInteger = <span class="number">84</span>;</span><br><span class="line">testBlock();</span><br></pre></td></tr></table></figure>
<p>因为<code>anInteger</code>被定义为一个<code>__block</code>变量，它的存储会在<code>block</code>定义中共享。上面的代码会输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer is: <span class="number">84</span></span><br></pre></td></tr></table></figure>
<p>这也意味着在<code>block</code>中可以修改原始值，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> anInteger = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"Integer is: %i"</span>, anInteger);</span><br><span class="line">    anInteger = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line">testBlock();</span><br><span class="line">NSLog(@<span class="string">"Value of original variable is now: %i"</span>, anInteger);</span><br></pre></td></tr></table></figure>
<p>以上会输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer is: <span class="number">42</span></span><br><span class="line">Value of original variable is now: <span class="number">100</span></span><br></pre></td></tr></table></figure>
<h2 id="你可以传递Block给方法或函数作为参数">你可以传递Block给方法或函数作为参数</h2><p>在前面的所有例子中，你都是定义<code>block</code>之后立即调用它。实践中，传递<code>block</code>给函数或方法调用是非常常见的。你可能会使用<code>Grand Central Dispatch</code>在后台调用<code>block</code>，例如，或者定义一个<code>block</code>代表重复被调用的任务，例如当枚举一个集合的时候。</p>
<p><code>Block</code>也同样可以被用于回调，定义一些代码在任务完成后执行。作为一个例子，你的app可能需要通过创建一个对象来响应用户的动作以此处理复杂的任务，例如从web服务器请求信息。因为这个任务可能会需要很长一段时间，在任务正在进行时您应该显示某种进度指示器，而一旦任务完成，您就需要隐藏掉任务指示器。</p>
<p>这将可能使用委托来完成这些：您需要创建一个合适的委托协议，实现必须的方法，设置您的对象为任务的委托，然后等待您的对象在任务完成时调用委托方法。</p>
<p><code>Block</code>使这些变得更加容易，然而，因为你可以定义回调行为在你初始化任务的时候，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)fetchRemoteInformation:(id)sender &#123;</span><br><span class="line">    [self showProgressIndicator];</span><br><span class="line">    XYZWebTask *task = ...</span><br><span class="line">    [task beginTaskWithCallbackBlock:^&#123;</span><br><span class="line">        [self hideProgressIndicator];</span><br><span class="line">&#125;]; &#125;</span><br></pre></td></tr></table></figure>
<p>这个例子调用了一个方法来显示进度指示器，然后创建任务并开始。回调的<code>block</code>指定了在任务完成后执行的代码；在这种情况下，它只是调用了一个方法来隐藏进度指示器。要注意，这个回调<code>block</code>为了能够调用<code>hideProgressIndicator</code>方法而捕获了<code>self</code>。有一点非常重要的是在捕获<code>self</code>时要非常注意，因为它会造成<code>strong reference cycle</code>。</p>
<p>在代码的可读性方面，<code>block</code>使得很容易在一个地方看出在任务完成之前和之后会发生什么，避免了需要通过跟踪委托方法来找出发生了什么事情。</p>
<p>下面是<code>beginTaskWithCallbackBlock:</code>方法的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)beginTaskWithCallbackBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))callbackBlock;</span><br></pre></td></tr></table></figure>
<p><code>(void (^)(void))</code>指定了这个参数是一个不接受任何参数也没有返回值的<code>block</code>。该方法的实现可以以通常的方式来调用<code>block</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)beginTaskWithCallbackBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))callbackBlock &#123;</span><br><span class="line">    ...</span><br><span class="line">    callbackBlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="block必须为方法的最后的参数">block必须为方法的最后的参数</h3><p>在方法中只使用一个<code>block</code>参数通常是最好的做法。如果一个方法同样需要其他的非<code>block</code>参数，那么<code>block</code>应该放在最后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">￼- (<span class="keyword">void</span>)beginTaskWithName:(NSString *)name completion:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))callback</span><br></pre></td></tr></table></figure>
<p>这也使得在方法调用时代码具有更好的可读性，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self beginTaskWithName:@<span class="string">"MyTask"</span> completion:^&#123;</span><br><span class="line">    NSLog(@<span class="string">"The task is complete"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="使用类型定义简化block语法">使用类型定义简化block语法</h2><p>如果你需要定义不只一个<code>block</code>，且它们具有相同的签名，你可能想定义自己的类型签名。</p>
<p>作为一个例子，你可以定义一个没有参数也没有返回值的简单<code>block</code>类型，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(^XYZSimpleBlock)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>然后你就可以使用你的自定义类型来创建<code>block</code>了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XYZSimpleBlock anotherBlock = ^&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="对象使用属性来记录block">对象使用属性来记录block</h2><p>该语法定义了一个属性来记录一个<code>block</code>，这很类似一个<code>block</code>变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface XYZObject : NSObject</span><br><span class="line">@property (copy) <span class="keyword">void</span> (^blockProperty)(<span class="keyword">void</span>);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>一个<code>block</code>属性就像其他<code>block</code>变量一样被设置和调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.blockProperty = ^&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">self.blockProperty();</span><br></pre></td></tr></table></figure>
<p>同样可能使用类型定义来定义<code>block</code>属性声明，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(^XYZSimpleBlock)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">@interface XYZObject : NSObject</span><br><span class="line">@property (copy) XYZSimpleBlock blockProperty;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h2 id="捕获self时避免Strong_Reference_Cycles">捕获self时避免Strong Reference Cycles</h2><p>如果你需要在<code>block</code>中捕获<code>self</code>，例如，当定义一个回调<code>block</code>，有一点非常重要当是要考虑内存管理的影响。</p>
<p><code>Block</code>保持对任何捕获对象的强引用，也包括<code>self</code>，这意味着最后很容易造成强引用循环，例如，一个对象为一个<code>block</code>保持为一个<code>copy</code>属性然后捕获了<code>self</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface XYZBlockKeeper : NSObject</span><br><span class="line">@property (copy) <span class="keyword">void</span> (^block)(<span class="keyword">void</span>);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@implementation XYZBlockKeeper</span><br><span class="line">- (<span class="keyword">void</span>)configureBlock &#123;</span><br><span class="line">	self.block = ^&#123;</span><br><span class="line">          [self doSomething];</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">... @end</span><br></pre></td></tr></table></figure>
<p>编译器会警告你一个简单的例子是这样的，但更复杂的例子可能涉及到对象创建周期之间的多个强引用，使之更难以诊断。</p>
<p>为了避免这个问题，捕获一个对<code>self</code>对弱引用是最好的办法，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)configureBlock &#123;</span><br><span class="line">    XYZBlockKeeper * __weak weakSelf = self;</span><br><span class="line">    self.block = ^&#123;</span><br><span class="line">        [weakSelf doSomething];   <span class="comment">// capture the weak reference</span></span><br><span class="line">                                  <span class="comment">// to avoid the reference cycle</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Block简化枚举">Block简化枚举</h2><p>除了一般的完成处理，许多<code>Cocoa</code>和<code>Cocoa Touch API</code>使用<code>block</code>来简化常用的任务，如集合枚举。<code>NSArray</code>类，例如，提供了三个基于<code>block</code>的方法，包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)enumerateObjectsUsingBlock:(<span class="keyword">void</span> (^)(id obj, NSUInteger idx, BOOL</span><br><span class="line">*stop))block;</span><br></pre></td></tr></table></figure>
<p>该方法接受一个参数，它是一个<code>block</code>会被数组中的每一个元素调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSArray *<span class="built_in">array</span> = ...</span><br><span class="line">[<span class="built_in">array</span> enumerateObjectsUsingBlock:^ (id obj, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">    NSLog(@<span class="string">"Object at index %lu is %@"</span>, idx, obj);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="Block简化并发任务">Block简化并发任务</h2><p><code>block</code>代表了一个工作的不同单位，结合可执行代码和从周围作用域捕获的可选状态。这使得它非常适用于在iOS和OS X中使用并发选项之一来异步调用。而不必弄清楚如何与低层次的机制工作，就像线程，您可以使用<code>block</code>简单地定义你的任务，然后让系统执行这些任务随着处理器资源可用。</p>
<p>OS X和iOS提供了各种技术的并发性，其中包括两个任务调度机制：操作队列和<code>Grand Central Dispatch</code>，这些机制围绕队列任务等待被执行的想法。您按照您想<code>block</code>执行的顺序将<code>blocks</code>添加到队列中，然后系统将它们出列直到处理器时间和资源可用。</p>
<p>串行队列只允许一个任务同时执行——队列中的下一个任务将不被出列并调用直到前一个任务已完成。并发队列调用尽可能多的任务，无需等待前一个任务来完成。</p>
<h3 id="使用Block操作与操作队列">使用Block操作与操作队列</h3><p>操作队列是<code>Cocoa</code>和<code>Cocoa Touch</code>的任务调度方式。你创建一个<code>NSOperation</code>实例为了封装工作单位以及任何必要的数据，然后将那个操作添加到<code>NSOperationQueue</code>执行。</p>
<p>尽管你创建了你自己的自定义<code>NSOperation</code>子类去实现复杂的任务，但还是可能去使用<code>NSBlockOperation</code>来用<code>block</code>创建一个操作，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这是可能手动去执行操作，但是操作可能通常被添加到一个已经存在到操作队列或你自己创建的一个队列，准备执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// schedule task on main queue:</span></span><br><span class="line">NSOperationQueue *mainQueue = [NSOperationQueue mainQueue];</span><br><span class="line">[mainQueue addOperation:operation];</span><br><span class="line"><span class="comment">// schedule task on background queue:</span></span><br><span class="line">NSOperationQueue *<span class="built_in">queue</span> = [[NSOperationQueue alloc] init];</span><br><span class="line">[<span class="built_in">queue</span> addOperation:operation];</span><br></pre></td></tr></table></figure>
<p>如果你使用一个操作队列，你可以在操作之间配置优先级和依赖，例如指定某个操作必须在其他一些操作执行后才能操作。</p>
<h3 id="调度Block在GCD的调度队列（Schedule_Blocks_on_Dispatch_Queues_with_Grand_Central_Dispatch）">调度Block在GCD的调度队列（Schedule Blocks on Dispatch Queues with Grand Central Dispatch）</h3><p>如果你需要调度执行代码的任意块，你可以直接使用被GCD（Grand Central Dispatch ）控制的调度队列，调度队列使得操作任务更加简单，不管是相对于调用者的同步或异步操作，且执行这些任务的顺序为先进先出。</p>
<p>你可以创建你自己的调度队列或使用GCD提供的队列。如果你需要调度一个任务为并发执行，例如，你可以通过<code>dispatch_get_global_queue()</code>获取一个存在队列的引用，和指定一个队列优先级，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>为了将<code>block</code>调度到队列，您可以使用<code>dispatch_async()</code>或<code>dispatch_sync()</code>函数。<code>dispatch_async()</code>函数是立即返回，不用去等待<code>block</code>的执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"Block for asynchronous execution"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/04/18/objectivec-block/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/04/18/objectivec-block/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/04/09/javascript-types/" title="JavaScript  类型与类型转换" itemprop="url">JavaScript  类型与类型转换</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-04-09T10:07:42.000Z" itemprop="datePublished"> 發表於 2015-04-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="类型">类型</h2><p><code>JavaScript</code>类型主要包括了<code>primitive</code>和<code>object</code>类型，其中<code>primitive</code>类型包括了：<code>null</code>、<code>undefined</code>、<code>boolean</code>、<code>number</code>、<code>string</code>和<code>symbol(es6)</code>。</p>
<p>参考链接：1. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures</a></p>
<ol>
<li><a href="http://www.w3.org/html/ig/zh/wiki/ES5/types" target="_blank" rel="external">http://www.w3.org/html/ig/zh/wiki/ES5/types</a></li>
</ol>
<h2 id="类型检测">类型检测</h2><p>说到类型检测主要包括了：<code>typeof</code>、<code>instanceof</code>和<code>Object.prototype.toString.call(xxx)或{}.toString.call(xxx)</code>。这里在玉伯的博文<a href="https://github.com/lifesinger/lifesinger.github.com/issues/175" target="_blank" rel="external">Sea.js 源码解析（三）</a>中有讨论过<code>Object.prototype.toString.call(xxx)或{}.toString.call(xxx)</code>哪一个更好，有兴趣的可以看一看。</p>
<h3 id="typeof">typeof</h3><p><code>typeof</code>一般适用于判断<code>primitive</code>类型的数据，在判断<code>object</code>类型的数据时有时会有意想不到的结果，例如：<code>typeof null</code>结果为<code>object</code>。下面的表是<code>typeof</code>元素符的一个结果：</p>
<table>
<thead>
<tr>
<th>val 类型</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Undefined</td>
<td>“undefined”</td>
</tr>
<tr>
<td>Null</td>
<td>“object”</td>
</tr>
<tr>
<td>Boolean</td>
<td>“boolean”</td>
</tr>
<tr>
<td>Number</td>
<td>“number”</td>
</tr>
<tr>
<td>String</td>
<td>“string”</td>
</tr>
<tr>
<td>Object（原生，且没有实现 [[Call]]）</td>
<td>“object”</td>
</tr>
<tr>
<td>Object（原生或者宿主且实现了 [[Call]]）</td>
<td>“function”</td>
</tr>
<tr>
<td>Object（宿主且没实现 [[Call]]）</td>
<td>由实现定义，但不能是 “undefined”、”boolean”、”number” 或 “string”。</td>
</tr>
</tbody>
</table>
<p>这里还有一篇相关介绍<code>typeof</code>的文章：<a href="http://blog.alexanderdickson.com/javascript-typeof" target="_blank" rel="external">JavaScript’s typeof operator</a><br>也可以看ES5中关于<code>typeof</code>的介绍：<a href="http://www.w3.org/html/ig/zh/wiki/ES5/expressions#typeof_.E8.BF.90.E7.AE.97.E7.AC.A6" target="_blank" rel="external">typeof 运算符</a></p>
<h3 id="instanceof">instanceof</h3><p><code>instanceof</code>运算符是用于判断一个实例是否属于某一类型，例如：<code>a instanceof Person</code>，其内部原理实际上是判断<code>Person.prototype</code>是否在<code>a</code>实例的原型链中，其原理可以用下面的函数来表达：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance_of</span><span class="params">(V, F)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> O = F.prototype;</span><br><span class="line">  V = V.__proto__;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (V === <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (O === V)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    V = V.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>V8</code>源码的<code>runtime.js</code>中也有关于<code>instanceof</code>运算符的描述：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMA-262, section 11.8.6, page 54. To make the implementation more</span></span><br><span class="line"><span class="comment">// efficient, the return value should be zero if the 'this' is an</span></span><br><span class="line"><span class="comment">// instance of F, and non-zero if not. This makes it possible to avoid</span></span><br><span class="line"><span class="comment">// an expensive ToBoolean conversion in the generated code.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">INSTANCE_OF</span><span class="params">(F)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> V = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (!IS_SPEC_FUNCTION(F)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> %MakeTypeError(<span class="string">'instanceof_function_expected'</span>, [F]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If V is not an object, return false.</span></span><br><span class="line">  <span class="keyword">if</span> (!IS_SPEC_OBJECT(V)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if function is bound, if so, get [[BoundFunction]] from it</span></span><br><span class="line">  <span class="comment">// and use that instead of F.</span></span><br><span class="line">  <span class="keyword">var</span> bindings = %BoundFunctionGetBindings(F);</span><br><span class="line">  <span class="keyword">if</span> (bindings) &#123;</span><br><span class="line">    F = bindings[kBoundFunctionIndex];  <span class="comment">// Always a non-bound function.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Get the prototype of F; if it is not an object, throw an error.</span></span><br><span class="line">  <span class="keyword">var</span> O = F.prototype;</span><br><span class="line">  <span class="keyword">if</span> (!IS_SPEC_OBJECT(O)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> %MakeTypeError(<span class="string">'instanceof_nonobject_proto'</span>, [O]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return whether or not O is in the prototype chain of V.</span></span><br><span class="line">  <span class="keyword">return</span> %IsInPrototypeChain(O, V) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Object-prototype-toString-call(xxx)或{}-toString-call(xxx)">Object.prototype.toString.call(xxx)或{}.toString.call(xxx)</h3><p>这两个的区别在<a href="http://blog.alexanderdickson.com/javascript-typeof" target="_blank" rel="external">JavaScript’s typeof operator</a>中有说到：<code>You can always swap {} with Object.prototype, to save creating an object just to exploit its toString() method.</code>。也就是使用<code>Object.prototype.toString</code>会节省创建一个对象。</p>
<p>实际在使用时<code>Object.prototype.toString.call(xxx)</code>会返回类似<code>[object String]</code>的字符串给我们，用他我们就可以很好的判断变量的类型了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'sss'</span>;</span><br><span class="line"><span class="keyword">var</span> b = [];</span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(a))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(b))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(c))</span><br></pre></td></tr></table></figure>
<h2 id="类型转换">类型转换</h2><p>类型转换主要分为两大类：<code>ToPrimitive</code>和<code>ToObject</code>。其中<code>ToPrimitive</code>又分为了：<code>ToNumber</code>、<code>ToString</code>和<code>ToBoolean</code>。</p>
<h3 id="ToPrimitive">ToPrimitive</h3><p>看名字就能知道，<code>ToPrimitive</code>是用于变量需要转换为原始类型时调用。在<code>JavaScript</code>内部实现了该函数，在需要将变量转换为原始类型时就会调用该函数，下面看一下它的源代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMA-262, section 9.1, page 30. Use null/undefined for no hint,</span></span><br><span class="line"><span class="comment">// (1) for number hint, and (2) for string hint.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToPrimitive</span><span class="params">(x, hint)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Fast case check.</span></span><br><span class="line">  <span class="comment">// 如果为字符串，则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (IS_STRING(x)) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="comment">// Normal behavior.</span></span><br><span class="line">  <span class="keyword">if</span> (!IS_SPEC_OBJECT(x)) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">if</span> (IS_SYMBOL_WRAPPER(x)) <span class="keyword">throw</span> MakeTypeError(<span class="string">'symbol_to_primitive'</span>, []);</span><br><span class="line">  <span class="keyword">if</span> (hint == NO_HINT) hint = (IS_DATE(x)) ? STRING_HINT : NUMBER_HINT;</span><br><span class="line">  <span class="keyword">return</span> (hint == NUMBER_HINT) ? %DefaultNumber(x) : %DefaultString(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面有一个<code>hint</code>的参数，当没有传入<code>hint</code>参数时，且<code>x</code>不是<code>Date</code>对象时会通过<code>%DefaultNumber(x)</code>来转换，否则通过<code>%DefaultString(x)</code>。这里也可以看到日期类型的对象转换为原始类型时的不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMA-262, section 8.6.2.6, page 28.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DefaultNumber</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!IS_SYMBOL_WRAPPER(x)) &#123;</span><br><span class="line">    <span class="comment">// 转换为数字原始类型时，首先通过valueOf来转换</span></span><br><span class="line">    <span class="keyword">var</span> valueOf = x.valueOf;</span><br><span class="line">    <span class="keyword">if</span> (IS_SPEC_FUNCTION(valueOf)) &#123;</span><br><span class="line">      <span class="keyword">var</span> v = %_CallFunction(x, valueOf);</span><br><span class="line">      <span class="keyword">if</span> (%IsPrimitive(v)) <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则通过toString</span></span><br><span class="line">    <span class="keyword">var</span> toString = x.toString;</span><br><span class="line">    <span class="keyword">if</span> (IS_SPEC_FUNCTION(toString)) &#123;</span><br><span class="line">      <span class="keyword">var</span> s = %_CallFunction(x, toString);</span><br><span class="line">      <span class="keyword">if</span> (%IsPrimitive(s)) <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则抛出异常</span></span><br><span class="line">  <span class="keyword">throw</span> %MakeTypeError(<span class="string">'cannot_convert_to_primitive'</span>, []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ECMA-262, section 8.6.2.6, page 28.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DefaultString</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!IS_SYMBOL_WRAPPER(x)) &#123;</span><br><span class="line">    <span class="comment">// 转换为字符串原始类型时首先通过toString</span></span><br><span class="line">    <span class="keyword">var</span> toString = x.toString;</span><br><span class="line">    <span class="keyword">if</span> (IS_SPEC_FUNCTION(toString)) &#123;</span><br><span class="line">      <span class="keyword">var</span> s = %_CallFunction(x, toString);</span><br><span class="line">      <span class="keyword">if</span> (%IsPrimitive(s)) <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则通过valueOf</span></span><br><span class="line">    <span class="keyword">var</span> valueOf = x.valueOf;</span><br><span class="line">    <span class="keyword">if</span> (IS_SPEC_FUNCTION(valueOf)) &#123;</span><br><span class="line">      <span class="keyword">var</span> v = %_CallFunction(x, valueOf);</span><br><span class="line">      <span class="keyword">if</span> (%IsPrimitive(v)) <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则抛出异常</span></span><br><span class="line">  <span class="keyword">throw</span> %MakeTypeError(<span class="string">'cannot_convert_to_primitive'</span>, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ToNumber">ToNumber</h4><p><code>ToNumber</code>是用于将变量转换为<code>number</code>类型，它在<code>V8</code>中的实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMA-262, section 9.3, page 31.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToNumber</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果为number直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (IS_NUMBER(x)) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="comment">// 如果为字符串，则调用StringToNumber转换</span></span><br><span class="line">  <span class="keyword">if</span> (IS_STRING(x)) &#123;</span><br><span class="line">    <span class="keyword">return</span> %_HasCachedArrayIndex(x) ? %_GetCachedArrayIndex(x)</span><br><span class="line">                                    : %StringToNumber(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (IS_BOOLEAN(x)) <span class="keyword">return</span> x ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 如果为undefined，则返回NAN</span></span><br><span class="line">  <span class="keyword">if</span> (IS_UNDEFINED(x)) <span class="keyword">return</span> NAN;</span><br><span class="line">  <span class="comment">// 如果为symbol，则抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (IS_SYMBOL(x)) <span class="keyword">throw</span> MakeTypeError(<span class="string">'symbol_to_number'</span>, []);</span><br><span class="line">  <span class="comment">// 如果为null或</span></span><br><span class="line">  <span class="keyword">return</span> (IS_NULL(x)) ? <span class="number">0</span> : ToNumber(%DefaultNumber(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ToString">ToString</h4><p><code>ToString</code>是用于将变量转换为<code>string</code>类型，它在<code>V8</code>中的实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMA-262, section 9.8, page 35.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToString</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果为string，则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (IS_STRING(x)) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="comment">// 如果为number，则调用_NumberToString</span></span><br><span class="line">  <span class="keyword">if</span> (IS_NUMBER(x)) <span class="keyword">return</span> %_NumberToString(x);</span><br><span class="line">  <span class="comment">// 如果为boolean</span></span><br><span class="line">  <span class="keyword">if</span> (IS_BOOLEAN(x)) <span class="keyword">return</span> x ? <span class="string">'true'</span> : <span class="string">'false'</span>;</span><br><span class="line">  <span class="comment">// 如果为undefined，则返回undefined字符串</span></span><br><span class="line">  <span class="keyword">if</span> (IS_UNDEFINED(x)) <span class="keyword">return</span> <span class="string">'undefined'</span>;</span><br><span class="line">  <span class="comment">// 如果为symbol，则抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (IS_SYMBOL(x)) <span class="keyword">throw</span> %MakeTypeError(<span class="string">'symbol_to_string'</span>, []);</span><br><span class="line">  <span class="comment">// 如果为null，或者对象</span></span><br><span class="line">  <span class="keyword">return</span> (IS_NULL(x)) ? <span class="string">'null'</span> : %ToString(%DefaultString(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ToBoolean">ToBoolean</h4><p><code>ToBoolean</code>是用于将变量转换为<code>boolean</code>类型，它在<code>V8</code>中的实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMA-262, section 9.2, page 30</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToBoolean</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果为boolean，则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (IS_BOOLEAN(x)) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="comment">// 如果为string，则当字符串长度不为0时返回true</span></span><br><span class="line">  <span class="keyword">if</span> (IS_STRING(x)) <span class="keyword">return</span> x.length != <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 如果为null，返回false</span></span><br><span class="line">  <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 如果为number，当number不为0，且不为NAN时返回true</span></span><br><span class="line">  <span class="keyword">if</span> (IS_NUMBER(x)) <span class="keyword">return</span> !((x == <span class="number">0</span>) || NUMBER_IS_NAN(x));</span><br><span class="line">  <span class="comment">// 否则返回true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ToObject">ToObject</h3><p><code>ToObject</code>是用于变量需要转换为对象时调用。在<code>JavaScript</code>内部实现了该函数，在需要将变量转换为对象时就会调用该函数，下面看一下它的源代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMA-262, section 9.9, page 36.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToObject</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (IS_STRING(x)) <span class="keyword">return</span> <span class="keyword">new</span> $<span class="built_in">String</span>(x);</span><br><span class="line">  <span class="keyword">if</span> (IS_NUMBER(x)) <span class="keyword">return</span> <span class="keyword">new</span> $<span class="built_in">Number</span>(x);</span><br><span class="line">  <span class="keyword">if</span> (IS_BOOLEAN(x)) <span class="keyword">return</span> <span class="keyword">new</span> $<span class="built_in">Boolean</span>(x);</span><br><span class="line">  <span class="keyword">if</span> (IS_SYMBOL(x)) <span class="keyword">return</span> %NewSymbolWrapper(x);</span><br><span class="line">  <span class="comment">// 如果为null或undefined，抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (IS_NULL_OR_UNDEFINED(x) &amp;&amp; !IS_UNDETECTABLE(x)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> %MakeTypeError(<span class="string">'undefined_or_null_to_object'</span>, []);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ADD">ADD</h2><p>在<code>+</code>运算时也会涉及到类型转换，例如有面试题：<code>{} + 1</code>或<code>new Date() + 1</code>返回什么呢？这就要看看我们<code>V8</code>引擎内部是怎么对加法进行运算的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMA-262, section 11.6.1, page 50.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ADD</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Fast case: Check for number operands and do the addition.</span></span><br><span class="line">  <span class="comment">// 如果都为number或string，则直接调用NumberAdd或_StringAdd</span></span><br><span class="line">  <span class="keyword">if</span> (IS_NUMBER(<span class="keyword">this</span>) &amp;&amp; IS_NUMBER(x)) <span class="keyword">return</span> %NumberAdd(<span class="keyword">this</span>, x);</span><br><span class="line">  <span class="keyword">if</span> (IS_STRING(<span class="keyword">this</span>) &amp;&amp; IS_STRING(x)) <span class="keyword">return</span> %_StringAdd(<span class="keyword">this</span>, x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Default implementation.</span></span><br><span class="line">  <span class="comment">// 否则将两边操作数分别转换为原始类型</span></span><br><span class="line">  <span class="keyword">var</span> a = %ToPrimitive(<span class="keyword">this</span>, NO_HINT);</span><br><span class="line">  <span class="keyword">var</span> b = %ToPrimitive(x, NO_HINT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (IS_STRING(a)) &#123;</span><br><span class="line">    <span class="keyword">return</span> %_StringAdd(a, %ToString(b));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_STRING(b)) &#123;</span><br><span class="line">    <span class="keyword">return</span> %_StringAdd(%NonStringToString(a), b);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> %NumberAdd(%ToNumber(a), %ToNumber(b));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在操作数有一个不为number或string时，<code>ADD</code>操作就会将相应的操作数转换为原始类型，然后再进行相应的加法操作，可以看到上面的<code>{} + 1</code>，<code>{}</code>不为原始类型，所以就会调用<code>ToPrimitive({})</code>和<code>ToPrimitive(1)</code>，<code>ToPrimitive({})</code>调用的结果为<code>[object Object]</code>，所以最后会进行<code>_StringAdd</code>操作，最后的结果是：<code>[object Object]1</code>。</p>
<h2 id="Equals">Equals</h2><p>相等操作也会在某些情况下进行相应的类型转换，所以可以看看它的内部实现是怎样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMA-262 Section 11.9.3.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EQUALS</span><span class="params">(y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (IS_STRING(<span class="keyword">this</span>) &amp;&amp; IS_STRING(y)) <span class="keyword">return</span> %StringEquals(<span class="keyword">this</span>, y);</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果x为number</span></span><br><span class="line">    <span class="keyword">if</span> (IS_NUMBER(x)) &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IS_NUMBER(y)) <span class="keyword">return</span> %NumberEquals(x, y);</span><br><span class="line">        <span class="keyword">if</span> (IS_NULL_OR_UNDEFINED(y)) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// not equal</span></span><br><span class="line">        <span class="keyword">if</span> (IS_SYMBOL(y)) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// not equal</span></span><br><span class="line">        <span class="keyword">if</span> (!IS_SPEC_OBJECT(y)) &#123;</span><br><span class="line">          <span class="comment">// String or boolean.</span></span><br><span class="line">          <span class="keyword">return</span> %NumberEquals(x, %ToNumber(y));</span><br><span class="line">        &#125;</span><br><span class="line">        y = %ToPrimitive(y, NO_HINT);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_STRING(x)) &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IS_STRING(y)) <span class="keyword">return</span> %StringEquals(x, y);</span><br><span class="line">        <span class="keyword">if</span> (IS_SYMBOL(y)) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// not equal</span></span><br><span class="line">        <span class="keyword">if</span> (IS_NUMBER(y)) <span class="keyword">return</span> %NumberEquals(%ToNumber(x), y);</span><br><span class="line">        <span class="keyword">if</span> (IS_BOOLEAN(y)) <span class="keyword">return</span> %NumberEquals(%ToNumber(x), %ToNumber(y));</span><br><span class="line">        <span class="keyword">if</span> (IS_NULL_OR_UNDEFINED(y)) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// not equal</span></span><br><span class="line">        y = %ToPrimitive(y, NO_HINT);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_SYMBOL(x)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (IS_SYMBOL(y)) <span class="keyword">return</span> %_ObjectEquals(x, y) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// not equal</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_BOOLEAN(x)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (IS_BOOLEAN(y)) <span class="keyword">return</span> %_ObjectEquals(x, y) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (IS_NULL_OR_UNDEFINED(y)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (IS_NUMBER(y)) <span class="keyword">return</span> %NumberEquals(%ToNumber(x), y);</span><br><span class="line">      <span class="keyword">if</span> (IS_STRING(y)) <span class="keyword">return</span> %NumberEquals(%ToNumber(x), %ToNumber(y));</span><br><span class="line">      <span class="keyword">if</span> (IS_SYMBOL(y)) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// not equal</span></span><br><span class="line">      <span class="comment">// y is object.</span></span><br><span class="line">      x = %ToNumber(x);</span><br><span class="line">      y = %ToPrimitive(y, NO_HINT);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_NULL_OR_UNDEFINED(x)) &#123;</span><br><span class="line">      <span class="keyword">return</span> IS_NULL_OR_UNDEFINED(y) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// x is an object.</span></span><br><span class="line">      <span class="keyword">if</span> (IS_SPEC_OBJECT(y)) &#123;</span><br><span class="line">        <span class="keyword">return</span> %_ObjectEquals(x, y) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (IS_NULL_OR_UNDEFINED(y)) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// not equal</span></span><br><span class="line">      <span class="keyword">if</span> (IS_SYMBOL(y)) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// not equal</span></span><br><span class="line">      <span class="keyword">if</span> (IS_BOOLEAN(y)) y = %ToNumber(y);</span><br><span class="line">      x = %ToPrimitive(x, NO_HINT);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码逻辑大概是这样的：</p>
<ol>
<li>如果有一个操作数为string，则执行<code>StringEquals</code>操作</li>
<li>否则，如果第一个操作数为number，如果另外一个操作数为原始类型（非null和undefined），则将其执行<code>ToNumber</code>，并进行<code>NumberEquals</code>，如果为<code>null</code>和<code>undefined</code>则返回<code>false</code>，如果为对象类型，则将该操作数执行<code>ToPrimitive</code>后再重复以上步骤</li>
<li>否则，如果第一个操作数为string，如果另外一个操作数也为string，则进行<code>StringEquals</code>，如果为number或<code>boolean</code>，则将第一个操作数执行<code>ToNumber</code>，再进行<code>NumberEquals</code>，如果为<code>null</code>和<code>undefined</code>则返回<code>false</code>，如果为对象类型，则将该操作数执行<code>ToPrimitive</code>后再重复以上步骤</li>
<li>否则如果第一个操作数为boolean，如果另外一个操作数也为<code>boolean</code>，则进行<code>_ObjectEquals</code>，否则如果为string或number，则进行<code>NumberEquals</code>，如果为<code>null</code>和<code>undefined</code>则返回<code>false</code>，如果为对象类型，则将该操作数执行<code>ToPrimitive</code>后再重复以上步骤</li>
<li>如果第一个操作数为对象类型，则将其<code>ToPrimitive</code>，在重复以上步骤</li>
</ol>
<p>例如有个面试题是这样的<code>[] == ![]</code>，是<code>true</code>还是<code>false</code>，我们首先看右边的<code>![]</code>，空数组转换为boolean是<code>true</code>的，再进行<code>!</code>，可以知道右边的<code>![]</code>为<code>false</code>，当一个对象和boolean进行<code>equal</code>时，<code>[]</code>会进行<code>ToPrimitive</code>，这里就会首先调用<code>Array.prototype.valueOf</code>，调用后返回的是<code>[]</code>，不是原始类型，再进行<code>Array.prototype.toString</code>，这里返回了<code>&quot;&quot;</code>空字符，空字符和<code>false</code>进行相等比较这里就是<code>true</code>了。</p>
<h2 id="Compare">Compare</h2><p>什么是<code>Compare</code>呢，就是<code>&gt; &lt; &lt;=</code>这些操作都是<code>compare</code>，<code>compare</code>也会涉及到类型转换的操作，我们这里看内部<code>compare</code>是怎么实现的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMA-262, section 11.8.5, page 53. The 'ncr' parameter is used as</span></span><br><span class="line"><span class="comment">// the result when either (or both) the operands are NaN.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">COMPARE</span><span class="params">(x, ncr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> left;</span><br><span class="line">  <span class="keyword">var</span> right;</span><br><span class="line">  <span class="comment">// Fast cases for string, numbers and undefined compares.</span></span><br><span class="line">  <span class="keyword">if</span> (IS_STRING(<span class="keyword">this</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (IS_STRING(x)) <span class="keyword">return</span> %_StringCompare(<span class="keyword">this</span>, x);</span><br><span class="line">    <span class="keyword">if</span> (IS_UNDEFINED(x)) <span class="keyword">return</span> ncr;</span><br><span class="line">    left = <span class="keyword">this</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_NUMBER(<span class="keyword">this</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (IS_NUMBER(x)) <span class="keyword">return</span> %NumberCompare(<span class="keyword">this</span>, x, ncr);</span><br><span class="line">    <span class="keyword">if</span> (IS_UNDEFINED(x)) <span class="keyword">return</span> ncr;</span><br><span class="line">    left = <span class="keyword">this</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_UNDEFINED(<span class="keyword">this</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!IS_UNDEFINED(x)) &#123;</span><br><span class="line">      %ToPrimitive(x, NUMBER_HINT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ncr;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_UNDEFINED(x)) &#123;</span><br><span class="line">    %ToPrimitive(<span class="keyword">this</span>, NUMBER_HINT);</span><br><span class="line">    <span class="keyword">return</span> ncr;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    left = %ToPrimitive(<span class="keyword">this</span>, NUMBER_HINT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  right = %ToPrimitive(x, NUMBER_HINT);</span><br><span class="line">  <span class="keyword">if</span> (IS_STRING(left) &amp;&amp; IS_STRING(right)) &#123;</span><br><span class="line">    <span class="keyword">return</span> %_StringCompare(left, right);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left_number = %ToNumber(left);</span><br><span class="line">    <span class="keyword">var</span> right_number = %ToNumber(right);</span><br><span class="line">    <span class="keyword">if</span> (NUMBER_IS_NAN(left_number) || NUMBER_IS_NAN(right_number)) <span class="keyword">return</span> ncr;</span><br><span class="line">    <span class="keyword">return</span> %NumberCompare(left_number, right_number, ncr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>compare</code>操作相对于<code>equal</code>还是相对来说简单一点的，它首先会判断第一个操作数，如果为对象则将其<code>ToPrimitive</code>，否则如果两个操作数都为<code>string</code>时，进行<code>_StringCompare</code>，否则，将两个操作数都<code>ToNumber</code>再进行<code>NumberCompare</code>。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScript/">JavaScript</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/04/09/javascript-types/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/04/09/javascript-types/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/02/05/css-selectors/" title="CSS 选择器" itemprop="url">CSS 选择器</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-02-05T08:47:42.000Z" itemprop="datePublished"> 發表於 2015-02-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文是从<a href="http://www.w3.org/TR/css3-selectors/#selector-syntax" target="_blank" rel="external">Selectors Level 3</a>提取出的一些重点，如有不懂的地方可以看原文对照。</p>
<h2 id="1-_选择器语法">1. 选择器语法</h2><p>一个选择器是一个或多个被<a href="http://www.w3.org/TR/css3-selectors/#combinators" target="_blank" rel="external">连结符</a>分隔的简单选择器序列组成的链。一个<a href="http://www.w3.org/TR/css3-selectors/#pseudo-elements" target="_blank" rel="external">伪元素</a>可能会附加到选择器中的最后一个简单选择器序列。</p>
<p>一个简单选择器序列是没有被<a href="http://www.w3.org/TR/css3-selectors/#combinators" target="_blank" rel="external">连结符</a>分隔的<a href="http://www.w3.org/TR/css3-selectors/#simple-selectors-dfn" target="_blank" rel="external">简单选择器</a>组成的链。它总是以一个<a href="http://www.w3.org/TR/css3-selectors/#type-selectors" target="_blank" rel="external">类型选择器</a>或<a href="http://www.w3.org/TR/css3-selectors/#universal-selector" target="_blank" rel="external">通用选择器</a>开始。除了类型选择器和通用选择器，没有其他类型的选择器允许在序列中。</p>
<p>一个简单选择器可以是<a href="http://www.w3.org/TR/css3-selectors/#type-selectors" target="_blank" rel="external">类型选择器</a>，<a href="http://www.w3.org/TR/css3-selectors/#universal-selector" target="_blank" rel="external">通用选择器</a>，<a href="http://www.w3.org/TR/css3-selectors/#attribute-selectors" target="_blank" rel="external">属性选择器</a>，<a href="http://www.w3.org/TR/css3-selectors/#class-html" target="_blank" rel="external">类选择器</a>，<a href="http://www.w3.org/TR/css3-selectors/#id-selectors" target="_blank" rel="external">id选择器</a>或<a href="http://www.w3.org/TR/css3-selectors/#pseudo-classes" target="_blank" rel="external">伪类</a>。</p>
<p>连结符可以是：空白、<code>&gt;</code>、<code>+</code>、<code>~</code>。</p>
<p>一个文档树的元素被选择器所代表，它是选择器的主题（subject）。一个选择器组成了一个简单选择器的单一序列，代表了任何满足它需求的元素。前面加上其他的简单选择器序列，且序列中的连结符施加了额外的匹配限制，所以一个选择器的主题总是最后一个简单选择器序列所代表的元素的子集。</p>
<p>一个空的选择器，没有包含简单选择器序列和伪元素，是一个<a href="http://www.w3.org/TR/css3-selectors/#Conformance" target="_blank" rel="external">无效的选择器</a>。</p>
<p>选择器中的字符可以根据在<code>CSS2</code>中相同的<a href="http://www.w3.org/TR/CSS21/syndata.html#characters" target="_blank" rel="external">转义规则</a>并通过<code>\</code>来转义。</p>
<h2 id="2-_选择器组">2.  选择器组</h2><p>一个逗号分隔的选择器列表表示了被任何单一选择器选择的所有元素的组合。例如，在<code>CSS</code>中当一些选择器共享相同的声明时，它们可以组合成一个逗号分隔的列表。空格可能出现在逗号的前面或后面。</p>
<p><strong><code>CSS</code>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">h1</span> <span class="rules">&#123; <span class="rule"><span class="attribute">font-family</span>:<span class="value"> sans-serif &#125;</span><br><span class="line">h2 &#123; font-family: sans-serif &#125;</span><br><span class="line">h3 &#123; font-family: sans-serif &#125;</span></span></span></span><br></pre></td></tr></table></figure>
<p>上面等价于：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">h1</span>, <span class="tag">h2</span>, <span class="tag">h3</span> <span class="rules">&#123; <span class="rule"><span class="attribute">font-family</span>:<span class="value"> sans-serif &#125;</span></span></span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>在本例中等价是真的，因为所有的选择器是有效的选择器。如果选择器中的一个是无效的选择器，那么整个声明是无效的。</p>
<p>无效的<code>CSS</code>实例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">h1</span> <span class="rules">&#123; <span class="rule"><span class="attribute">font-family</span>:<span class="value"> sans-serif &#125;</span><br><span class="line">h2..foo &#123; font-family: sans-serif &#125;</span><br><span class="line">h3 &#123; font-family: sans-serif &#125;</span></span></span></span><br></pre></td></tr></table></figure>
<p>不等价于：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">h1</span>, <span class="tag">h2</span>.<span class="class">.foo</span>, <span class="tag">h3</span> <span class="rules">&#123; <span class="rule"><span class="attribute">font-family</span>:<span class="value"> sans-serif &#125;</span></span></span></span><br></pre></td></tr></table></figure>
<p>在实际应用中也没有人这样写了。否则肯定早晚开除了。</p>
<h2 id="3-_简单选择器">3. 简单选择器</h2><h3 id="3-1_类型选择器">3.1 类型选择器</h3><p>一个类型选择器是文档语言元素类型的名称，并使用<a href="http://www.w3.org/TR/css3-namespace/#css-qnames" target="_blank" rel="external">CSS qualified names</a>语法。一个类型选择器表示了在文档树中元素类型的实例。</p>
<p><strong>实例</strong>：</p>
<p>以下的选择器表示了在文档树中的<code>h1</code>元素：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">h1</span></span><br></pre></td></tr></table></figure>
<h4 id="3-1-1_类型选择器和命名空间">3.1.1 类型选择器和命名空间</h4><p>类型选择器允许一个可选的命名空间组件：一个命名空间前缀被定义在元素名的前面，并通过<code>|</code>符号来分隔。</p>
<p>命名空间可能为空，代表了选择器没有命名空间。</p>
<p>一个<code>*</code>可被用作为命名空间前缀，表明代表了元素的所有命名空间。</p>
<p>元素类型选择器在没有命名空间组件时代表了元素不会考虑元素的命名空间（等价于<code>*|</code>），除非定义了一个默认的命名空间。如果一个默认命名空间被声明，这些元素会代表在默认命名空间中的元素。</p>
<p>那怎么定义默认命名空间呢？</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">namespace</span> <span class="string">"http://www.w3.org/1999/xhtml"</span></span>;</span><br><span class="line"><span class="at_rule">@<span class="keyword">namespace</span> svg <span class="string">"http://www.w3.org/2000/svg"</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面的<code>http://www.w3.org/1999/xhtml</code>就为默认的命名空间。</p>
<p>总结(要注意的是<code>|</code>前后没有空格的哟)：</p>
<p><strong>ns|E</strong><br>元素为<code>E</code>且在命名空间<code>ns</code>中</p>
<p><strong>*|E</strong><br>元素为<code>E</code>且在任何命名空间中</p>
<p><strong>|E</strong><br>元素为<code>E</code>且没有命名空间</p>
<p><strong>E</strong><br>如果没有为选择器定义默认的命名空间，这个等价于<code>*|E</code>。否则等价于<code>ns|E</code>，且<code>ns</code>为默认的命名空间。</p>
<p><code>CSS</code>实例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@namespace foo url(http://www.example.com);</span><br><span class="line"> foo|h1 &#123; color: blue &#125;  /* first rule */</span><br><span class="line"> foo|* &#123; color: yellow &#125; /* second rule */</span><br><span class="line"> |h1 &#123; color: red &#125;      /* ...*/</span><br><span class="line"> *|h1 &#123; color: green &#125;</span><br><span class="line"> h1 &#123; color: green &#125;</span><br></pre></td></tr></table></figure>
<p>第一条规则只会匹配在<code>http://www.example.com</code>命名空间中的<code>h1</code>元素。<br>第二条规则会匹配在<code>http://www.example.com</code>命名空间中的所有元素。<br>第三条规则只会匹配没有命名空间的<code>h1</code>元素。<br>第四条规则会匹配在任何命名空间中的<code>h1</code>元素。<br>第五条规则等价于第四条规则，因为没有默认的命名空间被定义。</p>
<h3 id="3-2_通用选择器">3.2 通用选择器</h3><p>通用选择器，用<code>*</code>来表示，它代表了任何元素类型的限定名。它代表了在文档树中的任何命名空间的任何单一元素，如果没有为选择器指定默认的命名空间。如果指定了默认的命名空间，可以看下面的<a href="http://www.w3.org/TR/css3-selectors/#univnmsp" target="_blank" rel="external">通用选择器和命名空间</a>。</p>
<p>如果一个通用选择器不是选择器序列的唯一组件，或者它后面紧跟了<a href="http://www.w3.org/TR/css3-selectors/#pseudo-elements" target="_blank" rel="external">伪元素</a>，那么<code>*</code>可以省略，通用选择器隐含的表示存在。</p>
<p><strong>实例：</strong></p>
<ul>
<li><code>*[hreflang|=en]</code>和<code>[hreflang|=en]</code>是等价的</li>
<li><code>*.warning</code>和<code>.warning</code>是等价的</li>
<li><code>*#myid</code>和<code>#myid</code>是等价的</li>
</ul>
<h4 id="3-2-1_通用选择器和命名空间">3.2.1 通用选择器和命名空间</h4><p>通用选择器允许一个可选的命名空间组件。它可以按照以下方式来使用：</p>
<p><code>ns|*</code><br>在<code>ns</code>命名空间中的所有元素</p>
<p><code>*|*</code><br>所有元素</p>
<p><code>|*</code><br>所有没有命名空间的元素</p>
<p><code>*</code><br>如果没有默认指定默认的命名空间，则等价于<code>*|*</code>，否则等价于<code>ns|*</code>，如果<code>ns</code>为默认的命名空间。</p>
<h3 id="3-3_属性选择器">3.3 属性选择器</h3><p>选择器允许表示元素的属性。当选择器被用作为一个表达式来匹配元素时，属性选择器必须认为匹配元素如果元素有一个属性且匹配属性选择器所代表的属性时。</p>
<h4 id="3-3-1_属性存在和值选择器">3.3.1 属性存在和值选择器</h4><p><code>CSS2</code>介绍了四种属性选择器：</p>
<p><code>[att]</code><br>代表了元素有一个<code>att</code>属性，不管属性的值是什么。</p>
<p><code>[att=val]</code><br>代表了元素有一个<code>att</code>属性，且值为<code>val</code>。这种可以用于选择例如：<code>input[type=&quot;text&quot;]</code></p>
<p><code>[att~=val]</code><br>代表了元素有一个<code>att</code>属性，且它的值为空白分隔的列表，其中的一个值为<code>val</code>，如果选择器中的<code>val</code>包含了空白，它永远不会代表什么。同样，如果<code>val</code>为空字符串，它永远不会代表什么。</p>
<p><code>[att|=val]</code><br>代表了元素有一个<code>att</code>属性，且它的值为<code>val</code>或者<code>val</code>紧跟着<code>-</code>。</p>
<p><strong>实例：</strong></p>
<p>下面的属性选择器代表了<code>h1</code>元素，且它有一个<code>title</code>属性，且不管值为多少：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">h1</span><span class="attr_selector">[title]</span></span><br></pre></td></tr></table></figure>
<p>下面的例子选择器代表了一个<code>span</code>元素它的<code>class</code>属性的值为<code>example</code>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">span</span><span class="attr_selector">[class="example"]</span></span><br></pre></td></tr></table></figure>
<p>下面的选择器代表了一个<code>a</code>元素，且它的<code>hreflang</code>属性值为<code>en</code>或<code>en-US</code>等</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">a</span><span class="attr_selector">[hreflang|="en"]</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-2_子字符串匹配属性选择器">3.3.2 子字符串匹配属性选择器</h4><p>三个附加的属性选择器被提供给匹配属性值的子字符串：</p>
<p><code>[att^=val]</code><br>代表了元素有一个<code>att</code>属性，且值以<code>val</code>前缀开始。如果<code>val</code>为空字符串，则这个选择器不会代表任何元素</p>
<p><code>[att$=val]</code><br>代表了元素有一个<code>att</code>属性，且值以<code>val</code>后缀结束。如果<code>val</code>为空字符串，则这个选择器不会代表任何元素</p>
<p><code>[att*=val]</code><br>代表了元素有一个<code>att</code>属性，且值包含至少子字符串<code>val</code>的一个实例。如果<code>val</code>为空字符串，则这个选择器不会代表任何元素</p>
<p><strong>实例：</strong></p>
<p>下面的选择器代表了一个<code>HTML</code>的<code>object</code>，引用了一个图片：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">object</span><span class="attr_selector">[type^="image/"]</span></span><br></pre></td></tr></table></figure>
<p>下面的选择器代表了一个<code>HTML</code>链接<code>a</code>，且它的<code>href</code>属性以<code>.html</code>结尾：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">a</span><span class="attr_selector">[href$=".html"]</span></span><br></pre></td></tr></table></figure>
<p>下面的选择器代表了<code>HTML</code>段落中<code>title</code>属性包含了子字符串<code>hello</code>：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">p</span><span class="attr_selector">[title*="hello"]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-3_属性选择器和命名空间">3.3.3 属性选择器和命名空间</h4><p>在属性选择器中的属性名是以<a href="http://www.w3.org/TR/css3-namespace/#css-qnames" target="_blank" rel="external">CSS限定名</a>给出：先前已声明的命名空间前缀可预先准备给由命名空间分隔符<code>|</code>分隔的属性名。为了保持命名空间在<code>XML</code>中的推荐，默认的命名空间不会应用到属性中，因此，没有命名空间组件的属性选择器只应用到那些没有命名空间的属性。一个<code>*</code>可能被用于命名空间前缀以表明该选择器可匹配所有属性名而不用考虑属性的命名空间。</p>
<p>一个属性选择器有一个属性名包含了命名空间前缀，但是该命名空间没有在之前定义，这时该属性选择器是一个无效的选择器。</p>
<p><code>CSS</code>实例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">namespace</span> foo <span class="string">"http://www.example.com"</span></span>;</span><br><span class="line"><span class="attr_selector">[foo|att=val]</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> blue &#125;</span><br><span class="line">[*|att] &#123; color: yellow &#125;</span><br><span class="line">[|att] &#123; color: green &#125;</span><br><span class="line">[att] &#123; color: green &#125;</span></span></span></span><br></pre></td></tr></table></figure>
<p>第一条规则只匹配有在<code>http://www.example.com</code>命名空间下的属性<code>att</code>，且值为<code>val</code>的元素。</p>
<p>第二条规则只匹配具有属性<code>att</code>，且不管属性的命名空间。</p>
<p>最后两条规则是等价的，且只匹配具有属性<code>att</code>，且该属性不在任何命名空间下的元素。</p>
<h4 id="3-3-4_在DTDs中的默认属性值">3.3.4 在<code>DTDs</code>中的默认属性值</h4><p>属性选择器代表了在文档树中的属性值。文档树如何构建是在选择器之外的。在某些文档格式中，默认的属性值可以定义在<code>DTD</code>或其他地方，如果它们出现在文档树中的话，这些只能通过属性选择器来选择。选择器的设计应该使它们工作，不管默认值是否包含在文档树中。</p>
<p>例如，一个<code>XML</code>的用户代理可能并不需要去读取一个<code>DTD</code>的<code>外部子集</code>，但是需要在文档的<code>内部子集</code>寻找默认属性值（看这里：<a href="http://www.w3.org/TR/css3-selectors/#XML10" target="_blank" rel="external">XML10</a>）。取决于用户代理，一个定义在<code>DTD</code>的外部子集的默认的属性值可能会或可能不会出现在文档树中。</p>
<p>一个识别<code>XML</code>命名空间的用户代理可能不需要利用它的对于那个命名空间的认知来对待默认的属性值，就好像它们就在文档中。（例如，一个<code>XHTML</code>的用户代理不需要利用它内置的该<code>XHTML DTD</code>的认知）</p>
<p><strong>实例：</strong></p>
<p>考虑一个元素<code>example</code>，它有一个属性<code>radix</code>，且其默认值为<code>decimal</code>。<code>DTD</code>片段可能为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">!ATTLIST</span> <span class="attribute">EXAMPLE</span> <span class="attribute">radix</span> (<span class="attribute">decimal</span>,<span class="attribute">octal</span>) "<span class="attribute">decimal</span>"&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果样式表包含了这些规则：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">EXAMPLE</span><span class="attr_selector">[radix=decimal]</span> <span class="rules">&#123; <span class="comment">/*... default property settings ...*/</span> &#125;</span></span><br><span class="line"><span class="tag">EXAMPLE</span><span class="attr_selector">[radix=octal]</span>   <span class="rules">&#123; <span class="comment">/*... other settings...*/</span> &#125;</span></span><br></pre></td></tr></table></figure>
<p>第一条规则可能不会匹配那些<code>radix</code>属性被设置为默认值的元素，即为明确设置。为了捕获所有情况，属性选择器的默认值必须被舍弃：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">EXAMPLE</span>                <span class="rules">&#123; <span class="comment">/*... default property settings ...*/</span> &#125;</span></span><br><span class="line"><span class="tag">EXAMPLE</span><span class="attr_selector">[radix=octal]</span>   <span class="rules">&#123; <span class="comment">/*... other settings...*/</span> &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4_类选择器">3.4 类选择器</h3><p>与<code>HTML</code>工作，作者可能会使用<code>句点</code>符号（也就是<code>.</code>）来代替<code>~=</code>符号表示<code>class</code>属性。因此，对于<code>HTML</code>，<code>div.value</code>和<code>div[class~=value]</code>是具有同样的含义的。该属性值必须紧跟在<code>.</code>符号后面。</p>
<p>如果用户代理具有命名空间特定的知识，且允许它确定哪个属性是<code>class</code>属性用于各个命名空间，用户代理可能使用<code>.</code>符号在<code>XML</code>文档中应用选择器。</p>
<p><strong>CSS实例：</strong></p>
<p>我们可以通过以下方式来分配样式给所有<code>class~=&quot;pastoral&quot;</code>的元素：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*<span class="class">.pastoral</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> green &#125;  <span class="comment">/* all elements with class~=pastoral */</span></span></span></span></span><br></pre></td></tr></table></figure>
<p>或者只是：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.pastoral</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> green &#125;  <span class="comment">/* all elements with class~=pastoral */</span></span></span></span></span><br></pre></td></tr></table></figure>
<p>以下只分配样式给所有<code>class~=&quot;pastoral&quot;</code>的<code>h1</code>元素：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">H1</span><span class="class">.pastoral</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> green &#125;  <span class="comment">/* H1 elements with class~=pastoral */</span></span></span></span></span><br></pre></td></tr></table></figure>
<h3 id="3-5_ID选择器">3.5 ID选择器</h3><p>文档语言可以包含声明为ID类型的属性。ID类型属性的特殊之处在于在一致性的文档中没有两个这样的属性可以有相同的值，且不管携带该属性的元素类型；无论什么文档语言，一个ID类型属性可被用于唯一地标识其元素。</p>
<p>ID选择器是以<code>#</code>开头，然后紧跟着ID值。</p>
<p><strong>实例：</strong></p>
<p>以下ID选择器代表了一个<code>h1</code>元素，且它的id属性值为<code>chapter1</code></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">h1</span><span class="id">#chapter1</span></span><br></pre></td></tr></table></figure>
<p>不过很少会像上面这样写，一般是像下面这样：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#chapter1</span></span><br></pre></td></tr></table></figure>
<h3 id="3-6_伪类">3.6 伪类</h3><p>伪类的概念被引入以允许选择位于该文档树以外或者使用其他简单选择器不能表达的信息。</p>
<p>一个伪类总是包含<code>:</code>跟着伪类的名称和一个可选的值被放在圆括号之间。</p>
<p>伪类中允许包含在选择器中的所有简单选择器序列。伪类可以出现在简单选择器序列的任何地方，类型选择器和通用选择器（可能省略）后面。伪类名是不区分大小写。一些伪类是相互排斥的，而另一些可以同时施加到相同的元素。伪类可能是动态的，在这个意义上，元素可能获得或失去一个伪类当用户与文档进行交互的时候。</p>
<h4 id="3-6-1_动态伪类">3.6.1 动态伪类</h4><p>动态伪类在特性上分类元素，除了它们的名字、属性或内容，原则上特性不能从文档树中推断出来。</p>
<p>动态伪类不会出现在文档源或文档树中。</p>
<h5 id="3-6-1-1_链接伪类：:link和:visited">3.6.1.1 链接伪类：<code>:link</code>和<code>:visited</code></h5><p>用户代理通常显示未访问的链接不同于之前访问过的。选择器提供了伪类<code>:link</code>和<code>:visited</code>来区分它们。</p>
<ul>
<li><code>:link</code>伪类应用在那些没有被访问过的链接</li>
<li><code>:visited</code>伪类应用在那些已经被用户访问过的链接</li>
</ul>
<p>经过一定的时间，用户代理可能选择返回一个访问过的链接为<code>:link</code>状态。</p>
<p>这两种状态是互斥的。</p>
<p><strong>实例：</strong></p>
<p>下面的选择器代表了有一个<code>external</code>类的链接，且被访问过：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">a.external</span>:<span class="value">visited</span></span></span><br></pre></td></tr></table></figure>
<p>用户代理可能会因此对待所有的链接为未访问链接，或者采取其他措施以保护用户的隐私，而对访问和未访问链接渲染出不同。</p>
<h5 id="3-6-1-2_用户动作伪类:hover、:active和:focus">3.6.1.2 用户动作伪类<code>:hover</code>、<code>:active</code>和<code>:focus</code></h5><p>交互式用户代理有时会为了响应用户操作而改变呈现。选择器提供了三个伪类来选择这些用户正在作用的元素。</p>
<ul>
<li><code>:hover</code>伪类应用在当用户通过定位设备来指定元素，但不一定激活它时。例如，一个视觉用户代理可以应用伪类当光标悬停到元素所生成的盒子上时。用户代理不支持交互式媒体的不需要支持该伪类。支持交互式媒体的一些用户代理可能无法支持这个伪类。</li>
<li><code>:active</code>伪类应用在正被用户激活的元素上。例如，在用户按下鼠标按钮和释放它之间。在多于一个鼠标按钮的系统，<code>:active</code>仅应用在主激活按钮（通常是鼠标左键），以及它们的任意别名。</li>
<li><code>:focus</code>伪类应用在获得焦点的元素</li>
</ul>
<p>这些伪类不是相互排斥的。一个元素可以在相同的时间匹配的几个伪类。</p>
<p>选择器没有定义当元素的父亲也在<code>:active</code>或<code>:hover</code>状态时。</p>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">a</span>:<span class="value">link    <span class="comment">/* unvisited links */</span></span><br><span class="line">a:visited <span class="comment">/* visited links */</span></span><br><span class="line">a:hover   <span class="comment">/* user hovers */</span></span><br><span class="line">a:active  <span class="comment">/* active links */</span></span></span></span><br></pre></td></tr></table></figure>
<p>或者结合多个动态伪类：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">a</span>:<span class="value">focus</span><br><span class="line">a:focus:hover</span></span></span><br></pre></td></tr></table></figure>
<h4 id="3-6-2_目标伪类:target">3.6.2 目标伪类<code>:target</code></h4><p>一些<code>URIs</code>会引用资源内的一个位置。这种类型的<code>URI</code>是以<code>#</code>紧跟锚标识符结束。</p>
<p>有片段标识浮的<code>URIs</code>链接到文档内的某个元素，被称为目标元素。举例来说，这里给出了一个<code>URI</code>指向文档中一个名为<code>section_2</code>的锚。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//example.com/html/top.html#section_2</span></span><br></pre></td></tr></table></figure>
<p>一个目标元素可以使用<code>:target</code>伪类来表示。如果文档的URI没有片段标识符，则该文档没有目标元素。</p>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">p.note</span>:<span class="value">target</span></span></span><br></pre></td></tr></table></figure>
<p>这个选择器代表了一个<code>p</code>标签，且它有一个类<code>note</code>，且它是指定<code>URI</code>的目标元素时。</p>
<h4 id="3-6-3_语言伪类:lang">3.6.3 语言伪类<code>:lang</code></h4><p>如果文档语言指定了一个元素的人类语言如何确定，则可以使用选择器来代表基于该语言的元素。例如，在<code>HTML</code>中，语言是由<code>lang</code>属性和从<code>meta</code>元素的信息或<code>HTTP</code>协议联合决定的。<code>XML</code>使用一个叫做<code>xml:lang</code>的属性，并且还可能有其他的文档语言特定的方法，用于确定使用的语言。</p>
<p>伪类<code>:lang(C)</code>代表了在语言<code>C</code>中的元素。一个元素是否通过<code>:lang</code>被代表是完全基于元素的语言值是否和标识符<code>C</code>相等，或者是以标识符<code>C</code>开始并紧跟着<code>-</code>。对<code>C</code>和元素语言值的匹配是不区分大小写的。标识符<code>C</code>不必须是一个有效的语言名称。</p>
<p><code>C</code>必须是一个有效的<code>CSS</code>标识符，且不能为空。</p>
<p>实例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">html</span>:<span class="value"><span class="function">lang</span>(fr-be)</span><br><span class="line">html:<span class="function">lang</span>(de)</span><br><span class="line">:<span class="function">lang</span>(fr-be) &gt; q</span><br><span class="line">:<span class="function">lang</span>(de) &gt; q</span></span></span><br></pre></td></tr></table></figure>
<h4 id="3-6-4_UI元素状态伪类">3.6.4 UI元素状态伪类</h4><h5 id="3-6-4-1_:enabled和:disabled伪类">3.6.4.1 <code>:enabled</code>和<code>:disabled</code>伪类</h5><p><code>:enabled</code>伪类代表了处于激活状态的用户界面元素；这些元素都有相应的禁用状态。</p>
<p>相反地，<code>:disabled</code>伪类代表了处于禁用状态的用户界面元素；这些元素都有相应的激活状态。</p>
<p>什么构成激活状态、禁用状态和用户界面元素是语言决定的。在一个典型的文档中大多数元素即不会是<code>:enabled</code>也不会是<code>:disabled</code>。</p>
<p>那什么元素有这种状态呢，<code>input</code>、<code>textarea</code>等元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line"><span class="rule"><span class="attribute">input</span>:<span class="value">disabled &#123;</span><br><span class="line">	border: <span class="number">1px</span> solid blue</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="rule"><span class="attribute">input</span>:<span class="value">enabled &#123;</span><br><span class="line">	border: <span class="number">1px</span> solid red</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">disabled</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="3-6-4-2_:checked伪类">3.6.4.2 <code>:checked</code>伪类</h5><p>单选框和复选框元素可以被用户切换。一些菜单项被勾选，当用户选择它们的时候。<code>:checked</code>伪类就是应用在这些有<code>selected</code>和<code>checked</code>属性的元素，这些元素包含<code>checkbox</code>、<code>radio</code>、<code>option</code>等。</p>
<p>实例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line"><span class="rule"><span class="attribute">input</span>:<span class="value">checked + label &#123;</span><br><span class="line">	color: red</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">label</span>&gt;</span>checkbox<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"radio"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">label</span>&gt;</span>radio<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="3-6-4-3_:indeterminate伪类">3.6.4.3 <code>:indeterminate</code>伪类</h5><p>这个是对于<code>radio</code>和<code>checkbox</code>有时处于一种模糊的状态，即不是<code>checked</code>，也不是<code>unchecked</code>。</p>
<h4 id="3-6-5_结构伪类">3.6.5 结构伪类</h4><p>选择器引入了结构伪类的概念，允许基于在文档树中确定的信息来选择，但是不能通过其他简单选择器或连结符来表示。</p>
<p>当在它父亲的孩子列表中计算一个元素的位置时，独立文本和其他非元素节点不计算在内当计算在其父亲的孩子列表中的元素的位置，该指数的编号从1开始。</p>
<h5 id="3-6-5-1_:root伪类">3.6.5.1 <code>:root</code>伪类</h5><p><code>:root</code>伪类代表了文档的根元素。在<code>HTML4</code>中总是<code>html</code>元素。</p>
<h5 id="3-6-5-2_:nth-child()伪类">3.6.5.2 <code>:nth-child()</code>伪类</h5><p><code>:nth-child(an+b)</code>伪类可以代表在文档树中在它之前的有<code>an+b-1</code>个兄弟的元素，<code>n</code>可以为任何的正数或0，且有一个父元素。对于大于0的<code>a</code>和<code>b</code>，这有效的将元素的孩子分成每组<code>a</code>个元素，然后选择每组中的第<code>b</code>个元素。例如，这使得选择器解决<code>table</code>中每隔一行的问题，并可以用于段落文本中每四个交替颜色。<code>a</code>和<code>b</code>的值必须为整数。元素的子元素的索引是从<code>1</code>开始（要注意不是<code>JavaScript</code>等语言的0哟）。</p>
<p>除此之外，<code>:nth-child()</code>还可以接受<code>odd</code>和<code>even</code>作为参数。<code>odd</code>其实等价于<code>2n+1</code>，<code>even</code>其实等价于<code>2n</code>。</p>
<p><code>:nth-child()</code>的参数必须匹配以下语法规则，<code>INTEGER</code>匹配<code>[0-9]+</code>，标记的其余部分是由<a href="http://www.w3.org/TR/css3-selectors/#lex" target="_blank" rel="external">Lexical scanner</a>给出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nth</span><br><span class="line">  : S* [ [<span class="string">'-'</span>|<span class="string">'+'</span>]? INTEGER? &#123;N&#125; [ S* [<span class="string">'-'</span>|<span class="string">'+'</span>] S* INTEGER ]? |</span><br><span class="line">         [<span class="string">'-'</span>|<span class="string">'+'</span>]? INTEGER | &#123;O&#125;&#123;D&#125;&#123;D&#125; | &#123;E&#125;&#123;V&#125;&#123;E&#125;&#123;N&#125; ] S*</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">tr</span>:<span class="value"><span class="function">nth-child</span>(<span class="number">2</span>n+<span class="number">1</span>) <span class="comment">/* represents every odd row of an HTML table */</span></span><br><span class="line">tr:<span class="function">nth-child</span>(odd)  <span class="comment">/* same */</span></span><br><span class="line">tr:<span class="function">nth-child</span>(<span class="number">2</span>n+<span class="number">0</span>) <span class="comment">/* represents every even row of an HTML table */</span></span><br><span class="line">tr:<span class="function">nth-child</span>(even) <span class="comment">/* same */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Alternate paragraph colours in CSS */</span></span><br><span class="line">p:<span class="function">nth-child</span>(<span class="number">4</span>n+<span class="number">1</span>) &#123; color: navy</span></span>; &#125;</span><br><span class="line"><span class="rule"><span class="attribute">p</span>:<span class="value"><span class="function">nth-child</span>(<span class="number">4</span>n+<span class="number">2</span>) &#123; color: green</span></span>; &#125;</span><br><span class="line"><span class="rule"><span class="attribute">p</span>:<span class="value"><span class="function">nth-child</span>(<span class="number">4</span>n+<span class="number">3</span>) &#123; color: maroon</span></span>; &#125;</span><br><span class="line"><span class="rule"><span class="attribute">p</span>:<span class="value"><span class="function">nth-child</span>(<span class="number">4</span>n+<span class="number">4</span>) &#123; color: purple</span></span>; &#125;</span><br></pre></td></tr></table></figure>
<p>当<code>b</code>的值前面有一个负号，则<code>+</code>字符必须从表达式中移除。</p>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="pseudo">:nth-child(10n-1)</span>  <span class="comment">/* represents the 9th, 19th, 29th, etc, element */</span></span><br><span class="line"><span class="pseudo">:nth-child(10n+9)</span>  <span class="comment">/* Same */</span></span><br><span class="line"><span class="pseudo">:nth-child(10n+-1)</span> <span class="comment">/* Syntactically invalid, and would be ignored */</span></span><br></pre></td></tr></table></figure>
<p>当<code>a=0</code>，则<code>an</code>部分可以不包含。当<code>an</code>未包含且<code>b</code>为非负数，则在<code>b</code>前面的<code>+</code>字符也可省略。</p>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">foo</span>:<span class="value"><span class="function">nth-child</span>(<span class="number">0</span>n+<span class="number">5</span>)   <span class="comment">/* represents an element foo that is the 5th child</span><br><span class="line">                         of its parent element */</span></span><br><span class="line">foo:<span class="function">nth-child</span>(<span class="number">5</span>)      <span class="comment">/* same */</span></span></span></span><br></pre></td></tr></table></figure>
<p>当<code>a=1</code>或<code>a=-1</code>，数字可以从规则中省略。</p>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">bar</span>:<span class="value"><span class="function">nth-child</span>(<span class="number">1</span>n+<span class="number">0</span>)   <span class="comment">/* represents all bar elements, specificity (0,1,1) */</span></span><br><span class="line">bar:<span class="function">nth-child</span>(n+<span class="number">0</span>)    <span class="comment">/* same */</span></span><br><span class="line">bar:<span class="function">nth-child</span>(n)      <span class="comment">/* same */</span></span><br><span class="line">bar                   <span class="comment">/* same but lower specificity (0,0,1) */</span></span></span></span><br></pre></td></tr></table></figure>
<p>当<code>b=0</code>，则每一个第<code>a</code>个元素被选择。在这种情况，<code>+b</code>或<code>-b</code>部分可能省略，除非<code>a</code>部分已经被省略。</p>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">tr</span>:<span class="value"><span class="function">nth-child</span>(<span class="number">2</span>n+<span class="number">0</span>) <span class="comment">/* represents every even row of an HTML table */</span></span><br><span class="line">tr:<span class="function">nth-child</span>(<span class="number">2</span>n) <span class="comment">/* same */</span></span></span></span><br></pre></td></tr></table></figure>
<p>空白是允许出现在<code>(之后</code>或<code>)</code>之前，也可以出现在<code>+</code>或<code>-</code>任何一方以分割<code>an</code>和<code>b</code>部分，当它们都没有省略的时候。</p>
<p><strong>有效的实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="pseudo">:nth-child(</span> 3<span class="tag">n</span> + 1 )</span><br><span class="line"><span class="pseudo">:nth-child(</span> +3<span class="tag">n</span> <span class="tag">-</span> 2 )</span><br><span class="line"><span class="pseudo">:nth-child(</span> <span class="tag">-n</span>+ 6)</span><br><span class="line"><span class="pseudo">:nth-child(</span> +6 )</span><br></pre></td></tr></table></figure>
<p>下面是无效的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="pseudo">:nth-child(3</span> <span class="tag">n</span>)</span><br><span class="line"><span class="pseudo">:nth-child(+</span> 2<span class="tag">n</span>)</span><br><span class="line"><span class="pseudo">:nth-child(+</span> 2)</span><br></pre></td></tr></table></figure>
<p>当<code>a</code>和<code>b</code>都为0时，该伪类没有选择文档树中的任何元素。</p>
<p><code>a</code>的值可能为负数，但是只有在<code>an+b</code>的正数位置才可以被选择。</p>
<p><strong>实例：</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html|tr:nth-child(-n+6)  /* represents the 6 first rows of XHTML tables */</span><br></pre></td></tr></table></figure>
<h5 id="3-6-5-3_:nth-last-child()伪类">3.6.5.3 <code>:nth-last-child()</code>伪类</h5><p>其实这个伪类和前面的<code>:nth-child()</code>是很类似的，它只是从最后一个元素开始计算索引。<code>:nth-last-child(an+b)</code>伪类可以代表在文档树中在它之<code>后</code>的有<code>an+b-1</code>个兄弟的元素，<code>n</code>可以为任何的正数或0，且有一个父元素。这个可以参考上面的<code>:nth-child()</code>语法。它同样接受<code>odd</code>和<code>even</code>作为参数。</p>
<p>实例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">tr</span>:<span class="value"><span class="function">nth-last-child</span>(-n+<span class="number">2</span>)    <span class="comment">/* represents the two last rows of an HTML table */</span></span><br><span class="line"></span><br><span class="line">foo:<span class="function">nth-last-child</span>(odd)    <span class="comment">/* represents all odd foo elements in their parent element,</span><br><span class="line">                              counting from the last one */</span></span></span></span><br></pre></td></tr></table></figure>
<h5 id="3-6-5-4_:nth-of-type()伪类">3.6.5.4 <code>:nth-of-type()</code>伪类</h5><p>这个伪类其实可以看成对<code>:nth-child()</code>施加了一个限制，那就是元素类型必须相同。<code>:nth-of-type(an+b)</code>伪类可以代表在文档树中在它之前有<code>an+b-1</code>个兄弟，且<code>元素类型必须相同</code>的元素，<code>n</code>可以为任何的正数或0，且有一个父元素。这个可以参考上面的<code>:nth-child()</code>语法。它同样接受<code>odd</code>和<code>even</code>作为参数。</p>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">img</span>:<span class="value"><span class="function">nth-of-type</span>(<span class="number">2</span>n+<span class="number">1</span>) &#123; float: right</span></span>; &#125;</span><br><span class="line"><span class="rule"><span class="attribute">img</span>:<span class="value"><span class="function">nth-of-type</span>(<span class="number">2</span>n) &#123; float: left</span></span>; &#125;</span><br></pre></td></tr></table></figure>
<p>再看一个例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">/*#demo p:nth-of-type(even) &#123;</span><br><span class="line">	color: red;</span><br><span class="line">&#125;*/</span><br><span class="line">#demo :nth-child(even) &#123;</span><br><span class="line">	color: blue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id="demo"&gt;</span><br><span class="line">	&lt;p&gt;1&lt;/p&gt;</span><br><span class="line">	&lt;p&gt;2&lt;/p&gt;</span><br><span class="line">	&lt;p&gt;3&lt;/p&gt;</span><br><span class="line">	&lt;a href=""&gt;4&lt;/a&gt;</span><br><span class="line">	&lt;p&gt;5&lt;/p&gt;</span><br><span class="line">	&lt;p&gt;6&lt;/p&gt;</span><br><span class="line">	&lt;p&gt;7&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>你可以在浏览器中对比以下这两个选择器的效果哟。</p>
<h5 id="3-6-5-5_:nth-last-of-type()伪类">3.6.5.5 <code>:nth-last-of-type()</code>伪类</h5><p>这个伪类和<code>:nth-of-type()</code>，只是从最后一个元素开始计算索引啦。<code>:nth-last-of-type(an+b)</code>伪类可以代表在文档树中在它之<code>后</code>有<code>an+b-1</code>个兄弟，且<code>元素类型必须相同</code>的元素，<code>n</code>可以为任何的正数或0，且有一个父元素。这个可以参考上面的<code>:nth-child()</code>语法。它同样接受<code>odd</code>和<code>even</code>作为参数。</p>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">body</span> &gt; <span class="tag">h2</span><span class="pseudo">:nth-of-type(n+2)</span><span class="pseudo">:nth-last-of-type(n+2)</span></span><br></pre></td></tr></table></figure>
<h5 id="3-6-5-6_:first-child伪类">3.6.5.6 <code>:first-child</code>伪类</h5><p>和<code>:nth-child(1)</code>相同。<code>:first-child</code>伪类代表一个元素为其他元素的第一个子元素。</p>
<p>实例：</p>
<p>下面的例子代表了一个<code>p</code>元素是<code>div</code>中的第一个元素。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span> &gt; <span class="rule"><span class="attribute">p</span>:<span class="value">first-child</span></span></span><br></pre></td></tr></table></figure>
<p>选择器可以匹配下面HTML中<code>div</code>中的<code>p</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span> The last P before the note.<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"note"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">p</span>&gt;</span> The first P inside the note.<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是不能匹配下面<code>div</code>中<code>p</code>元素，因为<code>p</code>不是<code>div</code>中的第一个子元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span> The last P before the note.<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"note"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">h2</span>&gt;</span> Note <span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">p</span>&gt;</span> The first P inside the note.<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="3-6-5-7_:last-child伪类">3.6.5.7 <code>:last-child</code>伪类</h5><p>和<code>:nth-last-child(1)</code>相同。<code>:last-child</code>伪类代表一个元素为其他元素的最后一个子元素。</p>
<p>实例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">ol</span> &gt; <span class="rule"><span class="attribute">li</span>:<span class="value">last-child</span></span></span><br></pre></td></tr></table></figure>
<h5 id="3-6-5-8_:first-of-type伪类">3.6.5.8 <code>:first-of-type</code>伪类</h5><p>和<code>:nth-of-type(1)</code>相同。<code>:first-of-type</code>伪类代表一个元素，它是父元素中第一个具有相同元素名的元素。</p>
<p>实例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dl dt:first-of-type &#123;</span><br><span class="line">	color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;dl&gt;</span><br><span class="line"> &lt;dt&gt;gigogne&lt;/dt&gt;</span><br><span class="line"> &lt;dd&gt;</span><br><span class="line">  &lt;dl&gt;</span><br><span class="line">   &lt;dt&gt;fusée&lt;/dt&gt;</span><br><span class="line">   &lt;dd&gt;multistage rocket&lt;/dd&gt;</span><br><span class="line">   &lt;dt&gt;table&lt;/dt&gt;</span><br><span class="line">   &lt;dd&gt;nest of tables&lt;/dd&gt;</span><br><span class="line">  &lt;/dl&gt;</span><br><span class="line"> &lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure>
<h5 id="3-6-5-9_:last-of-type伪类">3.6.5.9 <code>:last-of-type</code>伪类</h5><p>和<code>:nth-last-of-type(1)</code>相同。<code>:last-of-type</code>伪类代表一个元素，它是父元素中最后一个具有相同元素名的元素。</p>
<p>实例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">tr</span> &gt; <span class="rule"><span class="attribute">td</span>:<span class="value">last-of-type</span></span></span><br></pre></td></tr></table></figure>
<h5 id="3-6-5-10_:only-child伪类">3.6.5.10 <code>:only-child</code>伪类</h5><p>该伪类代表了一个元素，它的父元素除了它没有其他元素。其实等价于<code>:first-child:last-child</code>。</p>
<h5 id="3-6-5-11_:only-of-type伪类">3.6.5.11 <code>:only-of-type</code>伪类</h5><p>该伪类代表了一个元素，它的父元素除了它没有其他元素，且和指定的元素类型相同。等价于<code>:first-of-type:last-of-type</code>。</p>
<h5 id="3-6-5-12_:empty伪类">3.6.5.12 <code>:empty</code>伪类</h5><p><code>:empty</code>伪类代表了一个元素始终没有子元素。</p>
<p><strong>实例：</strong></p>
<p><code>p:empty</code>可以代表以下<code>html</code>片段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而<code>foo:empty</code>不能代表以下片段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">foo</span>&gt;</span>bar<span class="tag">&lt;/<span class="title">foo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">foo</span>&gt;</span><span class="tag">&lt;<span class="title">bar</span>&gt;</span>bla<span class="tag">&lt;/<span class="title">bar</span>&gt;</span><span class="tag">&lt;/<span class="title">foo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">foo</span>&gt;</span>this is not <span class="tag">&lt;<span class="title">bar</span>&gt;</span>:empty<span class="tag">&lt;/<span class="title">bar</span>&gt;</span><span class="tag">&lt;/<span class="title">foo</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-6-6_空白">3.6.6 空白</h4><p>本节有意留为空白。（本节之前定义了一个<code>:contains()</code>伪类）</p>
<h4 id="3-6-7_否定伪类">3.6.7 否定伪类</h4><p>否定伪类，<code>:not(x)</code>是一个功能性的符号，它接受一个简单选择器作为参数。它代表了这些不是参数所代表的元素。</p>
<p>否定不能嵌套，<code>:not(:not(...))</code>是无效的。要注意当伪元素不是简单选择器，所以它们不是<code>:not()</code>的有效参数。</p>
<p><strong>实例：</strong></p>
<p>以下选择器匹配在HTML中没有被禁用的按钮：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">button</span>:<span class="value"><span class="function">not</span>([DISABLED])</span></span></span><br></pre></td></tr></table></figure>
<p>默认的命名空间声明不会影响否定伪类的参数，除非该参数是一个通用选择器或类型选择器。</p>
<p><strong>实例：</strong></p>
<p>假设默认的命名空间为<code>http://example.com/</code>，下面的选择器代表了所有不在该命名空间的元素：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*|*:not(*)</span><br></pre></td></tr></table></figure>
<h2 id="4-_伪元素">4. 伪元素</h2><p>在文档语言规定之外，伪元素创建了一个关于文档树的抽象引用。例如，文档语言不提供机制来访问的一个元素的内容的第一个字母或第一行。伪元素允许作者引用这个本来无法访问的信息。伪元素还能提供作者一种方式去引用源文档中不存在的内容（<code>::before</code>和<code>::after</code>）。</p>
<p>一个伪元素是由<code>::</code>跟着伪元素名称组成的。</p>
<p><code>::</code>符号在文档中被引入是为了在伪类和伪元素之间建立一个区别。为了与现有的样式表的兼容性，用户代理必须同样接受一个冒号<code>:</code>的写法。</p>
<h3 id="4-1_::first-line伪元素">4.1 <code>::first-line</code>伪元素</h3><p><code>::first-line</code>伪元素描述了元素的内容中被格式化的第一行。</p>
<p><strong>CSS实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">p</span>:<span class="value">:first-line &#123; text-transform: uppercase &#125;</span></span></span><br></pre></td></tr></table></figure>
<p>上面的规则意思为将每个<code>p</code>元素的第一行的每个字母变为大写。</p>
<p>注意，第一行的长度取决于许多因素，包括该页面的宽度，字体大小等。因此，一个普通的HTML段落，如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">P</span>&gt;</span>This is a somewhat long HTML </span><br><span class="line">paragraph that will be broken into several </span><br><span class="line">lines. The first line will be identified</span><br><span class="line">by a fictional tag sequence. The other lines </span><br><span class="line">will be treated as ordinary lines in the </span><br><span class="line">paragraph.<span class="tag">&lt;/<span class="title">P</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中折行如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">THIS IS A SOMEWHAT LONG HTML PARAGRAPH THAT</span><br><span class="line">will be broken into several lines. The first</span><br><span class="line">line will be identified by a fictional tag </span><br><span class="line">sequence. The other lines will be treated as </span><br><span class="line">ordinary lines in the paragraph.</span><br></pre></td></tr></table></figure>
<p>该段落可能可能被用户代理<code>重写</code>，包括虚构的标签<code>::first-line</code>。这个虚构的标签序列有助于说明属性如何继承。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">P</span>&gt;</span><span class="tag">&lt;<span class="title">P::first-line</span>&gt;</span> This is a somewhat long HTML </span><br><span class="line">paragraph that <span class="tag">&lt;/<span class="title">P::first-line</span>&gt;</span> will be broken into several</span><br><span class="line">lines. The first line will be identified </span><br><span class="line">by a fictional tag sequence. The other lines </span><br><span class="line">will be treated as ordinary lines in the </span><br><span class="line">paragraph.<span class="tag">&lt;/<span class="title">P</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果伪元素折断了一个真实的元素，所需的效果通常被描述为一个虚构的标签序列关闭，然后重新打开该元素。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">P</span>&gt;</span><span class="tag">&lt;<span class="title">SPAN</span> <span class="attribute">class</span>=<span class="value">"test"</span>&gt;</span> This is a somewhat long HTML</span><br><span class="line">paragraph that will be broken into several</span><br><span class="line">lines.<span class="tag">&lt;/<span class="title">SPAN</span>&gt;</span> The first line will be identified</span><br><span class="line">by a fictional tag sequence. The other lines </span><br><span class="line">will be treated as ordinary lines in the </span><br><span class="line">paragraph.<span class="tag">&lt;/<span class="title">P</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>用户代理会像下面这样处理：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">P</span>&gt;</span><span class="tag">&lt;<span class="title">P::first-line</span>&gt;</span><span class="tag">&lt;<span class="title">SPAN</span> <span class="attribute">class</span>=<span class="value">"test"</span>&gt;</span> This is a</span><br><span class="line">somewhat long HTML</span><br><span class="line">paragraph that will <span class="tag">&lt;/<span class="title">SPAN</span>&gt;</span><span class="tag">&lt;/<span class="title">P::first-line</span>&gt;</span><span class="tag">&lt;<span class="title">SPAN</span> <span class="attribute">class</span>=<span class="value">"test"</span>&gt;</span> be</span><br><span class="line">broken into several</span><br><span class="line">lines.<span class="tag">&lt;/<span class="title">SPAN</span>&gt;</span> The first line will be identified</span><br><span class="line">by a fictional tag sequence. The other lines</span><br><span class="line">will be treated as ordinary lines in the </span><br><span class="line">paragraph.<span class="tag">&lt;/<span class="title">P</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="4-1-1_CSS中格式化的第一行的定义">4.1.1 CSS中格式化的第一行的定义</h4><p>在CSS中，<code>::first-line</code>伪元素只能在<code>block-like</code>容器上有效果，这些容器有<code>block box</code>，<code>inline-block</code>，<code>table-caption</code>和<code>table-cell</code>。</p>
<p>一个元素的格式化第一行可能发生在相同流的一个<code>block-level</code>后代中（例如，一个<code>block-level</code>后代没有脱离流）。例如，在<code>&lt;DIV&gt;&lt;P&gt;This line...&lt;/P&gt;&lt;/DIV&gt;</code>中<code>DIV</code>的第一行为<code>p</code>元素的第一行。</p>
<p><code>table-cell</code>和<code>inline-block</code>的第一行不能成为一个祖先元素的格式化的第一行。因此，在<code>&lt;DIV&gt;&lt;P STYLE=&quot;display: inline-block&quot;&gt;Hello&lt;BR&gt;Goodbye&lt;/P&gt; etcetera&lt;/DIV&gt;</code>中，<code>DIV</code>的格式化第一行不是<code>Hello</code>的那一行。</p>
<p>一个用户代理应当表现的就好像<code>::first-line</code>的虚拟开始标签伪元素被嵌套到最内层的<code>block-level</code>元素中。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">DIV</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">P</span>&gt;</span>First paragraph<span class="tag">&lt;/<span class="title">P</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">P</span>&gt;</span>Second paragraph<span class="tag">&lt;/<span class="title">P</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">DIV</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>加上虚拟标签后：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">DIV</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">P</span>&gt;</span><span class="tag">&lt;<span class="title">DIV::first-line</span>&gt;</span><span class="tag">&lt;<span class="title">P::first-line</span>&gt;</span>First paragraph<span class="tag">&lt;/<span class="title">P::first-line</span>&gt;</span><span class="tag">&lt;/<span class="title">DIV::first-line</span>&gt;</span><span class="tag">&lt;/<span class="title">P</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">P</span>&gt;</span><span class="tag">&lt;<span class="title">P::first-line</span>&gt;</span>Second paragraph<span class="tag">&lt;/<span class="title">P::first-line</span>&gt;</span><span class="tag">&lt;/<span class="title">P</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">DIV</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>::first-line</code>伪元素类似于一个<code>inline-level</code>元素，但有一定的限制。以下CSS属性应用到一个<code>::first-line</code>伪元素：字体属性、背景属性、颜色属性、<code>word-spacing</code>，<code>letter-spacing</code>，<code>text-decoration</code>，<code>vertical-align</code>，<code>text-transform</code>，<code>line-height</code>。用户代理也可能应用其他属性。</p>
<p>在CSS继承时，发生在第一行的子元素的一部分只从<code>::first-line</code>伪元素继承<code>::first-line</code>上可应用的属性。对于所有的其他属性，继承时从第一行伪元素的非鱼伪元素父元素中继承。</p>
<h3 id="4-2_::first-letter伪元素">4.2 <code>::first-letter</code>伪元素</h3><p><code>::first-letter</code>代表了一个元素的第一个字母，如果在该行中在它前面没有任何其他内容。<code>::first-letter</code>伪元素可能被用于<code>首字母大写</code>等用途。</p>
<p>标点符号，即第一个字母前面或后面也应包括在内。</p>
<p><img src="http://www.w3.org/TR/css3-selectors/first-letter2.png" alt="enter image description here"></p>
<p>当第一个字母为数字时，<code>::first-line</code>也同样被应用，例如，在<code>67 million dollars is a lot of money.</code>中的<code>6</code>。</p>
<h4 id="4-2-1_在CSS中的应用">4.2.1 在CSS中的应用</h4><p>在CSS中，<code>::first-letter</code>伪元素只能在<code>block-like</code>容器上有效果，这些容器有<code>block</code>，<code>list-item</code>，<code>inline-block</code>，<code>table-caption</code>和<code>table-cell</code>。</p>
<p><code>::first-letter</code>伪元素可和所有这些包含文本的元素或有一个后代包含文本且在相同的流的元素使用。用户代理也应该表现为好像虚拟的标签被加上。</p>
<p><strong>实例：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>The first text.</span><br></pre></td></tr></table></figure>
<p>表现为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">div::first-letter</span>&gt;</span><span class="tag">&lt;<span class="title">p::first-letter</span>&gt;</span>T<span class="tag">&lt;/<span class="title">...</span>&gt;</span><span class="tag">&lt;/<span class="title">...</span>&gt;</span>he first text.</span><br></pre></td></tr></table></figure>
<p><code>table-cell</code>和<code>inline-block</code>的第一个字母不能成为一个祖先元素的的第一字母。因此，在<code>&lt;DIV&gt;&lt;P STYLE=&quot;display: inline-block&quot;&gt;Hello&lt;BR&gt;Goodbye&lt;/P&gt; etcetera&lt;/DIV&gt;</code>中，<code>DIV</code>的第一字母不是<code>H</code>。实际上，<code>DIV</code>没有第一个字母。</p>
<p>如果元素是一个<code>list item</code>，<code>::first-letter</code>应用在主体框标记后的第一个字母。如果<code>list item</code>设置了<code>list-style-position: inside</code>，用户代理将忽略该列表项的<code>::first-letter</code>。如果一个元素有<code>::before</code>和<code>::after</code>内容，<code>::first-letter</code>应用的时候包含了<code>::before</code>和<code>::after</code>的内容。</p>
<p><strong>实例：</strong></p>
<p>例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">p</span>:<span class="value">:before &#123;content: <span class="string">"Note: "</span>&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><code>p::first-letter</code>匹配<code>Note</code>中的<code>N</code>。</p>
<p>在CSS中，<code>::first-letter</code>伪元素类似于一个<code>inline-level</code>元素，如果该元素的<code>float</code>为<code>none</code>；否则，它和浮动元素相同。</p>
<h3 id="4-3_空白">4.3 空白</h3><p>这里是故意留白的。（之前定义了<code>::selection</code>伪元素）</p>
<h3 id="4-4_::before和::after伪元素">4.4 <code>::before</code>和<code>::after</code>伪元素</h3><p>这两个伪元素在<a href="http://www.w3.org/TR/css3-selectors/#CSS21" target="_blank" rel="external">CSS21</a>中定义。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/CSS/">CSS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/selector/">selector</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/02/05/css-selectors/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/02/05/css-selectors/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/21/css3-animation/" title="CSS3 Animation" itemprop="url">CSS3 Animation</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-01-21T05:47:42.000Z" itemprop="datePublished"> 發表於 2015-01-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文是<a href="http://www.w3.org/TR/web-animations/" target="_blank" rel="external">Web Animations 1.0</a>的学习和翻译，如有翻译不好的可以看看原文哟。</p>
<h2 id="1_介绍">1 介绍</h2><p><code>CSS</code>的<a href="http://www.w3.org/TR/css3-animations/#CSS3-TRANSITIONS" target="_blank" rel="external">transition</a>提供了一种在它们基本属性改变时插入<code>CSS</code>属性值的方式。这提供了一种简单的方法来实现一些简单的动画，但动画的开始和结束状态是由现有的属性值来控制，<code>transition</code>在动画如何进行上给作者提供了很少的控制。</p>
<p>该提案中介绍了定义动画，其中作者可以使用<code>keyframe</code>来指定<code>CSS</code>属性随着时间的变化。<code>Animation</code>类似于<code>transition</code>，因为它们随时间改变CSS属性的表象值（presentational value）。主要的区别是，<code>transition</code>是当属性值改变时触发，<code>animation</code>是在<code>animation</code>属性被应用后明确的执行。正因为如此，<code>animations</code>对于正在被动画的属性需要明确的值。这些值是使用动画关键帧（keyframes）来指定的，将在下面描述。</p>
<p>动画的许多方面可以被控制，包括多少次动画迭代，是否交替开始和结束之间的值，动画是否应该运行还是暂停。动画同样可以延迟它的开始时间。</p>
<h2 id="2_取值">2 取值</h2><p>该规范遵循<a href="http://www.w3.org/TR/css3-animations/#CSS21" target="_blank" rel="external">CSS21</a>中的<a href="http://www.w3.org/TR/CSS21/about.html#property-defs" target="_blank" rel="external">CSS属性定义约定</a>。在该规范中没有定义的值的类型被定义在<code>CSS Level 2 Revision 1</code><a href="http://www.w3.org/TR/css3-animations/#CSS21" target="_blank" rel="external">[CSS21]</a>。其他CSS模块可能扩展这些值类型的定义：例如<a href="http://www.w3.org/TR/css3-animations/#CSS3VAL" target="_blank" rel="external">[CSS3VAL)]</a>，当与该模块结合时，扩展<code>&lt;length&gt;</code>值类型的定义将在本规范中使用。</p>
<p>除了在它们的定义中列出的属性的特定值，在该规范中定义的所有属性也接受了<a href="http://dev.w3.org/csswg/css3-values/#common-keywords" target="_blank" rel="external">initial</a>和<a href="http://www.w3.org/TR/CSS21/cascade.html#value-def-inherit" target="_blank" rel="external">inherit</a>关键字作为他们的属性值。因为可读性原因，并未明确重复。</p>
<h2 id="3_动画">3 动画</h2><p><code>CSS</code>动画影响属性的计算值。在动画的执行期间，对于属性的计算值是由动画控制。这将会覆盖在正常样式系统中指定的值。动画覆盖所有一般规则，但会被<code>!important</code>规则所覆盖。</p>
<p>如果在一个时间点有多个动画为同一个属性指定了行为，则该动画名出现在<a href="http://www.w3.org/TR/css3-animations/#animation-name" target="_blank" rel="external">animation-name</a>值的最后一个会覆盖其他动画。</p>
<p>一个动画在动画应用程序之前、动画延迟到期前和动画结束后不会影响计算值。</p>
<center><br><img src="http://www.w3.org/TR/css3-animations/sandwich.png" alt="enter image description here"><br></center>

<center><br>图片1：动画属性值的计算<br></center>

<p>上图显示了属性值如何计算。本身的样式显示在图的顶部，当动画没有运行和动画被延迟时，计算值是从本身样式衍生而来。在动画运行期间，计算样式是由动画值衍生而来。</p>
<p>动画的开始时间是后面的两个时刻：样式被解析出指定了动画的时间，或文档的<code>load</code>事件被触发。因此，在文档的样式表中指定的动画是在文档加载后开始。通过修改元素样式的指定动画会在文档被加载后且该样式被解析后开始。这可能在伪元素样式规则下立即执行，例如<code>hover</code>，或者是脚本引擎将控制返回给浏览器。</p>
<p>当元素有一个<a href="http://www.w3.org/TR/css3-animations/#animation-name" target="_blank" rel="external">animation-name</a>的值引用了一个有效的<code>keyframes</code>规则时，动画才会应用到元素上。一旦动画开始，它会继续直到结束，或者<a href="http://www.w3.org/TR/css3-animations/#animation-name" target="_blank" rel="external">animation-name</a>被移除。用于关键帧和动画属性的值当动画开始时被快照。在动画执行期间改变它们是没有效果的。另外要注意，改变<a href="http://www.w3.org/TR/css3-animations/#animation-name" target="_blank" rel="external">animation-name</a>的值并不一定会重新启动动画（例如：如果一个动画列表被应用，且其中一个从列表中移除，只有那个动画会暂停，其他动画会继续运行）。为了重新启动动画，它必须被移除，然后重新应用。</p>
<p>动画的结束是由<a href="http://www.w3.org/TR/css3-animations/#animation-duration" target="_blank" rel="external">animation-duration</a>、<a href="http://www.w3.org/TR/css3-animations/#animation-iteration-count" target="_blank" rel="external">animation-iteration-count</a>和<a href="http://www.w3.org/TR/css3-animations/#animation-fill-mode" target="_blank" rel="external">animatioin-fill-mode</a>属性结合一起定义的。</p>
<p><strong>实例1：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">animation-name</span>:<span class="value"> diagonal-slide</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">animation-duration</span>:<span class="value"> <span class="number">5s</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">animation-iteration-count</span>:<span class="value"> <span class="number">10</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="at_rule">@<span class="keyword">keyframes</span> diagonal-slide </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="tag">from</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">to</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上会产生用五秒将元素<code>(0, 0)</code>移动到<code>(100px, 100px)</code>，并且重复十次。</p>
<p>当设置<code>display</code>属性为<code>none</code>时，会终止任何被应用在元素和它后代的运行中的动画。如果元素的<code>diaplay</code>为<code>none</code>，当更新它的<code>display</code>值不为<code>none</code>的任何值时所有通过<a href="http://www.w3.org/TR/css3-animations/#animation-name" target="_blank" rel="external">animation-name</a>运用到元素的动画会开始运行，也同样包括它后代的<code>display</code>不为<code>none</code>的动画。</p>
<p>虽然作者可以使用动画来创建动态变化的内容，动态变化的内容可以导致在某些用户癫痫。有关如何避免内容导致癫痫发作的信息，可以看<a href="http://www.w3.org/TR/WCAG20/#seizure" target="_blank" rel="external">Guideline 2.3: Seizures: Do not design content in a way that is known to cause seizures</a></p>
<h2 id="4_关键帧（keyframes）">4 关键帧（keyframes）</h2><p>关键帧被用于在动画过程中指定用于在各个点的动画属性的值。关键帧指定了动画的一个周期的行为，动画可以迭代一次或多次。</p>
<p>关键帧是使用专门的<code>CSS</code>的<code>@</code>规则来指定。一个<code>@keyframes</code>规则包含了关键字<code>@keyframes</code>，然后跟着标识符给出动画的名称（它会被<a href="http://www.w3.org/TR/css3-animations/#animation-name" target="_blank" rel="external">animation-name</a>引用到），最后是一组样式规则（由大括号分隔）。</p>
<p>对于关键帧样式规则的<strong>关键帧选择器（keyframe selector）</strong>包含了由逗号分隔的百分比值列表或关键字<code>from</code>或<code>to</code>。选择器用于指定沿该关键帧代表的该动画的持续时间的百分比。关键帧本身是通过在选择器声明的属性值块中指定。关键字<code>from</code>等价于<code>0%</code>，关键字<code>to</code>等价于<code>100%</code>。</p>
<p>如果<code>0%</code>或<code>from</code>没有被指定，那么用户代理会使用将要动画的属性的计算值构造一个<code>0%</code>的关键帧。如果<code>100%</code>或<code>to</code>没有被指定，那么用户代理会使用将要动画的属性的计算值构造一个<code>100%</code>的关键帧。如果关键帧选择器指定了一个负的或者是大于<code>100%</code>百分比值，该关键帧将被忽略。</p>
<p>一个关键帧规则的<strong>关键帧声明块（keyframe declaration block）</strong>包含属性和值，那些不能动画的属性将在规则中被忽略，除了<a href="http://www.w3.org/TR/css3-animations/#animation-timing-function" target="_blank" rel="external">animation-timing-function</a>之外，该属性的行为将在下面说明。此外，关键帧规则声明中想具有<code>!important</code>资格将被忽略（没有!important优先级）。</p>
<p>动画所使用的<code>@keyframes</code>规则将是在被排序后的规则顺序中最后一个遇到的，且匹配在<a href="http://www.w3.org/TR/css3-animations/#animation-name" target="_blank" rel="external">animation-name</a>引用到）属性中指定的动画名称 。<code>@keyframes</code>规则不会层叠；因此，一个动画永远不会从多个<code>@keyframes</code>规则中获得关键帧。</p>
<p>为了确定该组的关键帧，所有的选择器的值按时间递增顺序排序。如果有任何重复，那么<code>@keyframes</code>规则内指定的最后一个关键帧将被用于提供那时关键帧的信息。如果有多个关键帧指定了相同的关键帧选择器值时，在<code>@keyframes</code>规则中不会重叠。</p>
<p>如果一个属性不是为关键帧指定，或者它的指定是无效的，动画的那个属性进行就好像那个关键帧不存在一样。概念上，就好像构造一组关键帧的每个属性存在于任何关键帧，且动画是为每个属性独立运行的。</p>
<p><strong>实例2：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">keyframes</span> wobble </span>&#123;</span><br><span class="line">  0% <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><br><span class="line">  40% <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">150px</span></span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><br><span class="line">  60% <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">75px</span></span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><br><span class="line">  100% <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四个关键帧在动画名为<code>wobble</code>的动画中指定。在第一个关键帧中，显示了动画周期的开始，<code>left</code>属性的值被动画到<code>100px</code>。在<code>40%</code>时，<code>left</code>为<code>150px</code>。以此类推。下面的图展示了动画的状态，如果动画持续时间被指定为10s的话。</p>
<p><ceter><br><img src="http://www.w3.org/TR/css3-animations/animation1.png" alt="enter image description here"><br></ceter></p>
<p>下面是关键帧规则的语法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">keyframes_rule: KEYFRAMES_SYM S+ IDENT S* <span class="string">'&#123;'</span> S* keyframes_blocks <span class="string">'&#125;'</span> S*;</span><br><span class="line"></span><br><span class="line">keyframes_blocks: [ keyframe_selector <span class="string">'&#123;'</span> S* declaration? [ <span class="string">';'</span> S* declaration? ]* <span class="string">'&#125;'</span> S* ]* ;</span><br><span class="line"></span><br><span class="line">keyframe_selector: [ FROM_SYM | TO_SYM | PERCENTAGE ] S* [ <span class="string">','</span> S* [ FROM_SYM | TO_SYM | PERCENTAGE ] S* ]*;</span><br><span class="line"></span><br><span class="line">@&#123;K&#125;&#123;E&#125;&#123;Y&#125;&#123;F&#125;&#123;R&#125;&#123;A&#125;&#123;M&#125;&#123;E&#125;&#123;S&#125;   &#123;<span class="keyword">return</span> KEYFRAMES_SYM;&#125;</span><br><span class="line">&#123;F&#125;&#123;R&#125;&#123;O&#125;&#123;M&#125;                   &#123;<span class="keyword">return</span> FROM_SYM;&#125;</span><br><span class="line">&#123;T&#125;&#123;O&#125;                         &#123;<span class="keyword">return</span> TO_SYM;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1_关键帧的缓动函数">4.1 关键帧的缓动函数</h3><p>关键帧样式同样可以定义缓动函数，这个缓动函数将用于动画从这个帧运行到下个帧。</p>
<p><strong>实例3：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">keyframes</span> bounce </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="tag">from</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">animation-timing-function</span>:<span class="value"> ease-out</span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><br><span class="line">  25% <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">50px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">animation-timing-function</span>:<span class="value"> ease-in</span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><br><span class="line">  50% <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">animation-timing-function</span>:<span class="value"> ease-out</span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><br><span class="line">  75% <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">75px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">animation-timing-function</span>:<span class="value"> ease-in</span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">to</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动画名为<code>bounce</code>的动画指定了五个关键帧。在第一个关键帧到第二个关键帧之间使用的缓动函数为<code>ease-out</code>（也即0%到25%），25%到50%之间使用的缓动函数为<code>ease-in</code>，以此类推了。</p>
<p>在<code>100%</code>或<code>to</code>上指定的缓动函数将被忽略。</p>
<h3 id="4-2_animation-name属性">4.2 <code>animation-name</code>属性</h3><p><code>animation-name</code>属性定义了应用的动画列表。每一个名字被用于选择关键帧规则，以提供该动画的属性值。如果该名字没有匹配任何关键帧<code>@</code>规则，没有属性进行动画且动画将不会执行（这里指的是该名字指定的动画，而不是说整个动画不会执行）。此外，如果动画名称为<code>none</code>，那么将不会有动画。这可以用于覆盖层叠而来的任何动画。如果多个动画尝试修改同一个属性，那么靠近列表的最后的动画会胜出。</p>
<p>对于下面列出的其他动画属性的值，按名称列出的每个动画应该有相应的值（简单点说，比如我定义了animation-name: aa bb; 在animation-duration中应该有相应的值，例如animation-name: 2s 4s;或者其他）。如果对于其他动画属性值的列表不具有相同的长度，<code>animation-name</code>列表的长度决定了启动动画时检查每个列表项的数量。列表是从第一个值开始匹配：不使用尾部剩余的值。如果其他属性中的一个没有足够的逗号分隔的值去匹配<code>animation-name</code>属性值的数量时，用户代理必须通过列表中的值计算，直到有足够的值。这些截断和重复不影响属性的计算值。</p>
<ul>
<li>名称：<code>animation-name</code></li>
<li>取值：<code>&lt;single-animation-name&gt; [ ‘,’ &lt;single-animation-name&gt; ]*</code></li>
<li>初始值：<code>none</code></li>
<li>应用于：所有元素，<code>::before</code>和<code>::after</code>伪元素</li>
<li>继承：无</li>
<li>可否动画：否</li>
<li>百分比：<code>N/A</code></li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<p>其中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;single-animation-name&gt; = none | &lt;IDENT&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-3_animation-duration属性">4.3 <code>animation-duration</code>属性</h3><p><code>animation-duration</code>属性一个动画完成一个周期的时间。</p>
<ul>
<li>名称：<code>animation-duration</code></li>
<li>取值：<code>&lt;time&gt; [, &lt;time&gt;]*</code></li>
<li>初始值：<code>0s</code></li>
<li>应用于：所有元素，<code>::before</code>和<code>::after</code>伪元素</li>
<li>继承：无</li>
<li>可否动画：否</li>
<li>百分比：<code>N/A</code></li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<p>初始值为<code>0s</code>，这意味着动画不花时间。当持续时间为<code>0s</code>时，<code>animation-fill-mode</code>仍然会被应用，所以一个动画填充为<code>backwards</code>将在一个延迟时间（如果有的话）后显示<code>0%</code>的关键帧，填充为<code>forwards</code>的将显示<code>100%</code>的关键帧，即使动画是瞬时的。同样，动画事件也会被触发。一个负的<code>animation-duration</code>值将导致该声明无效。</p>
<h3 id="4-4_animation-timing-function属性">4.4 <code>animation-timing-function</code>属性</h3><p><code>animation-timing-function</code>属性描述了动画在一个周期内如何进展。更多关于缓动函数：<a href="http://www.w3.org/TR/css3-animations/#CSS3-TRANSITIONS" target="_blank" rel="external">http://www.w3.org/TR/css3-animations/#CSS3-TRANSITIONS</a></p>
<ul>
<li>名称：<code>animation-timing-function</code></li>
<li>取值：<code>&lt;single-timing-function&gt; [ ‘,’ &lt;single-timing-function&gt; ]*</code></li>
<li>初始值：<code>ease</code></li>
<li>应用于：所有元素，<code>::before</code>和<code>::after</code>伪元素</li>
<li>继承：无</li>
<li>可否动画：否</li>
<li>百分比：<code>N/A</code></li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<h3 id="4-5_animation-iteration-count属性">4.5 <code>animation-iteration-count</code>属性</h3><p>这个属性看名字就能看出来了，它定义动画运行周期的次数。初始值为<code>1</code>，意味着动画会从开始到结束运行一次。一个<code>infinite</code>值将会使动画运行无限次。非整数的值将会导致动画运行到一个循环的一部分结束。<code>animation-iteration-count</code>属性值为负值时是无效的。这个属性通常结合<code>animation-direction</code>属性值的<code>alternate</code>使用，这会导致动画交替运行。</p>
<ul>
<li>名称：<code>animation-iteration-count</code></li>
<li>取值：<code>&lt;single-animation-iteration-count&gt; [ ‘,’ &lt;single-animation-iteration-count&gt; ]*</code></li>
<li>初始值：1</li>
<li>应用于：所有元素，<code>::before</code>和<code>::after</code>伪元素</li>
<li>继承：无</li>
<li>可否动画：否</li>
<li>百分比：<code>N/A</code></li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<p>其中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;single-animation-iteration-count&gt; = infinite | &lt;number&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-6_animation-direction属性">4.6 <code>animation-direction</code>属性</h3><p><code>animation-direction</code>属性定义了动画运行的方向。当一个动画运行是<code>reverse</code>（倒着运行）时，缓动函数也将是相反的。例如，当指定的缓动函数为<code>ease-in</code>，倒着运行时缓动函数为<code>ease-out</code>。</p>
<ul>
<li>名称：<code>animation-direction</code></li>
<li>取值：<code>&lt;single-animation-direction&gt; [ ‘,’ &lt;single-animation-direction&gt; ]*</code></li>
<li>初始值：<code>normal</code></li>
<li>应用于：所有元素，<code>::before</code>和<code>::after</code>伪元素</li>
<li>继承：无</li>
<li>可否动画：否</li>
<li>百分比：<code>N/A</code></li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<p>其中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;single-animation-direction&gt; = normal | reverse | alternate | alternate-reverse</span><br></pre></td></tr></table></figure>
<p>属性值的意义：</p>
<p><strong>normal</strong><br>动画的所有迭代按着指定的运行</p>
<p><strong>reverse</strong><br>动画的所有迭代按着定义的相反方向来运行</p>
<p><strong>alternate</strong><br>动画周期在奇数次按着<code>normal</code>方向运行，偶数次按着<code>reverse</code>方向运行。也就是交替运行</p>
<p><strong>alternate-reverse</strong><br>这个和<code>alternate</code>相反。奇数次按着<code>reverse</code>方向运行，偶数次按着<code>normal</code>方向运行</p>
<h3 id="4-7_animation-play-state属性">4.7 <code>animation-play-state</code>属性</h3><p><code>animation-play-state</code>属性定义了动画是否运行还是暂停。一个运行中的动画可以通过设置该属性为<code>pasued</code>。为了继续运行这个暂停的动画可以设置该属性为<code>running</code>。一个暂停的动画将继续处于静止状态显示动画的当前值，就好像动画的时间是常数。当已暂停的动画被恢复，它从当前值重新启动，而没必要从动画的开始。</p>
<ul>
<li>名称：<code>animation-play-state</code></li>
<li>取值：<code>&lt;single-animation-play-state&gt; [ ‘,’ &lt;single-animation-play-state&gt; ]*</code></li>
<li>初始值：<code>running</code></li>
<li>应用于：所有元素，<code>::before</code>和<code>::after</code>伪元素</li>
<li>继承：无</li>
<li>可否动画：否</li>
<li>百分比：<code>N/A</code></li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<p>其中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;single-animation-play-state&gt; = running | paused</span><br></pre></td></tr></table></figure>
<h3 id="4-8_animation-delay属性">4.8 <code>animation-delay</code>属性</h3><p><code>animation-delay</code>属性定义了动画什么时候开始。它允许动画开始执行一段时间（就是延迟一段时间执行）后在它被应用之后。当<code>animation-delay</code>的值为<code>0s</code>，意味着动画会在被应用后立即执行。否则，该值指定了从动画被应用时刻的偏移，以及动画将用该偏移延迟执行。</p>
<p>如果<code>animation-delay</code>的值是负的时间偏移，则动画将在它被应用的时刻执行，但是会出现在指定的偏移开始执行。也就是说，动画会出现从运行周期的一部分开始。</p>
<ul>
<li>名称：<code>animation-delay</code></li>
<li>取值：<code>&lt;time&gt; [, &lt;time&gt;]*</code></li>
<li>初始值：0s</li>
<li>应用于：所有元素，<code>::before</code>和<code>::after</code>伪元素</li>
<li>继承：无</li>
<li>可否动画：否</li>
<li>百分比：<code>N/A</code></li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<h3 id="4-9_animation-fill-mode属性">4.9 <code>animation-fill-mode</code>属性</h3><p><code>animation-fill-mode</code>属性定义了什么值被应用在动画之外的执行时间。默认情况下，动画不会影响在它被应用的时间和它开始执行的时间之间的属性值。同样，默认情况下动画也不会影响在动画结束后的属性值。<code>animation-fill-mode</code>可以覆盖这种行为。</p>
<p>如果<code>animation-fill-mode</code>的值为<code>backwards</code>，则动画会应用在定义在动画第一个迭代开始的关键帧的属性值，在定义在<code>animation-delay</code>的时间之间。</p>
<p>如果<code>animation-fill-mode</code>的值为<code>forwards</code>，则在动画结束后，动画将应用在动画结束后的属性值。</p>
<p>如果<code>animation-fill-mode</code>的值为<code>both</code>，则动画会遵循<code>backwards</code>和<code>forwards</code>的规则。也就是说，它会扩展两个方向的动画属性。</p>
<ul>
<li>名称：<code>animation-fill-mode</code></li>
<li>取值：<code>&lt;single-animation-fill-mode&gt; [ ‘,’ &lt;single-animation-fill-mode&gt; ]*</code></li>
<li>初始值：<code>none</code></li>
<li>应用于：所有元素，<code>::before</code>和<code>::after</code>伪元素</li>
<li>继承：无</li>
<li>可否动画：否</li>
<li>百分比：<code>N/A</code></li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<p>其中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;single-animation-fill-mode&gt; = none | forwards | backwards | both</span><br></pre></td></tr></table></figure>
<h3 id="4-10_animation简写属性">4.10 <code>animation</code>简写属性</h3><p><code>animation</code>属性是一个逗号分隔的动画定义列表，其中结合了7个动画属性成单个组件的值。</p>
<ul>
<li>名称：<code>animation</code></li>
<li>取值：<code>&lt;single-animation&gt; [ ‘,’ &lt;single-animation&gt; ]*</code></li>
<li>初始值：看单个属性的初始值</li>
<li>应用于：所有元素，<code>::before</code>和<code>::after</code>伪元素</li>
<li>继承：无</li>
<li>可否动画：否</li>
<li>百分比：<code>N/A</code></li>
<li>媒体：视觉</li>
<li>计算值：看单个属性</li>
</ul>
<p>其中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;single-animation&gt; = &lt;single-animation-name&gt; || &lt;time&gt; || &lt;single-animation-timing-function&gt; || &lt;time&gt; || &lt;single-animation-iteration-count&gt; || &lt;single-animation-direction&gt; || &lt;single-animation-fill-mode&gt; || &lt;single-animation-play-state&gt;</span><br></pre></td></tr></table></figure>
<p>要注意，在每个动画定义中顺序是非常重要的：第一个<code>&lt;time&gt;</code>值被赋给<code>animation-duration</code>，第二个<code>&lt;time&gt;</code>值赋给<code>animation-delay</code>。</p>
<h2 id="5_动画事件">5 动画事件</h2><p>事件相关可以自己看文档啦：<a href="http://www.w3.org/TR/css3-animations/#animation-events" target="_blank" rel="external">http://www.w3.org/TR/css3-animations/#animation-events</a></p>
<p>这里说下动画的三个事件：</p>
<ul>
<li>animationStart：发生在动画开始</li>
<li>animationEnd：发生在动画结束</li>
<li>animationiteration：发生在动画每个迭代的结束</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/CSS/">CSS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Animation/">Animation</a><a href="/tags/CSS3/">CSS3</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/01/21/css3-animation/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/01/21/css3-animation/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分類</p>
		<ul>
		
		  
			<li><a href="/categories/CSS/" title="CSS">CSS<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript/" title="JavaScript">JavaScript<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>3</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">標簽</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/JavaScript/" title="JavaScript">JavaScript<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/CSS3/" title="CSS3">CSS3<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS/" title="iOS">iOS<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Flexbox/" title="Flexbox">Flexbox<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Transform/" title="Transform">Transform<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Media-Query/" title="Media Query">Media Query<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Animation/" title="Animation">Animation<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/selector/" title="selector">selector<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情鏈接</p>
    <ul>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 訂閱</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> keep coding <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/https://github.com/cookfront" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:cookfront@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="http://cookfront.github.io/about" target="_blank" title="cookfront@gmail.com">cookfront@gmail.com</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"cookfront"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 









<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F1e9fdadfaa36dffc9a8914a1220e8161' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回頂部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>

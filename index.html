
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Cookfront&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="cookfront@gmail.com">
    

    
    <meta name="description" content="Cookfront&apos;s Blog，前端开发，HTML，CSS，JavaScript，jQuery，HTML5，CSS3，Sass Compass，Node.js">
<meta property="og:type" content="website">
<meta property="og:title" content="Cookfront's Blog">
<meta property="og:url" content="http://cookfront.github.io/index.html">
<meta property="og:site_name" content="Cookfront's Blog">
<meta property="og:description" content="Cookfront&apos;s Blog，前端开发，HTML，CSS，JavaScript，jQuery，HTML5，CSS3，Sass Compass，Node.js">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cookfront's Blog">
<meta name="twitter:description" content="Cookfront&apos;s Blog，前端开发，HTML，CSS，JavaScript，jQuery，HTML5，CSS3，Sass Compass，Node.js">

    
    <link rel="alternative" href="/atom.xml" title="Cookfront&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Cookfront&#39;s Blog" title="Cookfront&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Cookfront&#39;s Blog">Cookfront&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:cookfront.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/18/ios-uiview/" title="iOS UIView 学习" itemprop="url">iOS UIView 学习</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-05-18T03:47:42.000Z" itemprop="datePublished"> 發表於 2015-05-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文主要翻译自：<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009503-CH1-SW2" target="_blank" rel="external">View Programming Guide for iOS</a>，内容有删减。</p>
<p><code>UIView</code>类在屏幕上定义了一个矩形区域和一些在那个区域处理内容的接口。在运行时，一个<code>view</code>对象处理那个区域任何内容的渲染，还处理与这些内容的任何交互。<code>UIView</code>类它自己提供了用一个背景颜色填充它的矩形区域的基本行为。更复杂的内容可以通过继承<code>UIView</code>来呈现，并自身实现必要的绘制和事件处理代码。<code>UIKit</code>框架还包括一组标准的子类，从简单的按钮到复杂的表格可以使用。例如，一个<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UILabel_Class/index.html#//apple_ref/occ/cl/UILabel" target="_blank" rel="external">UILabel</a>对象绘制一个文本字符串，一个<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImageView_Class/index.html#//apple_ref/occ/cl/UIImageView" target="_blank" rel="external">UIImageView</a>对象绘制一张图片。</p>
<p>因为<code>view</code>对象是你的应用与用户交互的主要方式，所以它们具有许多职责。这里仅仅是几个：</p>
<ul>
<li>绘制和动画<ul>
<li>视图使用例如<code>UIKit</code>，<code>Core Graphics</code>和<code>OpenGL ES</code>的技术在它们的矩形区域绘制内容</li>
<li>一些视图属性可以动画到新的值</li>
</ul>
</li>
<li>布局和子视图管理<ul>
<li>一个视图可能包含0个或多个子视图</li>
<li>每一个视图定义了相对于它的父视图的它们自己默认的尺寸调整行为</li>
<li>视图可以根据需要限定的它的子视图的尺寸和位置</li>
</ul>
</li>
<li>事件处理<ul>
<li>视图是一个应答器，并能处理触摸事件以及由<code>UIResponder</code>类定义的其它事件</li>
<li>视图可以使用<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instm/UIView/addGestureRecognizer:" target="_blank" rel="external">addGestureRecognizer:</a>方法安装手势识别以处理常见的手势</li>
</ul>
</li>
</ul>
<p>视图可以嵌入其他视图，并创建复杂的视觉层次。这在被嵌入的视图（被称为subview）和父视图做嵌入（被称为superview）之间创建了一种<code>父－子</code>关系。通常情况下，一个<code>subview</code>的可见区域不会在它的<code>superview</code>的边界被剪切，但是在<code>iOS</code>中你可以使用<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instp/UIView/clipsToBounds" target="_blank" rel="external">clipsToBounds</a>来更新这种行为。一个父视图可以包含任意多个<code>subview</code>，但每个<code>subview</code>只有一个<code>superview</code>，该<code>superview</code>负责适当定位其子视图。</p>
<h2 id="视图绘制周期">视图绘制周期</h2><p><code>UIView</code>类使用一个按需绘制的模式来呈现内容。当一个视图第一次出现在屏幕上时，系统要求它绘制它的内容。系统捕捉内容的快照，并使用快照作为视图的可视化表示。如果你从未改变过视图内容，视图的绘制代码可能永远不会被再次调用。快照图片对于涉及视图的大部分操作中被重用。如果你更改了内容，你通知系统视图被改变了。视图重复绘制视图和捕捉新结果的快照。</p>
<p>当视图内容改变的时候，你不需要直接重绘这些变化。相反，你使用<code>setNeedsDisplay</code>或<code>setNeedsDisplayInRect:</code>中任何一个方法使视图失效。这些方法告诉系统视图中的内容被改变了，需要在下次机会被重绘。</p>
<p>当到了渲染视图内容的时候，实际的绘制过程取决于视图和它的配置。系统视图通常实现私有绘图方法来呈现其内容。这些相同的系统视图通常暴露接口，使用接口你可以配置视图的实际外观。对于自定义的<code>UIView</code>子类，你通常覆盖你视图的<code>drawRect:</code>方法，并使用该方法来绘制视图的内容。也有其他的方式来提供视图的内容，例如，直接设计内容底部的<code>layer</code>，但是覆盖<code>drawRect:</code>方法是最常用的技术。</p>
<p>下面再来看下上面提到的三个方法：</p>
<ul>
<li><code>- setNeedsDisplay</code></li>
</ul>
<p><strong>声明：</strong></p>
<p>SWIFT</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">setNeedsDisplay</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>OBJECTIVE-C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setNeedsDisplay</span><br></pre></td></tr></table></figure>
<p>你可以使用该方法或<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instm/UIView/setNeedsDisplayInRect:" target="_blank" rel="external">setNeedsDisplayInRect:</a>方法来通知系统你的视图内容需要被重绘了。这个方法发起请求并立即返回。视图并不是真的在重绘直到下一个绘制周期，在该点所有失效的视图被更新。</p>
<p>你应该只在视图的内容和外观改变时使用该方法来请求视图重绘。如果你只是简单地更改视图的几何结构，视图通常不会重新绘制。作为代替，它的现有内容基于视图的<code>contentMode</code>属性的值进行调整。重新显示现有的内容通过避免重绘并没有改变的内容而提供了性能。</p>
<ul>
<li><code>- setNeedsDisplayInRect:</code></li>
</ul>
<p><strong>声明：</strong></p>
<p>SWIFT</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">setNeedsDisplayInRect</span><span class="params">(_ invalidRect: CGRect)</span></span></span><br></pre></td></tr></table></figure>
<p>OBJECTIVE-C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setNeedsDisplayInRect:(CGRect)invalidRect</span><br></pre></td></tr></table></figure>
<ul>
<li><code>- drawRect:</code></li>
</ul>
<p><strong>声明：</strong></p>
<p>SWIFT</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">drawRect</span><span class="params">(_ rect: CGRect)</span></span></span><br></pre></td></tr></table></figure>
<p>OBJECTIVE-C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(CGRect)rect</span><br></pre></td></tr></table></figure>
<p><strong>参数：</strong></p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>rect</td>
<td>视图的边界部分。你的视图在第一绘制时，该矩形是通常是视图的整个可见边界。然而，在随后的绘制操作中，矩形可能被指定为视图的一部分。</td>
</tr>
</tbody>
</table>
<p>该方法的默认实现不做任何事情。使用技术，例如<code>Core Graphics</code>和<code>UIKit</code>来绘制它们的视图内容时，子类应该覆盖该方法并在该方法中实现它们的绘制代码。如果你的视图通过其他方式来设置它的内容，则你不需要覆盖该方法。例如，你不需要覆盖该方法如果你的视图仅显示一个背景颜色时或者你的视图通过底层的<code>layer</code>对象直接设置它们的内容。</p>
<p>在该方法被调用时，<code>UIKit</code>已经正确的为您的视图配置好绘制环境，你可以简单的调用任何绘制方法和功能来渲染你的内容。具体来说，<code>UIKit</code>创建和配置了一个图形上下文来绘制和调整在那个上下文中的转换，从而它的原点匹配你视图边界矩形的原点。你可以通过<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKitFunctionReference/index.html#//apple_ref/c/func/UIGraphicsGetCurrentContext" target="_blank" rel="external">UIGraphicsGetCurrentContext</a>函数来获取到该图形上下文的引用，但是不要建立一个强引用到该图形上下文，因为它会因为<code>drawRect:</code>方法的调用被改变。</p>
<p>需要注意的是，你永远不要直接调用该方法。我们可以通过<code>setNeedsDisplay</code>和<code>setNeedsDisplayInRect:</code>方法来告诉视图需要重绘。</p>
<h2 id="Content_Mode">Content Mode</h2><p>每个视图有一个内容模式，它控制视图在响应视图的几何结构改变时如何回收其内容，以及是否回收其内容。当视图第一次显示时，它和平常一样渲染内容，且结果在底层的位图中被捕获。在那之后，更改视图的几何形状并不总是导致位图重新被创建。作为替代，<code>contentMode</code>属性的值决定了位图是否应该缩放以适应新的边界，或简单的固定到一个角落或视图的边缘。</p>
<p>当你做以下事情时，一个视图的内容模式被应用：</p>
<ul>
<li>改变视图的<code>frame</code>或<code>bounds</code>矩形的宽度或高度</li>
<li>分配一个包括一个伸缩因子的变换到视图的<code>transform</code>属性</li>
</ul>
<p>默认情况下，对于大多数视图的<code>contentMode</code>属性被设置为<code>UIViewContentModeScaleToFill</code>，这将导致视图的内容被伸缩以适应新的框架尺寸。下面的图显示了几个<code>contentMode</code>属性值之间的比较：</p>
<p><img src="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/scale_aspect.jpg" alt="enter image description here"></p>
<p>内容模式有利于回收利用视图的内容，但是你也可以设置内容模式为<code>UIViewContentModeRedraw</code>，当你需要你的自定义视图在伸缩或调整操作时重绘它们自己。设置你的视图的内容模式为该值时，会强制系统调用你视图的<code>drawRect:</code>方法以响应几何尺寸的改变。一般情况下，只要有可能你应该避免使用这个值，你当然不应该在标准的系统视图中使用它。</p>
<h2 id="内置动画支持（Built-In_Animation_Support）">内置动画支持（Built-In Animation Support）</h2><p>在每一个视图后面有一个<code>layer</code>对象的一个好处是，你可以轻松动画许多视图相关的改变。动画是一种将信息传达给用户的非常有用的方式，在您的应用程序的设计过程中应该始终考虑它。<code>UIView</code>类的许多属性是可动画的——也就是说，半自动的支持从一个值到另一个值的动画。为了对这些动画属性之一执行动画，你所要做的是：</p>
<ol>
<li>告诉<code>UIKit</code>你要执行的动画</li>
<li>改变属性的值</li>
</ol>
<p><code>UIView</code>对象上你可以设置动画的属性为以下这些：</p>
<ul>
<li>frame：使用这个来动画视图的位置和尺寸</li>
<li>bounds：使用这个来动画视图的尺寸</li>
<li>center：使用这个来动画视图的位置</li>
<li>transform：使用这个来旋转或伸缩视图</li>
<li>alpha：使用这个来改变视图的透明性</li>
<li>backgroundColor：使用这个来改变视图的背景色</li>
<li>contentStretch：使用这个来改变视图如何伸缩</li>
</ul>
<h2 id="视图几何结构和坐标系统（View_Geometry_and_Coordinate_Systems）">视图几何结构和坐标系统（View Geometry and Coordinate Systems）</h2><p>在<code>UIKit</code>中默认的坐标系统有一个原点在左上角，且坐标轴向原点处往右和下延伸。坐标值是使用浮点数来代表，这使得精确布局和内容定位不考虑底层的屏幕分辨率。下图展示了相对于屏幕的坐标系统。</p>
<p><img src="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/native_coordinate_system.jpg" alt="enter image description here"></p>
<p>因为每个视图和<code>window</code>定义了它们自己的局部坐标系统，你需要知道在任何给定时间是哪个坐标系在起作用。任何时候你在视图中绘制或改变它的几何结构时，你这样做，相对于一些坐标系统。在正在绘制的情况下，你指定相对于视图自己的坐标系统的坐标。在几何结构改变的情况下，你指定相对于<code>superview</code>坐标系统的坐标。<code>UIWindow</code>和<code>UIView</code>类都包含了方法来帮助你从一个坐标系统转换为另一个。</p>
<h3 id="frame、bounds和center属性之间的关系"><code>frame</code>、<code>bounds</code>和<code>center</code>属性之间的关系</h3><p>一个视图对象使用<code>frame</code>、<code>bounds</code>和<code>center</code>属性来跟踪它的尺寸和位置：</p>
<ul>
<li>frame：<code>frame</code>属性包含了框架矩形，它指定了视图相对于<code>superview</code>坐标系统的尺寸和位置</li>
<li>bounds：<code>bounds</code>属性包含了边界矩形，它指定了视图相对于它的局部坐标系统的尺寸和位置</li>
<li>center：<code>center</code>属性包含了视图在<code>superview</code>坐标系统的中电</li>
</ul>
<p>你使用<code>center</code>和<code>frame</code>属性主要用于操作当前视图的几何结构。例如，当你在构建你的视图层级或在运行时改变一个视图的位置和尺寸时，你可以使用这些属性。如果你仅仅只是想改变视图的位置，<code>center</code>属性是首选的方法。<code>center</code>属性的值始终是有效的，即使伸缩或旋转因素被添加到视图的变换中。在同样情况下，对于<code>frame</code>属性则不正确，这被认为是无效的，如果视图的变换不等于恒等变换。</p>
<p>你使用<code>bounds</code>属性主要在绘制期间。边界矩形是在视图自己的局部坐标系统中的表示。该矩形的默认原点为<code>(0, 0)</code>，且它的尺寸匹配框架矩形的尺寸。任何你在该矩形中绘制的东西是视图可见内容的一部分。如果你改变边界矩形的原点，任何你在新的矩形中绘制的东西称为视图可见内容的一部分。</p>
<p>下图显示了这三个属性之间的关系：</p>
<p><img src="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/frame_bounds_rects.jpg" alt="enter image description here"></p>
<p>虽然你改变<code>frame</code>、<code>bounds</code>和<code>center</code>属性独立于其他，但是改变其中一个属性会按以下方式来改变其他属性：</p>
<ul>
<li>当你设置<code>frame</code>属性，<code>bounds</code>属性中的尺寸值也相应改变以匹配框架矩形的新尺寸。<code>center</code>属性的值也同样改变以匹配框架矩形中xin的中点。</li>
<li>当你设置<code>center</code>属性，在<code>frame</code>属性中的原点值也会相应改变。</li>
<li>当你设置<code>bounds</code>属性的尺寸时，<code>frame</code>属性中的尺寸值也相应改变以匹配边界矩形中的新尺寸。</li>
</ul>
<p>默认情况下，一个视图的框架（frame）不会被其<code>superview</code>的框架剪切。你可以改变这种行为，通过设置<code>superview</code>的<code>clipToBounds</code>属性为<code>YES</code>。</p>
<h3 id="坐标系统转换">坐标系统转换</h3><p>坐标系统转换提供了一种方式来更快和更简单的更新你的视图。一个仿射变换是一个数学矩阵，它指定了点如何从一个坐标系统映射到另一个坐标系统。你可以应用仿射变换到你的整个视图，以改变尺寸、位置或相对于其<code>superview</code>的方向。你也可以使用仿射变换在你的绘制代码中，去以单个块的渲染内容来执行相同类型的操作。如何应用仿射变换取决于上下文：</p>
<ul>
<li>要改变你的整个视图，改变你视图中<code>transform</code>属性的仿射变换。</li>
<li>要改变你视图的<code>drawRect:</code>方法的指定块的内容，改变关联当前活跃图形上下文的仿射变换。</li>
</ul>
<p>通常，您可以修改视图的<code>transform</code>属性，当你想要实现动画时。例如，你可以使用该属性创建一个你视图围绕中点旋转的动画。你不能使用该属性永久改变你的视图，例如改变视图在它的<code>superview</code>坐标空间的尺寸和位置。对于那种类型的改变，你应该改变框架矩形作为替代。</p>
<p>在你的<code>drawRect:</code>方法中，你可以使用仿射变换来定位和适应你计划绘制的元素。而不是固定在你视图某个位置的一个对象的位置，去创建相对于一个固定点的每个对象是非常简单的，通常<code>(0, 0)</code>，使用一个<code>transform</code>来定位该对象在立即绘制之前。在那种方式，该对象的位置在你的视图中改变，所有你所要做的就是修改变换，这是更快，更便宜的，相对于重新创建一个对象在它的新位置。你可以通过使用<code>CGContextGetCTM</code>函数来检索关联图形上下文的仿射变换，且你可以使用相关的<code>Core Graphics</code>函数在绘制期间设置和修改变换。</p>
<p><code>当前变换矩阵（current transformation matrix (CTM)）</code>是在任何给定时间当前正在使用的仿射变换。当操作整个视图的几何结构时，<code>CTM</code>是储存在你视图的<code>transform</code>属性的仿射变换。在你的<code>drawRect:</code>方法中，<code>CTM</code>是关联当前活跃图形上下文的仿射变换。</p>
<p>每个子视图的坐标系建立在其祖先的坐标系上。所以当你修改一个视图的<code>transform</code>属性时，这些改变会影响视图和它的所有子视图。然而，这些改变只影响视图在屏幕上的最后渲染。因为任何视图绘制它的内容和布局它的子视图是相对于它自己的边界，它在绘制和布局期间会忽略它的<code>superview</code>的变换。</p>
<h2 id="创建和管理视图层次">创建和管理视图层次</h2><p>管理视图层次是开发应用程序用户界面的重要组成部分。你的视图的组织影响你的应用程序的外观和应用程序如何响应变化和事件。例如，在视图层次中的<code>父－子</code>关系决定了哪个对象可能处理某个指定的触摸事件。同样的，<code>父－子</code>关系定义了每个视图如何响应界面方向改变。</p>
<h3 id="添加和移除子视图">添加和移除子视图</h3><p><code>Interface Builder</code>是建立视图层次的最方便的方式，因为你以图形化的方式组装视图，可以看到视图之间的关系，同样可以看到这些视图如何在运行时显示。当使用<code>Interface Builder</code>，你保存你的结果视图层级在一个<code>nib</code>文件中，你可以在运行时加载相应需要的视图。</p>
<p>如果你更愿意以程序的方式来创建你的视图，你创建和初始化它们，然后使用以下方法安排它们到层次：</p>
<ul>
<li>要添加一个子视图到父亲，在父视图上调用<code>addSubview:</code>。该方法添加子视图到父视图的子视图列表的末尾。</li>
<li>要插入一个子视图到父视图的子视图列表的中间，可以在父视图上调用任何和<code>insertSubview:...</code>相关的方法。</li>
<li>要重排父视图中现有的子视图，调用父视图的<code>bringSubviewToFront:</code>、<code>sendSubviewToBack:</code>或<code>exchangeSubviewAtIndex:withSubviewAtIndex:</code>方法。使用这些方法比移除子视图或重新插入它们更快。</li>
<li>要从父视图中移除一个子视图，在子视图上调用<code>removeFromSuperview</code>方法。</li>
</ul>
<p>添加一个子视图到另一个视图中最常见的例子发生在<code>application:didFinishLaunchingWithOptions:</code>方法中。下面显示了一个该方法的版本，它将视图从应用程序的主视图控制器安装到应用程序的<code>window</code>。<code>window</code>和视图控制器都是储存在应用程序的主<code>nib</code>文件中，它会在该方法调用前被加载。然而，由视图控制器管理的视图层级实际上不会加载，直到<code>view</code>属性被访问。</p>
<p>添加一个子视图到<code>window</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    <span class="comment">// Add the view controller's view to the window and display.</span></span><br><span class="line">    [window addSubview:viewController.view];</span><br><span class="line">    [window makeKeyAndVisible];</span><br><span class="line"><span class="keyword">return</span> YES; &#125;</span><br></pre></td></tr></table></figure>
<p>另一个常见的地方你可能添加子视图到视图层级中是在视图控制器的<code>loadView</code>和<code>viewDidLoad</code>方法中。如果你正在利用程序构建视图，你讲创建视图的代码放在视图控制器的<code>loadView</code>方法中。无论你是使用程序的方式，还是使用<code>nib</code>文件加载的方式来创建视图，你可能会在<code>viewDidLoad</code>方法中包含额外的视图配置代码。</p>
<p>添加视图到已存在的视图层级：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">      [super viewDidLoad];</span><br><span class="line">      self.title = NSLocalizedString(@<span class="string">"TransitionsTitle"</span>, @<span class="string">""</span>);</span><br><span class="line"><span class="comment">// create the container view which we will use for transition animation (centered horizontally)</span></span><br><span class="line">      CGRect frame = CGRectMake(round((self.view.bounds.size.width - kImageWidth) /</span><br><span class="line">   <span class="number">2.0</span>),</span><br><span class="line">                                                        kTopPlacement, kImageWidth,</span><br><span class="line">   kImageHeight);</span><br><span class="line">      self.containerView = [[[UIView alloc] initWithFrame:frame] autorelease];</span><br><span class="line">      [self.view addSubview:self.containerView];</span><br><span class="line">      <span class="comment">// The container view can represent the images for accessibility.</span></span><br><span class="line">      [self.containerView setIsAccessibilityElement:YES];</span><br><span class="line">      [self.containerView setAccessibilityLabel:NSLocalizedString(@<span class="string">"ImagesTitle"</span>,</span><br><span class="line">  @<span class="string">""</span>)];</span><br><span class="line">      <span class="comment">// create the initial image view</span></span><br><span class="line">      frame = CGRectMake(<span class="number">0.0</span>, <span class="number">0.0</span>, kImageWidth, kImageHeight);</span><br><span class="line">      self.mainView = [[[UIImageView alloc] initWithFrame:frame] autorelease];</span><br><span class="line">      self.mainView.image = [UIImage imageNamed:@<span class="string">"scene1.jpg"</span>];</span><br><span class="line">      [self.containerView addSubview:self.mainView];</span><br><span class="line">      <span class="comment">// create the alternate image view (to transition between)</span></span><br><span class="line">CGRect imageFrame = CGRectMake(<span class="number">0.0</span>, <span class="number">0.0</span>, kImageWidth, kImageHeight); self.flipToView = [[[UIImageView alloc] initWithFrame:imageFrame] autorelease];</span><br><span class="line">      self.flipToView.image = [UIImage imageNamed:@<span class="string">"scene2.jpg"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你添加子视图到另一个视图，<code>UIKit</code>通知父视图和子视图这些改变。如果你实现了自定义视图，你可以覆盖以下方法来拦截这些通知：<code>willMoveToSuperview:</code>、<code>willMoveToWindow:</code>、<code>willRemoveSubview:</code>、<code>didAddSubview:</code>、<code>didMoveToSuperview</code>或<code>didMoveToWindow</code>。您可以使用这些通知以更新与您的视图层次中相关的任何状态信息或执行其他任务。</p>
<h3 id="隐藏视图">隐藏视图</h3><p>为了在视觉上隐藏视图，你可以通过设置<code>hidden</code>属性为<code>YES</code>或者设置<code>alpha</code>属性为<code>0.0</code>。一个隐藏的视图不从系统接收触摸事件。然而，隐藏的视图仍然参与到自动调整大小和其他关联视图层级的布局操作。因此，当你需要从视图层级移除视图，隐藏视图通常是一个方便的选择，特别是如果你计划在某个点再重新显示视图。</p>
<p>如果你想动画一个视图，从可见过渡到隐藏（或者相反），你必须使用视图的<code>alpha</code>属性。因为<code>hidden</code>属性不是一个可动画的属性，所以你在上面做的改变会立即发生。</p>
<h3 id="在视图层级中定位视图">在视图层级中定位视图</h3><p>有两种方法在视图层级中定位视图：</p>
<ul>
<li>在适合的位置存储任何有关视图的指针，例如，在拥有该视图的视图控制器。</li>
<li>分配一个唯一的整数到每个视图的<code>tag</code>属性，然后使用<code>viewWithTag:</code>来定位它。</li>
</ul>
<p>储存相关视图的引用是最常见定位视图的方式，且使得访问这些视图非常容易。如果你使用<code>Interface Builder</code>来创建你的视图，你可以在你的<code>nib</code>文件中使用<code>outlets</code>连接对象到另一个。对于你用程序创建的视图，你可以在私有成员变量中保存这些视图的引用。无论你是使用<code>outlets</code>还是私有成员变量，你负责在需要时保留视图，或者释放它们。保证对象保留和释放最好的办法是使用声明的属性。</p>
<p>标签是减少硬编码依赖和支持动态和灵活的解决方案的有效方式。而不是保存视图的指针，你可以使用<code>tag</code>来定位它。标签也是引用视图的一种更持久的方式。</p>
<h3 id="平移，缩放和旋转视图">平移，缩放和旋转视图</h3><p>每个视图有一个关联的仿射变换，你可以使用它来平移、伸缩和旋转视图的内容。视图变换改变视图的最终渲染外观，且通常用于实现滚动，动画，或其他视觉效果。</p>
<p><code>UIView</code>的<code>transform</code>属性包含了一个应用变换的<code>CGAffineTransform</code>结构。默认情况下，这个属性被设置为恒等变换，不修改视图的外观。你可以在任何时候给该属性赋一个新的变换。例如，将一个视图旋转45度，你可以使用以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// M_PI/4.0 is one quarter of a half circle, or 45 degrees.</span></span><br><span class="line">CGAffineTransform xform = CGAffineTransformMakeRotation(M_PI/<span class="number">4.0</span>);</span><br><span class="line">self.view.transform = xform;</span><br></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/rotated_view.jpg" alt="enter image description here"></p>
<h2 id="在视图层级中转换坐标">在视图层级中转换坐标</h2><p>在不同的时间，特别是处理事件时，应用程序可能需要从一个框架的引用到另一个之间转换坐标值。例如，触摸事件是在<code>window</code>坐标系统中报告每一次触摸的位置，但是视图对象通常在视图的局部坐标系统中需要这些信息。<code>UIView</code>类定义了以下方法来转换坐标：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">convertPoint:fromView:</span><br><span class="line">convertRect:fromView:</span><br><span class="line">convertPoint:toView:</span><br><span class="line">convertRect:toView:</span><br></pre></td></tr></table></figure>
<p><code>convert...:fromView:</code>方法从其他视图坐标系统转换坐标到当前视图的局部坐标系统。相反的，<code>convert...:toView:</code>方法从当前视图坐标系统转换坐标到指定的视图的坐标系统。如果对于任何方法你指定<code>nil</code>为引用的视图，是从包含当前视图的<code>window</code>的坐标系统中转换。</p>
<p>除了<code>UIView</code>的转换方法，<code>UIWindow</code>类也同样定义了几个转换方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">convertPoint:fromWindow:</span><br><span class="line">convertRect:fromWindow:</span><br><span class="line">convertPoint:toWindow:</span><br><span class="line">convertRect:toWindow:</span><br></pre></td></tr></table></figure>
<p>未完待续。。。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/18/ios-uiview/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/05/18/ios-uiview/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/04/18/objectivec-block/" title="Objective-C基础学习之block" itemprop="url">Objective-C基础学习之block</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-04-18T10:07:42.000Z" itemprop="datePublished"> 發表於 2015-04-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>以下学习内容是翻译自Apple的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/ProgrammingWithObjectiveC.pdf" target="_blank" rel="external">Programming with Objective-C</a>，内容有部分删减，主要是自己一个学习和理解的过程，如有翻译不当，还请谅解。</p>
<p><code>Block</code>是被添加到<code>C</code>、<code>Objective-C</code>和<code>C++</code>的语言级别的特性，它允许你创建不同的代码片段，这些代码片段可以作为值传入到方法或函数中。<code>Blocks</code>是<code>Objective-C</code>对象，这意味着它可以被添加到类似<code>NSArray</code>和<code>NSDictionary</code>的集合中。他们同样有从封闭作用域中捕获值的能力，使他们类似于其他编程语言的<code>closures</code>和<code>lambdas</code>。</p>
<h2 id="Block语法">Block语法</h2><p>定义一个<code>block</code>是使用<code>^</code>符号，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^&#123;</span><br><span class="line">     NSLog(@<span class="string">"This is a block"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像函数和方法的定义，大括号表明了<code>block</code>的开始和结束。在这个例子中，<code>block</code>没有返回任何值，也没有任何参数。</p>
<p>以同样的方式，您可以使用一个函数指针来引用一个C函数，你可以定义一个变量来记录一个<code>block</code>，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^simpleBlock)(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<p>这个例子定义了一个变量：<code>simpleBlock</code>，该变量用于引用一个<code>block</code>，且该<code>block</code>没有参数且不返回值，这意味着您可以像下面这样将<code>block</code>字面赋给<code>simpleBlock</code>变量，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">simpleBlock = ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"This is a block"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要注意的是大括号末尾的分号。您同样可以结合变量定义和赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^simpleBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"This is a block"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后你就可以像下面这样来调用<code>block</code>了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simpleBlock();</span><br></pre></td></tr></table></figure>
<h2 id="带参数和返回值的Block">带参数和返回值的Block</h2><p><code>Block</code>是可以接受参数和返回值的，就像函数和方法那样。</p>
<p>作为一个例子，考虑一个变量引用到一个<code>block</code>，该<code>block</code>返回两个值的乘积：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (^multiplyTwoValues)(<span class="keyword">double</span>, <span class="keyword">double</span>);</span><br></pre></td></tr></table></figure>
<p>关联的<code>block</code>字面可能是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^ (<span class="keyword">double</span> firstValue, <span class="keyword">double</span> secondValue) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstValue * secondValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你声明和定义好了<code>block</code>，你可以调用它就像一个函数一样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (^multiplyTwoValues)(<span class="keyword">double</span>, <span class="keyword">double</span>) =</span><br><span class="line">                          ^(<span class="keyword">double</span> firstValue, <span class="keyword">double</span> secondValue) &#123;</span><br><span class="line">                              <span class="keyword">return</span> firstValue * secondValue;</span><br><span class="line">                          &#125;;</span><br><span class="line"><span class="keyword">double</span> result = multiplyTwoValues(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">NSLog(@<span class="string">"The result is %f"</span>, result);</span><br></pre></td></tr></table></figure>
<h2 id="Block能从封闭作用域中捕获值">Block能从封闭作用域中捕获值</h2><p>如果你在一个方法中定义了一个<code>block</code>，例如，它能从该方法的作用域中捕获任何能访问到的值，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testMethod &#123;</span><br><span class="line">    <span class="keyword">int</span> anInteger = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"Integer is: %i"</span>, anInteger);</span><br><span class="line">&#125;;</span><br><span class="line">    testBlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>anInteger</code>是定义在<code>block</code>之外的，但是当<code>block</code>定义时该变量被捕获到了。</p>
<p>只有值被捕获了，除非你指定。这意味着当你在定义<code>block</code>和调用<code>block</code>之间改变该变量的外在值时，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> anInteger = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"Integer is: %i"</span>, anInteger);</span><br><span class="line">&#125;;</span><br><span class="line">anInteger = <span class="number">84</span>;</span><br><span class="line">testBlock();</span><br></pre></td></tr></table></figure>
<p>被<code>block</code>捕获的值并没有受到影响。这意味着同样会输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer is: <span class="number">42</span></span><br></pre></td></tr></table></figure>
<h3 id="使用__block来共享存储">使用__block来共享存储</h3><p>如果你需要能够在<code>block</code>中改变捕获变量的值，你可以使用<code>__block</code>存储类型修饰符对原变量声明。这意味着该变量所在的存储是在原始变量的词法作用域和任何定义在该作用域的<code>block</code>之间共享。</p>
<p>作为一个例子，你可以重写之前都例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> anInteger = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"Integer is: %i"</span>, anInteger);</span><br><span class="line">&#125;;</span><br><span class="line">anInteger = <span class="number">84</span>;</span><br><span class="line">testBlock();</span><br></pre></td></tr></table></figure>
<p>因为<code>anInteger</code>被定义为一个<code>__block</code>变量，它的存储会在<code>block</code>定义中共享。上面的代码会输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer is: <span class="number">84</span></span><br></pre></td></tr></table></figure>
<p>这也意味着在<code>block</code>中可以修改原始值，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> anInteger = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"Integer is: %i"</span>, anInteger);</span><br><span class="line">    anInteger = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line">testBlock();</span><br><span class="line">NSLog(@<span class="string">"Value of original variable is now: %i"</span>, anInteger);</span><br></pre></td></tr></table></figure>
<p>以上会输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer is: <span class="number">42</span></span><br><span class="line">Value of original variable is now: <span class="number">100</span></span><br></pre></td></tr></table></figure>
<h2 id="你可以传递Block给方法或函数作为参数">你可以传递Block给方法或函数作为参数</h2><p>在前面的所有例子中，你都是定义<code>block</code>之后立即调用它。实践中，传递<code>block</code>给函数或方法调用是非常常见的。你可能会使用<code>Grand Central Dispatch</code>在后台调用<code>block</code>，例如，或者定义一个<code>block</code>代表重复被调用的任务，例如当枚举一个集合的时候。</p>
<p><code>Block</code>也同样可以被用于回调，定义一些代码在任务完成后执行。作为一个例子，你的app可能需要通过创建一个对象来响应用户的动作以此处理复杂的任务，例如从web服务器请求信息。因为这个任务可能会需要很长一段时间，在任务正在进行时您应该显示某种进度指示器，而一旦任务完成，您就需要隐藏掉任务指示器。</p>
<p>这将可能使用委托来完成这些：您需要创建一个合适的委托协议，实现必须的方法，设置您的对象为任务的委托，然后等待您的对象在任务完成时调用委托方法。</p>
<p><code>Block</code>使这些变得更加容易，然而，因为你可以定义回调行为在你初始化任务的时候，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)fetchRemoteInformation:(id)sender &#123;</span><br><span class="line">    [self showProgressIndicator];</span><br><span class="line">    XYZWebTask *task = ...</span><br><span class="line">    [task beginTaskWithCallbackBlock:^&#123;</span><br><span class="line">        [self hideProgressIndicator];</span><br><span class="line">&#125;]; &#125;</span><br></pre></td></tr></table></figure>
<p>这个例子调用了一个方法来显示进度指示器，然后创建任务并开始。回调的<code>block</code>指定了在任务完成后执行的代码；在这种情况下，它只是调用了一个方法来隐藏进度指示器。要注意，这个回调<code>block</code>为了能够调用<code>hideProgressIndicator</code>方法而捕获了<code>self</code>。有一点非常重要的是在捕获<code>self</code>时要非常注意，因为它会造成<code>strong reference cycle</code>。</p>
<p>在代码的可读性方面，<code>block</code>使得很容易在一个地方看出在任务完成之前和之后会发生什么，避免了需要通过跟踪委托方法来找出发生了什么事情。</p>
<p>下面是<code>beginTaskWithCallbackBlock:</code>方法的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)beginTaskWithCallbackBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))callbackBlock;</span><br></pre></td></tr></table></figure>
<p><code>(void (^)(void))</code>指定了这个参数是一个不接受任何参数也没有返回值的<code>block</code>。该方法的实现可以以通常的方式来调用<code>block</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)beginTaskWithCallbackBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))callbackBlock &#123;</span><br><span class="line">    ...</span><br><span class="line">    callbackBlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="block必须为方法的最后的参数">block必须为方法的最后的参数</h3><p>在方法中只使用一个<code>block</code>参数通常是最好的做法。如果一个方法同样需要其他的非<code>block</code>参数，那么<code>block</code>应该放在最后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">￼- (<span class="keyword">void</span>)beginTaskWithName:(NSString *)name completion:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))callback</span><br></pre></td></tr></table></figure>
<p>这也使得在方法调用时代码具有更好的可读性，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self beginTaskWithName:@<span class="string">"MyTask"</span> completion:^&#123;</span><br><span class="line">    NSLog(@<span class="string">"The task is complete"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="使用类型定义简化block语法">使用类型定义简化block语法</h2><p>如果你需要定义不只一个<code>block</code>，且它们具有相同的签名，你可能想定义自己的类型签名。</p>
<p>作为一个例子，你可以定义一个没有参数也没有返回值的简单<code>block</code>类型，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(^XYZSimpleBlock)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>然后你就可以使用你的自定义类型来创建<code>block</code>了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XYZSimpleBlock anotherBlock = ^&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="对象使用属性来记录block">对象使用属性来记录block</h2><p>该语法定义了一个属性来记录一个<code>block</code>，这很类似一个<code>block</code>变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface XYZObject : NSObject</span><br><span class="line">@property (copy) <span class="keyword">void</span> (^blockProperty)(<span class="keyword">void</span>);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>一个<code>block</code>属性就像其他<code>block</code>变量一样被设置和调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.blockProperty = ^&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">self.blockProperty();</span><br></pre></td></tr></table></figure>
<p>同样可能使用类型定义来定义<code>block</code>属性声明，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(^XYZSimpleBlock)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">@interface XYZObject : NSObject</span><br><span class="line">@property (copy) XYZSimpleBlock blockProperty;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h2 id="捕获self时避免Strong_Reference_Cycles">捕获self时避免Strong Reference Cycles</h2><p>如果你需要在<code>block</code>中捕获<code>self</code>，例如，当定义一个回调<code>block</code>，有一点非常重要当是要考虑内存管理的影响。</p>
<p><code>Block</code>保持对任何捕获对象的强引用，也包括<code>self</code>，这意味着最后很容易造成强引用循环，例如，一个对象为一个<code>block</code>保持为一个<code>copy</code>属性然后捕获了<code>self</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface XYZBlockKeeper : NSObject</span><br><span class="line">@property (copy) <span class="keyword">void</span> (^block)(<span class="keyword">void</span>);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@implementation XYZBlockKeeper</span><br><span class="line">- (<span class="keyword">void</span>)configureBlock &#123;</span><br><span class="line">	self.block = ^&#123;</span><br><span class="line">          [self doSomething];</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">... @end</span><br></pre></td></tr></table></figure>
<p>编译器会警告你一个简单的例子是这样的，但更复杂的例子可能涉及到对象创建周期之间的多个强引用，使之更难以诊断。</p>
<p>为了避免这个问题，捕获一个对<code>self</code>对弱引用是最好的办法，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)configureBlock &#123;</span><br><span class="line">    XYZBlockKeeper * __weak weakSelf = self;</span><br><span class="line">    self.block = ^&#123;</span><br><span class="line">        [weakSelf doSomething];   <span class="comment">// capture the weak reference</span></span><br><span class="line">                                  <span class="comment">// to avoid the reference cycle</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Block简化枚举">Block简化枚举</h2><p>除了一般的完成处理，许多<code>Cocoa</code>和<code>Cocoa Touch API</code>使用<code>block</code>来简化常用的任务，如集合枚举。<code>NSArray</code>类，例如，提供了三个基于<code>block</code>的方法，包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)enumerateObjectsUsingBlock:(<span class="keyword">void</span> (^)(id obj, NSUInteger idx, BOOL</span><br><span class="line">*stop))block;</span><br></pre></td></tr></table></figure>
<p>该方法接受一个参数，它是一个<code>block</code>会被数组中的每一个元素调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSArray *<span class="built_in">array</span> = ...</span><br><span class="line">[<span class="built_in">array</span> enumerateObjectsUsingBlock:^ (id obj, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">    NSLog(@<span class="string">"Object at index %lu is %@"</span>, idx, obj);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="Block简化并发任务">Block简化并发任务</h2><p><code>block</code>代表了一个工作的不同单位，结合可执行代码和从周围作用域捕获的可选状态。这使得它非常适用于在iOS和OS X中使用并发选项之一来异步调用。而不必弄清楚如何与低层次的机制工作，就像线程，您可以使用<code>block</code>简单地定义你的任务，然后让系统执行这些任务随着处理器资源可用。</p>
<p>OS X和iOS提供了各种技术的并发性，其中包括两个任务调度机制：操作队列和<code>Grand Central Dispatch</code>，这些机制围绕队列任务等待被执行的想法。您按照您想<code>block</code>执行的顺序将<code>blocks</code>添加到队列中，然后系统将它们出列直到处理器时间和资源可用。</p>
<p>串行队列只允许一个任务同时执行——队列中的下一个任务将不被出列并调用直到前一个任务已完成。并发队列调用尽可能多的任务，无需等待前一个任务来完成。</p>
<h3 id="使用Block操作与操作队列">使用Block操作与操作队列</h3><p>操作队列是<code>Cocoa</code>和<code>Cocoa Touch</code>的任务调度方式。你创建一个<code>NSOperation</code>实例为了封装工作单位以及任何必要的数据，然后将那个操作添加到<code>NSOperationQueue</code>执行。</p>
<p>尽管你创建了你自己的自定义<code>NSOperation</code>子类去实现复杂的任务，但还是可能去使用<code>NSBlockOperation</code>来用<code>block</code>创建一个操作，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这是可能手动去执行操作，但是操作可能通常被添加到一个已经存在到操作队列或你自己创建的一个队列，准备执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// schedule task on main queue:</span></span><br><span class="line">NSOperationQueue *mainQueue = [NSOperationQueue mainQueue];</span><br><span class="line">[mainQueue addOperation:operation];</span><br><span class="line"><span class="comment">// schedule task on background queue:</span></span><br><span class="line">NSOperationQueue *<span class="built_in">queue</span> = [[NSOperationQueue alloc] init];</span><br><span class="line">[<span class="built_in">queue</span> addOperation:operation];</span><br></pre></td></tr></table></figure>
<p>如果你使用一个操作队列，你可以在操作之间配置优先级和依赖，例如指定某个操作必须在其他一些操作执行后才能操作。</p>
<h3 id="调度Block在GCD的调度队列（Schedule_Blocks_on_Dispatch_Queues_with_Grand_Central_Dispatch）">调度Block在GCD的调度队列（Schedule Blocks on Dispatch Queues with Grand Central Dispatch）</h3><p>如果你需要调度执行代码的任意块，你可以直接使用被GCD（Grand Central Dispatch ）控制的调度队列，调度队列使得操作任务更加简单，不管是相对于调用者的同步或异步操作，且执行这些任务的顺序为先进先出。</p>
<p>你可以创建你自己的调度队列或使用GCD提供的队列。如果你需要调度一个任务为并发执行，例如，你可以通过<code>dispatch_get_global_queue()</code>获取一个存在队列的引用，和指定一个队列优先级，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>为了将<code>block</code>调度到队列，您可以使用<code>dispatch_async()</code>或<code>dispatch_sync()</code>函数。<code>dispatch_async()</code>函数是立即返回，不用去等待<code>block</code>的执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"Block for asynchronous execution"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/04/18/objectivec-block/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/04/18/objectivec-block/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/04/09/javascript-types/" title="JavaScript  类型与类型转换" itemprop="url">JavaScript  类型与类型转换</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-04-09T10:07:42.000Z" itemprop="datePublished"> 發表於 2015-04-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="类型">类型</h2><p><code>JavaScript</code>类型主要包括了<code>primitive</code>和<code>object</code>类型，其中<code>primitive</code>类型包括了：<code>null</code>、<code>undefined</code>、<code>boolean</code>、<code>number</code>、<code>string</code>和<code>symbol(es6)</code>。</p>
<p>参考链接：1. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures</a></p>
<ol>
<li><a href="http://www.w3.org/html/ig/zh/wiki/ES5/types" target="_blank" rel="external">http://www.w3.org/html/ig/zh/wiki/ES5/types</a></li>
</ol>
<h2 id="类型检测">类型检测</h2><p>说到类型检测主要包括了：<code>typeof</code>、<code>instanceof</code>和<code>Object.prototype.toString.call(xxx)或{}.toString.call(xxx)</code>。这里在玉伯的博文<a href="https://github.com/lifesinger/lifesinger.github.com/issues/175" target="_blank" rel="external">Sea.js 源码解析（三）</a>中有讨论过<code>Object.prototype.toString.call(xxx)或{}.toString.call(xxx)</code>哪一个更好，有兴趣的可以看一看。</p>
<h3 id="typeof">typeof</h3><p><code>typeof</code>一般适用于判断<code>primitive</code>类型的数据，在判断<code>object</code>类型的数据时有时会有意想不到的结果，例如：<code>typeof null</code>结果为<code>object</code>。下面的表是<code>typeof</code>元素符的一个结果：</p>
<table>
<thead>
<tr>
<th>val 类型</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Undefined</td>
<td>“undefined”</td>
</tr>
<tr>
<td>Null</td>
<td>“object”</td>
</tr>
<tr>
<td>Boolean</td>
<td>“boolean”</td>
</tr>
<tr>
<td>Number</td>
<td>“number”</td>
</tr>
<tr>
<td>String</td>
<td>“string”</td>
</tr>
<tr>
<td>Object（原生，且没有实现 [[Call]]）</td>
<td>“object”</td>
</tr>
<tr>
<td>Object（原生或者宿主且实现了 [[Call]]）</td>
<td>“function”</td>
</tr>
<tr>
<td>Object（宿主且没实现 [[Call]]）</td>
<td>由实现定义，但不能是 “undefined”、”boolean”、”number” 或 “string”。</td>
</tr>
</tbody>
</table>
<p>这里还有一篇相关介绍<code>typeof</code>的文章：<a href="http://blog.alexanderdickson.com/javascript-typeof" target="_blank" rel="external">JavaScript’s typeof operator</a><br>也可以看ES5中关于<code>typeof</code>的介绍：<a href="http://www.w3.org/html/ig/zh/wiki/ES5/expressions#typeof_.E8.BF.90.E7.AE.97.E7.AC.A6" target="_blank" rel="external">typeof 运算符</a></p>
<h3 id="instanceof">instanceof</h3><p><code>instanceof</code>运算符是用于判断一个实例是否属于某一类型，例如：<code>a instanceof Person</code>，其内部原理实际上是判断<code>Person.prototype</code>是否在<code>a</code>实例的原型链中，其原理可以用下面的函数来表达：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance_of</span><span class="params">(V, F)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> O = F.prototype;</span><br><span class="line">  V = V.__proto__;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (V === <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (O === V)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    V = V.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>V8</code>源码的<code>runtime.js</code>中也有关于<code>instanceof</code>运算符的描述：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMA-262, section 11.8.6, page 54. To make the implementation more</span></span><br><span class="line"><span class="comment">// efficient, the return value should be zero if the 'this' is an</span></span><br><span class="line"><span class="comment">// instance of F, and non-zero if not. This makes it possible to avoid</span></span><br><span class="line"><span class="comment">// an expensive ToBoolean conversion in the generated code.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">INSTANCE_OF</span><span class="params">(F)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> V = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (!IS_SPEC_FUNCTION(F)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> %MakeTypeError(<span class="string">'instanceof_function_expected'</span>, [F]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If V is not an object, return false.</span></span><br><span class="line">  <span class="keyword">if</span> (!IS_SPEC_OBJECT(V)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if function is bound, if so, get [[BoundFunction]] from it</span></span><br><span class="line">  <span class="comment">// and use that instead of F.</span></span><br><span class="line">  <span class="keyword">var</span> bindings = %BoundFunctionGetBindings(F);</span><br><span class="line">  <span class="keyword">if</span> (bindings) &#123;</span><br><span class="line">    F = bindings[kBoundFunctionIndex];  <span class="comment">// Always a non-bound function.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Get the prototype of F; if it is not an object, throw an error.</span></span><br><span class="line">  <span class="keyword">var</span> O = F.prototype;</span><br><span class="line">  <span class="keyword">if</span> (!IS_SPEC_OBJECT(O)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> %MakeTypeError(<span class="string">'instanceof_nonobject_proto'</span>, [O]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return whether or not O is in the prototype chain of V.</span></span><br><span class="line">  <span class="keyword">return</span> %IsInPrototypeChain(O, V) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Object-prototype-toString-call(xxx)或{}-toString-call(xxx)">Object.prototype.toString.call(xxx)或{}.toString.call(xxx)</h3><p>这两个的区别在<a href="http://blog.alexanderdickson.com/javascript-typeof" target="_blank" rel="external">JavaScript’s typeof operator</a>中有说到：<code>You can always swap {} with Object.prototype, to save creating an object just to exploit its toString() method.</code>。也就是使用<code>Object.prototype.toString</code>会节省创建一个对象。</p>
<p>实际在使用时<code>Object.prototype.toString.call(xxx)</code>会返回类似<code>[object String]</code>的字符串给我们，用他我们就可以很好的判断变量的类型了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'sss'</span>;</span><br><span class="line"><span class="keyword">var</span> b = [];</span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(a))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(b))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(c))</span><br></pre></td></tr></table></figure>
<h2 id="类型转换">类型转换</h2><p>类型转换主要分为两大类：<code>ToPrimitive</code>和<code>ToObject</code>。其中<code>ToPrimitive</code>又分为了：<code>ToNumber</code>、<code>ToString</code>和<code>ToBoolean</code>。</p>
<h3 id="ToPrimitive">ToPrimitive</h3><p>看名字就能知道，<code>ToPrimitive</code>是用于变量需要转换为原始类型时调用。在<code>JavaScript</code>内部实现了该函数，在需要将变量转换为原始类型时就会调用该函数，下面看一下它的源代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMA-262, section 9.1, page 30. Use null/undefined for no hint,</span></span><br><span class="line"><span class="comment">// (1) for number hint, and (2) for string hint.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToPrimitive</span><span class="params">(x, hint)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Fast case check.</span></span><br><span class="line">  <span class="comment">// 如果为字符串，则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (IS_STRING(x)) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="comment">// Normal behavior.</span></span><br><span class="line">  <span class="keyword">if</span> (!IS_SPEC_OBJECT(x)) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">if</span> (IS_SYMBOL_WRAPPER(x)) <span class="keyword">throw</span> MakeTypeError(<span class="string">'symbol_to_primitive'</span>, []);</span><br><span class="line">  <span class="keyword">if</span> (hint == NO_HINT) hint = (IS_DATE(x)) ? STRING_HINT : NUMBER_HINT;</span><br><span class="line">  <span class="keyword">return</span> (hint == NUMBER_HINT) ? %DefaultNumber(x) : %DefaultString(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面有一个<code>hint</code>的参数，当没有传入<code>hint</code>参数时，且<code>x</code>不是<code>Date</code>对象时会通过<code>%DefaultNumber(x)</code>来转换，否则通过<code>%DefaultString(x)</code>。这里也可以看到日期类型的对象转换为原始类型时的不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMA-262, section 8.6.2.6, page 28.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DefaultNumber</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!IS_SYMBOL_WRAPPER(x)) &#123;</span><br><span class="line">    <span class="comment">// 转换为数字原始类型时，首先通过valueOf来转换</span></span><br><span class="line">    <span class="keyword">var</span> valueOf = x.valueOf;</span><br><span class="line">    <span class="keyword">if</span> (IS_SPEC_FUNCTION(valueOf)) &#123;</span><br><span class="line">      <span class="keyword">var</span> v = %_CallFunction(x, valueOf);</span><br><span class="line">      <span class="keyword">if</span> (%IsPrimitive(v)) <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则通过toString</span></span><br><span class="line">    <span class="keyword">var</span> toString = x.toString;</span><br><span class="line">    <span class="keyword">if</span> (IS_SPEC_FUNCTION(toString)) &#123;</span><br><span class="line">      <span class="keyword">var</span> s = %_CallFunction(x, toString);</span><br><span class="line">      <span class="keyword">if</span> (%IsPrimitive(s)) <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则抛出异常</span></span><br><span class="line">  <span class="keyword">throw</span> %MakeTypeError(<span class="string">'cannot_convert_to_primitive'</span>, []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ECMA-262, section 8.6.2.6, page 28.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DefaultString</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!IS_SYMBOL_WRAPPER(x)) &#123;</span><br><span class="line">    <span class="comment">// 转换为字符串原始类型时首先通过toString</span></span><br><span class="line">    <span class="keyword">var</span> toString = x.toString;</span><br><span class="line">    <span class="keyword">if</span> (IS_SPEC_FUNCTION(toString)) &#123;</span><br><span class="line">      <span class="keyword">var</span> s = %_CallFunction(x, toString);</span><br><span class="line">      <span class="keyword">if</span> (%IsPrimitive(s)) <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则通过valueOf</span></span><br><span class="line">    <span class="keyword">var</span> valueOf = x.valueOf;</span><br><span class="line">    <span class="keyword">if</span> (IS_SPEC_FUNCTION(valueOf)) &#123;</span><br><span class="line">      <span class="keyword">var</span> v = %_CallFunction(x, valueOf);</span><br><span class="line">      <span class="keyword">if</span> (%IsPrimitive(v)) <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则抛出异常</span></span><br><span class="line">  <span class="keyword">throw</span> %MakeTypeError(<span class="string">'cannot_convert_to_primitive'</span>, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ToNumber">ToNumber</h4><p><code>ToNumber</code>是用于将变量转换为<code>number</code>类型，它在<code>V8</code>中的实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMA-262, section 9.3, page 31.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToNumber</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果为number直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (IS_NUMBER(x)) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="comment">// 如果为字符串，则调用StringToNumber转换</span></span><br><span class="line">  <span class="keyword">if</span> (IS_STRING(x)) &#123;</span><br><span class="line">    <span class="keyword">return</span> %_HasCachedArrayIndex(x) ? %_GetCachedArrayIndex(x)</span><br><span class="line">                                    : %StringToNumber(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (IS_BOOLEAN(x)) <span class="keyword">return</span> x ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 如果为undefined，则返回NAN</span></span><br><span class="line">  <span class="keyword">if</span> (IS_UNDEFINED(x)) <span class="keyword">return</span> NAN;</span><br><span class="line">  <span class="comment">// 如果为symbol，则抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (IS_SYMBOL(x)) <span class="keyword">throw</span> MakeTypeError(<span class="string">'symbol_to_number'</span>, []);</span><br><span class="line">  <span class="comment">// 如果为null或</span></span><br><span class="line">  <span class="keyword">return</span> (IS_NULL(x)) ? <span class="number">0</span> : ToNumber(%DefaultNumber(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ToString">ToString</h4><p><code>ToString</code>是用于将变量转换为<code>string</code>类型，它在<code>V8</code>中的实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMA-262, section 9.8, page 35.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToString</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果为string，则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (IS_STRING(x)) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="comment">// 如果为number，则调用_NumberToString</span></span><br><span class="line">  <span class="keyword">if</span> (IS_NUMBER(x)) <span class="keyword">return</span> %_NumberToString(x);</span><br><span class="line">  <span class="comment">// 如果为boolean</span></span><br><span class="line">  <span class="keyword">if</span> (IS_BOOLEAN(x)) <span class="keyword">return</span> x ? <span class="string">'true'</span> : <span class="string">'false'</span>;</span><br><span class="line">  <span class="comment">// 如果为undefined，则返回undefined字符串</span></span><br><span class="line">  <span class="keyword">if</span> (IS_UNDEFINED(x)) <span class="keyword">return</span> <span class="string">'undefined'</span>;</span><br><span class="line">  <span class="comment">// 如果为symbol，则抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (IS_SYMBOL(x)) <span class="keyword">throw</span> %MakeTypeError(<span class="string">'symbol_to_string'</span>, []);</span><br><span class="line">  <span class="comment">// 如果为null，或者对象</span></span><br><span class="line">  <span class="keyword">return</span> (IS_NULL(x)) ? <span class="string">'null'</span> : %ToString(%DefaultString(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ToBoolean">ToBoolean</h4><p><code>ToBoolean</code>是用于将变量转换为<code>boolean</code>类型，它在<code>V8</code>中的实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMA-262, section 9.2, page 30</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToBoolean</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果为boolean，则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (IS_BOOLEAN(x)) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="comment">// 如果为string，则当字符串长度不为0时返回true</span></span><br><span class="line">  <span class="keyword">if</span> (IS_STRING(x)) <span class="keyword">return</span> x.length != <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 如果为null，返回false</span></span><br><span class="line">  <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 如果为number，当number不为0，且不为NAN时返回true</span></span><br><span class="line">  <span class="keyword">if</span> (IS_NUMBER(x)) <span class="keyword">return</span> !((x == <span class="number">0</span>) || NUMBER_IS_NAN(x));</span><br><span class="line">  <span class="comment">// 否则返回true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ToObject">ToObject</h3><p><code>ToObject</code>是用于变量需要转换为对象时调用。在<code>JavaScript</code>内部实现了该函数，在需要将变量转换为对象时就会调用该函数，下面看一下它的源代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMA-262, section 9.9, page 36.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToObject</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (IS_STRING(x)) <span class="keyword">return</span> <span class="keyword">new</span> $<span class="built_in">String</span>(x);</span><br><span class="line">  <span class="keyword">if</span> (IS_NUMBER(x)) <span class="keyword">return</span> <span class="keyword">new</span> $<span class="built_in">Number</span>(x);</span><br><span class="line">  <span class="keyword">if</span> (IS_BOOLEAN(x)) <span class="keyword">return</span> <span class="keyword">new</span> $<span class="built_in">Boolean</span>(x);</span><br><span class="line">  <span class="keyword">if</span> (IS_SYMBOL(x)) <span class="keyword">return</span> %NewSymbolWrapper(x);</span><br><span class="line">  <span class="comment">// 如果为null或undefined，抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (IS_NULL_OR_UNDEFINED(x) &amp;&amp; !IS_UNDETECTABLE(x)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> %MakeTypeError(<span class="string">'undefined_or_null_to_object'</span>, []);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ADD">ADD</h2><p>在<code>+</code>运算时也会涉及到类型转换，例如有面试题：<code>{} + 1</code>或<code>new Date() + 1</code>返回什么呢？这就要看看我们<code>V8</code>引擎内部是怎么对加法进行运算的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMA-262, section 11.6.1, page 50.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ADD</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Fast case: Check for number operands and do the addition.</span></span><br><span class="line">  <span class="comment">// 如果都为number或string，则直接调用NumberAdd或_StringAdd</span></span><br><span class="line">  <span class="keyword">if</span> (IS_NUMBER(<span class="keyword">this</span>) &amp;&amp; IS_NUMBER(x)) <span class="keyword">return</span> %NumberAdd(<span class="keyword">this</span>, x);</span><br><span class="line">  <span class="keyword">if</span> (IS_STRING(<span class="keyword">this</span>) &amp;&amp; IS_STRING(x)) <span class="keyword">return</span> %_StringAdd(<span class="keyword">this</span>, x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Default implementation.</span></span><br><span class="line">  <span class="comment">// 否则将两边操作数分别转换为原始类型</span></span><br><span class="line">  <span class="keyword">var</span> a = %ToPrimitive(<span class="keyword">this</span>, NO_HINT);</span><br><span class="line">  <span class="keyword">var</span> b = %ToPrimitive(x, NO_HINT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (IS_STRING(a)) &#123;</span><br><span class="line">    <span class="keyword">return</span> %_StringAdd(a, %ToString(b));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_STRING(b)) &#123;</span><br><span class="line">    <span class="keyword">return</span> %_StringAdd(%NonStringToString(a), b);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> %NumberAdd(%ToNumber(a), %ToNumber(b));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在操作数有一个不为number或string时，<code>ADD</code>操作就会将相应的操作数转换为原始类型，然后再进行相应的加法操作，可以看到上面的<code>{} + 1</code>，<code>{}</code>不为原始类型，所以就会调用<code>ToPrimitive({})</code>和<code>ToPrimitive(1)</code>，<code>ToPrimitive({})</code>调用的结果为<code>[object Object]</code>，所以最后会进行<code>_StringAdd</code>操作，最后的结果是：<code>[object Object]1</code>。</p>
<h2 id="Equals">Equals</h2><p>相等操作也会在某些情况下进行相应的类型转换，所以可以看看它的内部实现是怎样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMA-262 Section 11.9.3.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EQUALS</span><span class="params">(y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (IS_STRING(<span class="keyword">this</span>) &amp;&amp; IS_STRING(y)) <span class="keyword">return</span> %StringEquals(<span class="keyword">this</span>, y);</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果x为number</span></span><br><span class="line">    <span class="keyword">if</span> (IS_NUMBER(x)) &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IS_NUMBER(y)) <span class="keyword">return</span> %NumberEquals(x, y);</span><br><span class="line">        <span class="keyword">if</span> (IS_NULL_OR_UNDEFINED(y)) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// not equal</span></span><br><span class="line">        <span class="keyword">if</span> (IS_SYMBOL(y)) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// not equal</span></span><br><span class="line">        <span class="keyword">if</span> (!IS_SPEC_OBJECT(y)) &#123;</span><br><span class="line">          <span class="comment">// String or boolean.</span></span><br><span class="line">          <span class="keyword">return</span> %NumberEquals(x, %ToNumber(y));</span><br><span class="line">        &#125;</span><br><span class="line">        y = %ToPrimitive(y, NO_HINT);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_STRING(x)) &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IS_STRING(y)) <span class="keyword">return</span> %StringEquals(x, y);</span><br><span class="line">        <span class="keyword">if</span> (IS_SYMBOL(y)) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// not equal</span></span><br><span class="line">        <span class="keyword">if</span> (IS_NUMBER(y)) <span class="keyword">return</span> %NumberEquals(%ToNumber(x), y);</span><br><span class="line">        <span class="keyword">if</span> (IS_BOOLEAN(y)) <span class="keyword">return</span> %NumberEquals(%ToNumber(x), %ToNumber(y));</span><br><span class="line">        <span class="keyword">if</span> (IS_NULL_OR_UNDEFINED(y)) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// not equal</span></span><br><span class="line">        y = %ToPrimitive(y, NO_HINT);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_SYMBOL(x)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (IS_SYMBOL(y)) <span class="keyword">return</span> %_ObjectEquals(x, y) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// not equal</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_BOOLEAN(x)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (IS_BOOLEAN(y)) <span class="keyword">return</span> %_ObjectEquals(x, y) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (IS_NULL_OR_UNDEFINED(y)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (IS_NUMBER(y)) <span class="keyword">return</span> %NumberEquals(%ToNumber(x), y);</span><br><span class="line">      <span class="keyword">if</span> (IS_STRING(y)) <span class="keyword">return</span> %NumberEquals(%ToNumber(x), %ToNumber(y));</span><br><span class="line">      <span class="keyword">if</span> (IS_SYMBOL(y)) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// not equal</span></span><br><span class="line">      <span class="comment">// y is object.</span></span><br><span class="line">      x = %ToNumber(x);</span><br><span class="line">      y = %ToPrimitive(y, NO_HINT);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_NULL_OR_UNDEFINED(x)) &#123;</span><br><span class="line">      <span class="keyword">return</span> IS_NULL_OR_UNDEFINED(y) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// x is an object.</span></span><br><span class="line">      <span class="keyword">if</span> (IS_SPEC_OBJECT(y)) &#123;</span><br><span class="line">        <span class="keyword">return</span> %_ObjectEquals(x, y) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (IS_NULL_OR_UNDEFINED(y)) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// not equal</span></span><br><span class="line">      <span class="keyword">if</span> (IS_SYMBOL(y)) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// not equal</span></span><br><span class="line">      <span class="keyword">if</span> (IS_BOOLEAN(y)) y = %ToNumber(y);</span><br><span class="line">      x = %ToPrimitive(x, NO_HINT);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码逻辑大概是这样的：</p>
<ol>
<li>如果有一个操作数为string，则执行<code>StringEquals</code>操作</li>
<li>否则，如果第一个操作数为number，如果另外一个操作数为原始类型（非null和undefined），则将其执行<code>ToNumber</code>，并进行<code>NumberEquals</code>，如果为<code>null</code>和<code>undefined</code>则返回<code>false</code>，如果为对象类型，则将该操作数执行<code>ToPrimitive</code>后再重复以上步骤</li>
<li>否则，如果第一个操作数为string，如果另外一个操作数也为string，则进行<code>StringEquals</code>，如果为number或<code>boolean</code>，则将第一个操作数执行<code>ToNumber</code>，再进行<code>NumberEquals</code>，如果为<code>null</code>和<code>undefined</code>则返回<code>false</code>，如果为对象类型，则将该操作数执行<code>ToPrimitive</code>后再重复以上步骤</li>
<li>否则如果第一个操作数为boolean，如果另外一个操作数也为<code>boolean</code>，则进行<code>_ObjectEquals</code>，否则如果为string或number，则进行<code>NumberEquals</code>，如果为<code>null</code>和<code>undefined</code>则返回<code>false</code>，如果为对象类型，则将该操作数执行<code>ToPrimitive</code>后再重复以上步骤</li>
<li>如果第一个操作数为对象类型，则将其<code>ToPrimitive</code>，在重复以上步骤</li>
</ol>
<p>例如有个面试题是这样的<code>[] == ![]</code>，是<code>true</code>还是<code>false</code>，我们首先看右边的<code>![]</code>，空数组转换为boolean是<code>true</code>的，再进行<code>!</code>，可以知道右边的<code>![]</code>为<code>false</code>，当一个对象和boolean进行<code>equal</code>时，<code>[]</code>会进行<code>ToPrimitive</code>，这里就会首先调用<code>Array.prototype.valueOf</code>，调用后返回的是<code>[]</code>，不是原始类型，再进行<code>Array.prototype.toString</code>，这里返回了<code>&quot;&quot;</code>空字符，空字符和<code>false</code>进行相等比较这里就是<code>true</code>了。</p>
<h2 id="Compare">Compare</h2><p>什么是<code>Compare</code>呢，就是<code>&gt; &lt; &lt;=</code>这些操作都是<code>compare</code>，<code>compare</code>也会涉及到类型转换的操作，我们这里看内部<code>compare</code>是怎么实现的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMA-262, section 11.8.5, page 53. The 'ncr' parameter is used as</span></span><br><span class="line"><span class="comment">// the result when either (or both) the operands are NaN.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">COMPARE</span><span class="params">(x, ncr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> left;</span><br><span class="line">  <span class="keyword">var</span> right;</span><br><span class="line">  <span class="comment">// Fast cases for string, numbers and undefined compares.</span></span><br><span class="line">  <span class="keyword">if</span> (IS_STRING(<span class="keyword">this</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (IS_STRING(x)) <span class="keyword">return</span> %_StringCompare(<span class="keyword">this</span>, x);</span><br><span class="line">    <span class="keyword">if</span> (IS_UNDEFINED(x)) <span class="keyword">return</span> ncr;</span><br><span class="line">    left = <span class="keyword">this</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_NUMBER(<span class="keyword">this</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (IS_NUMBER(x)) <span class="keyword">return</span> %NumberCompare(<span class="keyword">this</span>, x, ncr);</span><br><span class="line">    <span class="keyword">if</span> (IS_UNDEFINED(x)) <span class="keyword">return</span> ncr;</span><br><span class="line">    left = <span class="keyword">this</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_UNDEFINED(<span class="keyword">this</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!IS_UNDEFINED(x)) &#123;</span><br><span class="line">      %ToPrimitive(x, NUMBER_HINT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ncr;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_UNDEFINED(x)) &#123;</span><br><span class="line">    %ToPrimitive(<span class="keyword">this</span>, NUMBER_HINT);</span><br><span class="line">    <span class="keyword">return</span> ncr;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    left = %ToPrimitive(<span class="keyword">this</span>, NUMBER_HINT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  right = %ToPrimitive(x, NUMBER_HINT);</span><br><span class="line">  <span class="keyword">if</span> (IS_STRING(left) &amp;&amp; IS_STRING(right)) &#123;</span><br><span class="line">    <span class="keyword">return</span> %_StringCompare(left, right);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left_number = %ToNumber(left);</span><br><span class="line">    <span class="keyword">var</span> right_number = %ToNumber(right);</span><br><span class="line">    <span class="keyword">if</span> (NUMBER_IS_NAN(left_number) || NUMBER_IS_NAN(right_number)) <span class="keyword">return</span> ncr;</span><br><span class="line">    <span class="keyword">return</span> %NumberCompare(left_number, right_number, ncr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>compare</code>操作相对于<code>equal</code>还是相对来说简单一点的，它首先会判断第一个操作数，如果为对象则将其<code>ToPrimitive</code>，否则如果两个操作数都为<code>string</code>时，进行<code>_StringCompare</code>，否则，将两个操作数都<code>ToNumber</code>再进行<code>NumberCompare</code>。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScript/">JavaScript</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/04/09/javascript-types/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/04/09/javascript-types/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/02/05/css-selectors/" title="CSS 选择器" itemprop="url">CSS 选择器</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-02-05T08:47:42.000Z" itemprop="datePublished"> 發表於 2015-02-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文是从<a href="http://www.w3.org/TR/css3-selectors/#selector-syntax" target="_blank" rel="external">Selectors Level 3</a>提取出的一些重点，如有不懂的地方可以看原文对照。</p>
<h2 id="1-_选择器语法">1. 选择器语法</h2><p>一个选择器是一个或多个被<a href="http://www.w3.org/TR/css3-selectors/#combinators" target="_blank" rel="external">连结符</a>分隔的简单选择器序列组成的链。一个<a href="http://www.w3.org/TR/css3-selectors/#pseudo-elements" target="_blank" rel="external">伪元素</a>可能会附加到选择器中的最后一个简单选择器序列。</p>
<p>一个简单选择器序列是没有被<a href="http://www.w3.org/TR/css3-selectors/#combinators" target="_blank" rel="external">连结符</a>分隔的<a href="http://www.w3.org/TR/css3-selectors/#simple-selectors-dfn" target="_blank" rel="external">简单选择器</a>组成的链。它总是以一个<a href="http://www.w3.org/TR/css3-selectors/#type-selectors" target="_blank" rel="external">类型选择器</a>或<a href="http://www.w3.org/TR/css3-selectors/#universal-selector" target="_blank" rel="external">通用选择器</a>开始。除了类型选择器和通用选择器，没有其他类型的选择器允许在序列中。</p>
<p>一个简单选择器可以是<a href="http://www.w3.org/TR/css3-selectors/#type-selectors" target="_blank" rel="external">类型选择器</a>，<a href="http://www.w3.org/TR/css3-selectors/#universal-selector" target="_blank" rel="external">通用选择器</a>，<a href="http://www.w3.org/TR/css3-selectors/#attribute-selectors" target="_blank" rel="external">属性选择器</a>，<a href="http://www.w3.org/TR/css3-selectors/#class-html" target="_blank" rel="external">类选择器</a>，<a href="http://www.w3.org/TR/css3-selectors/#id-selectors" target="_blank" rel="external">id选择器</a>或<a href="http://www.w3.org/TR/css3-selectors/#pseudo-classes" target="_blank" rel="external">伪类</a>。</p>
<p>连结符可以是：空白、<code>&gt;</code>、<code>+</code>、<code>~</code>。</p>
<p>一个文档树的元素被选择器所代表，它是选择器的主题（subject）。一个选择器组成了一个简单选择器的单一序列，代表了任何满足它需求的元素。前面加上其他的简单选择器序列，且序列中的连结符施加了额外的匹配限制，所以一个选择器的主题总是最后一个简单选择器序列所代表的元素的子集。</p>
<p>一个空的选择器，没有包含简单选择器序列和伪元素，是一个<a href="http://www.w3.org/TR/css3-selectors/#Conformance" target="_blank" rel="external">无效的选择器</a>。</p>
<p>选择器中的字符可以根据在<code>CSS2</code>中相同的<a href="http://www.w3.org/TR/CSS21/syndata.html#characters" target="_blank" rel="external">转义规则</a>并通过<code>\</code>来转义。</p>
<h2 id="2-_选择器组">2.  选择器组</h2><p>一个逗号分隔的选择器列表表示了被任何单一选择器选择的所有元素的组合。例如，在<code>CSS</code>中当一些选择器共享相同的声明时，它们可以组合成一个逗号分隔的列表。空格可能出现在逗号的前面或后面。</p>
<p><strong><code>CSS</code>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">h1</span> <span class="rules">&#123; <span class="rule"><span class="attribute">font-family</span>:<span class="value"> sans-serif &#125;</span><br><span class="line">h2 &#123; font-family: sans-serif &#125;</span><br><span class="line">h3 &#123; font-family: sans-serif &#125;</span></span></span></span><br></pre></td></tr></table></figure>
<p>上面等价于：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">h1</span>, <span class="tag">h2</span>, <span class="tag">h3</span> <span class="rules">&#123; <span class="rule"><span class="attribute">font-family</span>:<span class="value"> sans-serif &#125;</span></span></span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>在本例中等价是真的，因为所有的选择器是有效的选择器。如果选择器中的一个是无效的选择器，那么整个声明是无效的。</p>
<p>无效的<code>CSS</code>实例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">h1</span> <span class="rules">&#123; <span class="rule"><span class="attribute">font-family</span>:<span class="value"> sans-serif &#125;</span><br><span class="line">h2..foo &#123; font-family: sans-serif &#125;</span><br><span class="line">h3 &#123; font-family: sans-serif &#125;</span></span></span></span><br></pre></td></tr></table></figure>
<p>不等价于：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">h1</span>, <span class="tag">h2</span>.<span class="class">.foo</span>, <span class="tag">h3</span> <span class="rules">&#123; <span class="rule"><span class="attribute">font-family</span>:<span class="value"> sans-serif &#125;</span></span></span></span><br></pre></td></tr></table></figure>
<p>在实际应用中也没有人这样写了。否则肯定早晚开除了。</p>
<h2 id="3-_简单选择器">3. 简单选择器</h2><h3 id="3-1_类型选择器">3.1 类型选择器</h3><p>一个类型选择器是文档语言元素类型的名称，并使用<a href="http://www.w3.org/TR/css3-namespace/#css-qnames" target="_blank" rel="external">CSS qualified names</a>语法。一个类型选择器表示了在文档树中元素类型的实例。</p>
<p><strong>实例</strong>：</p>
<p>以下的选择器表示了在文档树中的<code>h1</code>元素：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">h1</span></span><br></pre></td></tr></table></figure>
<h4 id="3-1-1_类型选择器和命名空间">3.1.1 类型选择器和命名空间</h4><p>类型选择器允许一个可选的命名空间组件：一个命名空间前缀被定义在元素名的前面，并通过<code>|</code>符号来分隔。</p>
<p>命名空间可能为空，代表了选择器没有命名空间。</p>
<p>一个<code>*</code>可被用作为命名空间前缀，表明代表了元素的所有命名空间。</p>
<p>元素类型选择器在没有命名空间组件时代表了元素不会考虑元素的命名空间（等价于<code>*|</code>），除非定义了一个默认的命名空间。如果一个默认命名空间被声明，这些元素会代表在默认命名空间中的元素。</p>
<p>那怎么定义默认命名空间呢？</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">namespace</span> <span class="string">"http://www.w3.org/1999/xhtml"</span></span>;</span><br><span class="line"><span class="at_rule">@<span class="keyword">namespace</span> svg <span class="string">"http://www.w3.org/2000/svg"</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面的<code>http://www.w3.org/1999/xhtml</code>就为默认的命名空间。</p>
<p>总结(要注意的是<code>|</code>前后没有空格的哟)：</p>
<p><strong>ns|E</strong><br>元素为<code>E</code>且在命名空间<code>ns</code>中</p>
<p><strong>*|E</strong><br>元素为<code>E</code>且在任何命名空间中</p>
<p><strong>|E</strong><br>元素为<code>E</code>且没有命名空间</p>
<p><strong>E</strong><br>如果没有为选择器定义默认的命名空间，这个等价于<code>*|E</code>。否则等价于<code>ns|E</code>，且<code>ns</code>为默认的命名空间。</p>
<p><code>CSS</code>实例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@namespace foo url(http://www.example.com);</span><br><span class="line"> foo|h1 &#123; color: blue &#125;  /* first rule */</span><br><span class="line"> foo|* &#123; color: yellow &#125; /* second rule */</span><br><span class="line"> |h1 &#123; color: red &#125;      /* ...*/</span><br><span class="line"> *|h1 &#123; color: green &#125;</span><br><span class="line"> h1 &#123; color: green &#125;</span><br></pre></td></tr></table></figure>
<p>第一条规则只会匹配在<code>http://www.example.com</code>命名空间中的<code>h1</code>元素。<br>第二条规则会匹配在<code>http://www.example.com</code>命名空间中的所有元素。<br>第三条规则只会匹配没有命名空间的<code>h1</code>元素。<br>第四条规则会匹配在任何命名空间中的<code>h1</code>元素。<br>第五条规则等价于第四条规则，因为没有默认的命名空间被定义。</p>
<h3 id="3-2_通用选择器">3.2 通用选择器</h3><p>通用选择器，用<code>*</code>来表示，它代表了任何元素类型的限定名。它代表了在文档树中的任何命名空间的任何单一元素，如果没有为选择器指定默认的命名空间。如果指定了默认的命名空间，可以看下面的<a href="http://www.w3.org/TR/css3-selectors/#univnmsp" target="_blank" rel="external">通用选择器和命名空间</a>。</p>
<p>如果一个通用选择器不是选择器序列的唯一组件，或者它后面紧跟了<a href="http://www.w3.org/TR/css3-selectors/#pseudo-elements" target="_blank" rel="external">伪元素</a>，那么<code>*</code>可以省略，通用选择器隐含的表示存在。</p>
<p><strong>实例：</strong></p>
<ul>
<li><code>*[hreflang|=en]</code>和<code>[hreflang|=en]</code>是等价的</li>
<li><code>*.warning</code>和<code>.warning</code>是等价的</li>
<li><code>*#myid</code>和<code>#myid</code>是等价的</li>
</ul>
<h4 id="3-2-1_通用选择器和命名空间">3.2.1 通用选择器和命名空间</h4><p>通用选择器允许一个可选的命名空间组件。它可以按照以下方式来使用：</p>
<p><code>ns|*</code><br>在<code>ns</code>命名空间中的所有元素</p>
<p><code>*|*</code><br>所有元素</p>
<p><code>|*</code><br>所有没有命名空间的元素</p>
<p><code>*</code><br>如果没有默认指定默认的命名空间，则等价于<code>*|*</code>，否则等价于<code>ns|*</code>，如果<code>ns</code>为默认的命名空间。</p>
<h3 id="3-3_属性选择器">3.3 属性选择器</h3><p>选择器允许表示元素的属性。当选择器被用作为一个表达式来匹配元素时，属性选择器必须认为匹配元素如果元素有一个属性且匹配属性选择器所代表的属性时。</p>
<h4 id="3-3-1_属性存在和值选择器">3.3.1 属性存在和值选择器</h4><p><code>CSS2</code>介绍了四种属性选择器：</p>
<p><code>[att]</code><br>代表了元素有一个<code>att</code>属性，不管属性的值是什么。</p>
<p><code>[att=val]</code><br>代表了元素有一个<code>att</code>属性，且值为<code>val</code>。这种可以用于选择例如：<code>input[type=&quot;text&quot;]</code></p>
<p><code>[att~=val]</code><br>代表了元素有一个<code>att</code>属性，且它的值为空白分隔的列表，其中的一个值为<code>val</code>，如果选择器中的<code>val</code>包含了空白，它永远不会代表什么。同样，如果<code>val</code>为空字符串，它永远不会代表什么。</p>
<p><code>[att|=val]</code><br>代表了元素有一个<code>att</code>属性，且它的值为<code>val</code>或者<code>val</code>紧跟着<code>-</code>。</p>
<p><strong>实例：</strong></p>
<p>下面的属性选择器代表了<code>h1</code>元素，且它有一个<code>title</code>属性，且不管值为多少：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">h1</span><span class="attr_selector">[title]</span></span><br></pre></td></tr></table></figure>
<p>下面的例子选择器代表了一个<code>span</code>元素它的<code>class</code>属性的值为<code>example</code>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">span</span><span class="attr_selector">[class="example"]</span></span><br></pre></td></tr></table></figure>
<p>下面的选择器代表了一个<code>a</code>元素，且它的<code>hreflang</code>属性值为<code>en</code>或<code>en-US</code>等</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">a</span><span class="attr_selector">[hreflang|="en"]</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-2_子字符串匹配属性选择器">3.3.2 子字符串匹配属性选择器</h4><p>三个附加的属性选择器被提供给匹配属性值的子字符串：</p>
<p><code>[att^=val]</code><br>代表了元素有一个<code>att</code>属性，且值以<code>val</code>前缀开始。如果<code>val</code>为空字符串，则这个选择器不会代表任何元素</p>
<p><code>[att$=val]</code><br>代表了元素有一个<code>att</code>属性，且值以<code>val</code>后缀结束。如果<code>val</code>为空字符串，则这个选择器不会代表任何元素</p>
<p><code>[att*=val]</code><br>代表了元素有一个<code>att</code>属性，且值包含至少子字符串<code>val</code>的一个实例。如果<code>val</code>为空字符串，则这个选择器不会代表任何元素</p>
<p><strong>实例：</strong></p>
<p>下面的选择器代表了一个<code>HTML</code>的<code>object</code>，引用了一个图片：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">object</span><span class="attr_selector">[type^="image/"]</span></span><br></pre></td></tr></table></figure>
<p>下面的选择器代表了一个<code>HTML</code>链接<code>a</code>，且它的<code>href</code>属性以<code>.html</code>结尾：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">a</span><span class="attr_selector">[href$=".html"]</span></span><br></pre></td></tr></table></figure>
<p>下面的选择器代表了<code>HTML</code>段落中<code>title</code>属性包含了子字符串<code>hello</code>：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">p</span><span class="attr_selector">[title*="hello"]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-3_属性选择器和命名空间">3.3.3 属性选择器和命名空间</h4><p>在属性选择器中的属性名是以<a href="http://www.w3.org/TR/css3-namespace/#css-qnames" target="_blank" rel="external">CSS限定名</a>给出：先前已声明的命名空间前缀可预先准备给由命名空间分隔符<code>|</code>分隔的属性名。为了保持命名空间在<code>XML</code>中的推荐，默认的命名空间不会应用到属性中，因此，没有命名空间组件的属性选择器只应用到那些没有命名空间的属性。一个<code>*</code>可能被用于命名空间前缀以表明该选择器可匹配所有属性名而不用考虑属性的命名空间。</p>
<p>一个属性选择器有一个属性名包含了命名空间前缀，但是该命名空间没有在之前定义，这时该属性选择器是一个无效的选择器。</p>
<p><code>CSS</code>实例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">namespace</span> foo <span class="string">"http://www.example.com"</span></span>;</span><br><span class="line"><span class="attr_selector">[foo|att=val]</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> blue &#125;</span><br><span class="line">[*|att] &#123; color: yellow &#125;</span><br><span class="line">[|att] &#123; color: green &#125;</span><br><span class="line">[att] &#123; color: green &#125;</span></span></span></span><br></pre></td></tr></table></figure>
<p>第一条规则只匹配有在<code>http://www.example.com</code>命名空间下的属性<code>att</code>，且值为<code>val</code>的元素。</p>
<p>第二条规则只匹配具有属性<code>att</code>，且不管属性的命名空间。</p>
<p>最后两条规则是等价的，且只匹配具有属性<code>att</code>，且该属性不在任何命名空间下的元素。</p>
<h4 id="3-3-4_在DTDs中的默认属性值">3.3.4 在<code>DTDs</code>中的默认属性值</h4><p>属性选择器代表了在文档树中的属性值。文档树如何构建是在选择器之外的。在某些文档格式中，默认的属性值可以定义在<code>DTD</code>或其他地方，如果它们出现在文档树中的话，这些只能通过属性选择器来选择。选择器的设计应该使它们工作，不管默认值是否包含在文档树中。</p>
<p>例如，一个<code>XML</code>的用户代理可能并不需要去读取一个<code>DTD</code>的<code>外部子集</code>，但是需要在文档的<code>内部子集</code>寻找默认属性值（看这里：<a href="http://www.w3.org/TR/css3-selectors/#XML10" target="_blank" rel="external">XML10</a>）。取决于用户代理，一个定义在<code>DTD</code>的外部子集的默认的属性值可能会或可能不会出现在文档树中。</p>
<p>一个识别<code>XML</code>命名空间的用户代理可能不需要利用它的对于那个命名空间的认知来对待默认的属性值，就好像它们就在文档中。（例如，一个<code>XHTML</code>的用户代理不需要利用它内置的该<code>XHTML DTD</code>的认知）</p>
<p><strong>实例：</strong></p>
<p>考虑一个元素<code>example</code>，它有一个属性<code>radix</code>，且其默认值为<code>decimal</code>。<code>DTD</code>片段可能为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">!ATTLIST</span> <span class="attribute">EXAMPLE</span> <span class="attribute">radix</span> (<span class="attribute">decimal</span>,<span class="attribute">octal</span>) "<span class="attribute">decimal</span>"&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果样式表包含了这些规则：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">EXAMPLE</span><span class="attr_selector">[radix=decimal]</span> <span class="rules">&#123; <span class="comment">/*... default property settings ...*/</span> &#125;</span></span><br><span class="line"><span class="tag">EXAMPLE</span><span class="attr_selector">[radix=octal]</span>   <span class="rules">&#123; <span class="comment">/*... other settings...*/</span> &#125;</span></span><br></pre></td></tr></table></figure>
<p>第一条规则可能不会匹配那些<code>radix</code>属性被设置为默认值的元素，即为明确设置。为了捕获所有情况，属性选择器的默认值必须被舍弃：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">EXAMPLE</span>                <span class="rules">&#123; <span class="comment">/*... default property settings ...*/</span> &#125;</span></span><br><span class="line"><span class="tag">EXAMPLE</span><span class="attr_selector">[radix=octal]</span>   <span class="rules">&#123; <span class="comment">/*... other settings...*/</span> &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4_类选择器">3.4 类选择器</h3><p>与<code>HTML</code>工作，作者可能会使用<code>句点</code>符号（也就是<code>.</code>）来代替<code>~=</code>符号表示<code>class</code>属性。因此，对于<code>HTML</code>，<code>div.value</code>和<code>div[class~=value]</code>是具有同样的含义的。该属性值必须紧跟在<code>.</code>符号后面。</p>
<p>如果用户代理具有命名空间特定的知识，且允许它确定哪个属性是<code>class</code>属性用于各个命名空间，用户代理可能使用<code>.</code>符号在<code>XML</code>文档中应用选择器。</p>
<p><strong>CSS实例：</strong></p>
<p>我们可以通过以下方式来分配样式给所有<code>class~=&quot;pastoral&quot;</code>的元素：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*<span class="class">.pastoral</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> green &#125;  <span class="comment">/* all elements with class~=pastoral */</span></span></span></span></span><br></pre></td></tr></table></figure>
<p>或者只是：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.pastoral</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> green &#125;  <span class="comment">/* all elements with class~=pastoral */</span></span></span></span></span><br></pre></td></tr></table></figure>
<p>以下只分配样式给所有<code>class~=&quot;pastoral&quot;</code>的<code>h1</code>元素：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">H1</span><span class="class">.pastoral</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> green &#125;  <span class="comment">/* H1 elements with class~=pastoral */</span></span></span></span></span><br></pre></td></tr></table></figure>
<h3 id="3-5_ID选择器">3.5 ID选择器</h3><p>文档语言可以包含声明为ID类型的属性。ID类型属性的特殊之处在于在一致性的文档中没有两个这样的属性可以有相同的值，且不管携带该属性的元素类型；无论什么文档语言，一个ID类型属性可被用于唯一地标识其元素。</p>
<p>ID选择器是以<code>#</code>开头，然后紧跟着ID值。</p>
<p><strong>实例：</strong></p>
<p>以下ID选择器代表了一个<code>h1</code>元素，且它的id属性值为<code>chapter1</code></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">h1</span><span class="id">#chapter1</span></span><br></pre></td></tr></table></figure>
<p>不过很少会像上面这样写，一般是像下面这样：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#chapter1</span></span><br></pre></td></tr></table></figure>
<h3 id="3-6_伪类">3.6 伪类</h3><p>伪类的概念被引入以允许选择位于该文档树以外或者使用其他简单选择器不能表达的信息。</p>
<p>一个伪类总是包含<code>:</code>跟着伪类的名称和一个可选的值被放在圆括号之间。</p>
<p>伪类中允许包含在选择器中的所有简单选择器序列。伪类可以出现在简单选择器序列的任何地方，类型选择器和通用选择器（可能省略）后面。伪类名是不区分大小写。一些伪类是相互排斥的，而另一些可以同时施加到相同的元素。伪类可能是动态的，在这个意义上，元素可能获得或失去一个伪类当用户与文档进行交互的时候。</p>
<h4 id="3-6-1_动态伪类">3.6.1 动态伪类</h4><p>动态伪类在特性上分类元素，除了它们的名字、属性或内容，原则上特性不能从文档树中推断出来。</p>
<p>动态伪类不会出现在文档源或文档树中。</p>
<h5 id="3-6-1-1_链接伪类：:link和:visited">3.6.1.1 链接伪类：<code>:link</code>和<code>:visited</code></h5><p>用户代理通常显示未访问的链接不同于之前访问过的。选择器提供了伪类<code>:link</code>和<code>:visited</code>来区分它们。</p>
<ul>
<li><code>:link</code>伪类应用在那些没有被访问过的链接</li>
<li><code>:visited</code>伪类应用在那些已经被用户访问过的链接</li>
</ul>
<p>经过一定的时间，用户代理可能选择返回一个访问过的链接为<code>:link</code>状态。</p>
<p>这两种状态是互斥的。</p>
<p><strong>实例：</strong></p>
<p>下面的选择器代表了有一个<code>external</code>类的链接，且被访问过：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">a.external</span>:<span class="value">visited</span></span></span><br></pre></td></tr></table></figure>
<p>用户代理可能会因此对待所有的链接为未访问链接，或者采取其他措施以保护用户的隐私，而对访问和未访问链接渲染出不同。</p>
<h5 id="3-6-1-2_用户动作伪类:hover、:active和:focus">3.6.1.2 用户动作伪类<code>:hover</code>、<code>:active</code>和<code>:focus</code></h5><p>交互式用户代理有时会为了响应用户操作而改变呈现。选择器提供了三个伪类来选择这些用户正在作用的元素。</p>
<ul>
<li><code>:hover</code>伪类应用在当用户通过定位设备来指定元素，但不一定激活它时。例如，一个视觉用户代理可以应用伪类当光标悬停到元素所生成的盒子上时。用户代理不支持交互式媒体的不需要支持该伪类。支持交互式媒体的一些用户代理可能无法支持这个伪类。</li>
<li><code>:active</code>伪类应用在正被用户激活的元素上。例如，在用户按下鼠标按钮和释放它之间。在多于一个鼠标按钮的系统，<code>:active</code>仅应用在主激活按钮（通常是鼠标左键），以及它们的任意别名。</li>
<li><code>:focus</code>伪类应用在获得焦点的元素</li>
</ul>
<p>这些伪类不是相互排斥的。一个元素可以在相同的时间匹配的几个伪类。</p>
<p>选择器没有定义当元素的父亲也在<code>:active</code>或<code>:hover</code>状态时。</p>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">a</span>:<span class="value">link    <span class="comment">/* unvisited links */</span></span><br><span class="line">a:visited <span class="comment">/* visited links */</span></span><br><span class="line">a:hover   <span class="comment">/* user hovers */</span></span><br><span class="line">a:active  <span class="comment">/* active links */</span></span></span></span><br></pre></td></tr></table></figure>
<p>或者结合多个动态伪类：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">a</span>:<span class="value">focus</span><br><span class="line">a:focus:hover</span></span></span><br></pre></td></tr></table></figure>
<h4 id="3-6-2_目标伪类:target">3.6.2 目标伪类<code>:target</code></h4><p>一些<code>URIs</code>会引用资源内的一个位置。这种类型的<code>URI</code>是以<code>#</code>紧跟锚标识符结束。</p>
<p>有片段标识浮的<code>URIs</code>链接到文档内的某个元素，被称为目标元素。举例来说，这里给出了一个<code>URI</code>指向文档中一个名为<code>section_2</code>的锚。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//example.com/html/top.html#section_2</span></span><br></pre></td></tr></table></figure>
<p>一个目标元素可以使用<code>:target</code>伪类来表示。如果文档的URI没有片段标识符，则该文档没有目标元素。</p>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">p.note</span>:<span class="value">target</span></span></span><br></pre></td></tr></table></figure>
<p>这个选择器代表了一个<code>p</code>标签，且它有一个类<code>note</code>，且它是指定<code>URI</code>的目标元素时。</p>
<h4 id="3-6-3_语言伪类:lang">3.6.3 语言伪类<code>:lang</code></h4><p>如果文档语言指定了一个元素的人类语言如何确定，则可以使用选择器来代表基于该语言的元素。例如，在<code>HTML</code>中，语言是由<code>lang</code>属性和从<code>meta</code>元素的信息或<code>HTTP</code>协议联合决定的。<code>XML</code>使用一个叫做<code>xml:lang</code>的属性，并且还可能有其他的文档语言特定的方法，用于确定使用的语言。</p>
<p>伪类<code>:lang(C)</code>代表了在语言<code>C</code>中的元素。一个元素是否通过<code>:lang</code>被代表是完全基于元素的语言值是否和标识符<code>C</code>相等，或者是以标识符<code>C</code>开始并紧跟着<code>-</code>。对<code>C</code>和元素语言值的匹配是不区分大小写的。标识符<code>C</code>不必须是一个有效的语言名称。</p>
<p><code>C</code>必须是一个有效的<code>CSS</code>标识符，且不能为空。</p>
<p>实例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">html</span>:<span class="value"><span class="function">lang</span>(fr-be)</span><br><span class="line">html:<span class="function">lang</span>(de)</span><br><span class="line">:<span class="function">lang</span>(fr-be) &gt; q</span><br><span class="line">:<span class="function">lang</span>(de) &gt; q</span></span></span><br></pre></td></tr></table></figure>
<h4 id="3-6-4_UI元素状态伪类">3.6.4 UI元素状态伪类</h4><h5 id="3-6-4-1_:enabled和:disabled伪类">3.6.4.1 <code>:enabled</code>和<code>:disabled</code>伪类</h5><p><code>:enabled</code>伪类代表了处于激活状态的用户界面元素；这些元素都有相应的禁用状态。</p>
<p>相反地，<code>:disabled</code>伪类代表了处于禁用状态的用户界面元素；这些元素都有相应的激活状态。</p>
<p>什么构成激活状态、禁用状态和用户界面元素是语言决定的。在一个典型的文档中大多数元素即不会是<code>:enabled</code>也不会是<code>:disabled</code>。</p>
<p>那什么元素有这种状态呢，<code>input</code>、<code>textarea</code>等元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line"><span class="rule"><span class="attribute">input</span>:<span class="value">disabled &#123;</span><br><span class="line">	border: <span class="number">1px</span> solid blue</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="rule"><span class="attribute">input</span>:<span class="value">enabled &#123;</span><br><span class="line">	border: <span class="number">1px</span> solid red</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">disabled</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="3-6-4-2_:checked伪类">3.6.4.2 <code>:checked</code>伪类</h5><p>单选框和复选框元素可以被用户切换。一些菜单项被勾选，当用户选择它们的时候。<code>:checked</code>伪类就是应用在这些有<code>selected</code>和<code>checked</code>属性的元素，这些元素包含<code>checkbox</code>、<code>radio</code>、<code>option</code>等。</p>
<p>实例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line"><span class="rule"><span class="attribute">input</span>:<span class="value">checked + label &#123;</span><br><span class="line">	color: red</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">label</span>&gt;</span>checkbox<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"radio"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">label</span>&gt;</span>radio<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="3-6-4-3_:indeterminate伪类">3.6.4.3 <code>:indeterminate</code>伪类</h5><p>这个是对于<code>radio</code>和<code>checkbox</code>有时处于一种模糊的状态，即不是<code>checked</code>，也不是<code>unchecked</code>。</p>
<h4 id="3-6-5_结构伪类">3.6.5 结构伪类</h4><p>选择器引入了结构伪类的概念，允许基于在文档树中确定的信息来选择，但是不能通过其他简单选择器或连结符来表示。</p>
<p>当在它父亲的孩子列表中计算一个元素的位置时，独立文本和其他非元素节点不计算在内当计算在其父亲的孩子列表中的元素的位置，该指数的编号从1开始。</p>
<h5 id="3-6-5-1_:root伪类">3.6.5.1 <code>:root</code>伪类</h5><p><code>:root</code>伪类代表了文档的根元素。在<code>HTML4</code>中总是<code>html</code>元素。</p>
<h5 id="3-6-5-2_:nth-child()伪类">3.6.5.2 <code>:nth-child()</code>伪类</h5><p><code>:nth-child(an+b)</code>伪类可以代表在文档树中在它之前的有<code>an+b-1</code>个兄弟的元素，<code>n</code>可以为任何的正数或0，且有一个父元素。对于大于0的<code>a</code>和<code>b</code>，这有效的将元素的孩子分成每组<code>a</code>个元素，然后选择每组中的第<code>b</code>个元素。例如，这使得选择器解决<code>table</code>中每隔一行的问题，并可以用于段落文本中每四个交替颜色。<code>a</code>和<code>b</code>的值必须为整数。元素的子元素的索引是从<code>1</code>开始（要注意不是<code>JavaScript</code>等语言的0哟）。</p>
<p>除此之外，<code>:nth-child()</code>还可以接受<code>odd</code>和<code>even</code>作为参数。<code>odd</code>其实等价于<code>2n+1</code>，<code>even</code>其实等价于<code>2n</code>。</p>
<p><code>:nth-child()</code>的参数必须匹配以下语法规则，<code>INTEGER</code>匹配<code>[0-9]+</code>，标记的其余部分是由<a href="http://www.w3.org/TR/css3-selectors/#lex" target="_blank" rel="external">Lexical scanner</a>给出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nth</span><br><span class="line">  : S* [ [<span class="string">'-'</span>|<span class="string">'+'</span>]? INTEGER? &#123;N&#125; [ S* [<span class="string">'-'</span>|<span class="string">'+'</span>] S* INTEGER ]? |</span><br><span class="line">         [<span class="string">'-'</span>|<span class="string">'+'</span>]? INTEGER | &#123;O&#125;&#123;D&#125;&#123;D&#125; | &#123;E&#125;&#123;V&#125;&#123;E&#125;&#123;N&#125; ] S*</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">tr</span>:<span class="value"><span class="function">nth-child</span>(<span class="number">2</span>n+<span class="number">1</span>) <span class="comment">/* represents every odd row of an HTML table */</span></span><br><span class="line">tr:<span class="function">nth-child</span>(odd)  <span class="comment">/* same */</span></span><br><span class="line">tr:<span class="function">nth-child</span>(<span class="number">2</span>n+<span class="number">0</span>) <span class="comment">/* represents every even row of an HTML table */</span></span><br><span class="line">tr:<span class="function">nth-child</span>(even) <span class="comment">/* same */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Alternate paragraph colours in CSS */</span></span><br><span class="line">p:<span class="function">nth-child</span>(<span class="number">4</span>n+<span class="number">1</span>) &#123; color: navy</span></span>; &#125;</span><br><span class="line"><span class="rule"><span class="attribute">p</span>:<span class="value"><span class="function">nth-child</span>(<span class="number">4</span>n+<span class="number">2</span>) &#123; color: green</span></span>; &#125;</span><br><span class="line"><span class="rule"><span class="attribute">p</span>:<span class="value"><span class="function">nth-child</span>(<span class="number">4</span>n+<span class="number">3</span>) &#123; color: maroon</span></span>; &#125;</span><br><span class="line"><span class="rule"><span class="attribute">p</span>:<span class="value"><span class="function">nth-child</span>(<span class="number">4</span>n+<span class="number">4</span>) &#123; color: purple</span></span>; &#125;</span><br></pre></td></tr></table></figure>
<p>当<code>b</code>的值前面有一个负号，则<code>+</code>字符必须从表达式中移除。</p>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="pseudo">:nth-child(10n-1)</span>  <span class="comment">/* represents the 9th, 19th, 29th, etc, element */</span></span><br><span class="line"><span class="pseudo">:nth-child(10n+9)</span>  <span class="comment">/* Same */</span></span><br><span class="line"><span class="pseudo">:nth-child(10n+-1)</span> <span class="comment">/* Syntactically invalid, and would be ignored */</span></span><br></pre></td></tr></table></figure>
<p>当<code>a=0</code>，则<code>an</code>部分可以不包含。当<code>an</code>未包含且<code>b</code>为非负数，则在<code>b</code>前面的<code>+</code>字符也可省略。</p>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">foo</span>:<span class="value"><span class="function">nth-child</span>(<span class="number">0</span>n+<span class="number">5</span>)   <span class="comment">/* represents an element foo that is the 5th child</span><br><span class="line">                         of its parent element */</span></span><br><span class="line">foo:<span class="function">nth-child</span>(<span class="number">5</span>)      <span class="comment">/* same */</span></span></span></span><br></pre></td></tr></table></figure>
<p>当<code>a=1</code>或<code>a=-1</code>，数字可以从规则中省略。</p>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">bar</span>:<span class="value"><span class="function">nth-child</span>(<span class="number">1</span>n+<span class="number">0</span>)   <span class="comment">/* represents all bar elements, specificity (0,1,1) */</span></span><br><span class="line">bar:<span class="function">nth-child</span>(n+<span class="number">0</span>)    <span class="comment">/* same */</span></span><br><span class="line">bar:<span class="function">nth-child</span>(n)      <span class="comment">/* same */</span></span><br><span class="line">bar                   <span class="comment">/* same but lower specificity (0,0,1) */</span></span></span></span><br></pre></td></tr></table></figure>
<p>当<code>b=0</code>，则每一个第<code>a</code>个元素被选择。在这种情况，<code>+b</code>或<code>-b</code>部分可能省略，除非<code>a</code>部分已经被省略。</p>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">tr</span>:<span class="value"><span class="function">nth-child</span>(<span class="number">2</span>n+<span class="number">0</span>) <span class="comment">/* represents every even row of an HTML table */</span></span><br><span class="line">tr:<span class="function">nth-child</span>(<span class="number">2</span>n) <span class="comment">/* same */</span></span></span></span><br></pre></td></tr></table></figure>
<p>空白是允许出现在<code>(之后</code>或<code>)</code>之前，也可以出现在<code>+</code>或<code>-</code>任何一方以分割<code>an</code>和<code>b</code>部分，当它们都没有省略的时候。</p>
<p><strong>有效的实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="pseudo">:nth-child(</span> 3<span class="tag">n</span> + 1 )</span><br><span class="line"><span class="pseudo">:nth-child(</span> +3<span class="tag">n</span> <span class="tag">-</span> 2 )</span><br><span class="line"><span class="pseudo">:nth-child(</span> <span class="tag">-n</span>+ 6)</span><br><span class="line"><span class="pseudo">:nth-child(</span> +6 )</span><br></pre></td></tr></table></figure>
<p>下面是无效的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="pseudo">:nth-child(3</span> <span class="tag">n</span>)</span><br><span class="line"><span class="pseudo">:nth-child(+</span> 2<span class="tag">n</span>)</span><br><span class="line"><span class="pseudo">:nth-child(+</span> 2)</span><br></pre></td></tr></table></figure>
<p>当<code>a</code>和<code>b</code>都为0时，该伪类没有选择文档树中的任何元素。</p>
<p><code>a</code>的值可能为负数，但是只有在<code>an+b</code>的正数位置才可以被选择。</p>
<p><strong>实例：</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html|tr:nth-child(-n+6)  /* represents the 6 first rows of XHTML tables */</span><br></pre></td></tr></table></figure>
<h5 id="3-6-5-3_:nth-last-child()伪类">3.6.5.3 <code>:nth-last-child()</code>伪类</h5><p>其实这个伪类和前面的<code>:nth-child()</code>是很类似的，它只是从最后一个元素开始计算索引。<code>:nth-last-child(an+b)</code>伪类可以代表在文档树中在它之<code>后</code>的有<code>an+b-1</code>个兄弟的元素，<code>n</code>可以为任何的正数或0，且有一个父元素。这个可以参考上面的<code>:nth-child()</code>语法。它同样接受<code>odd</code>和<code>even</code>作为参数。</p>
<p>实例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">tr</span>:<span class="value"><span class="function">nth-last-child</span>(-n+<span class="number">2</span>)    <span class="comment">/* represents the two last rows of an HTML table */</span></span><br><span class="line"></span><br><span class="line">foo:<span class="function">nth-last-child</span>(odd)    <span class="comment">/* represents all odd foo elements in their parent element,</span><br><span class="line">                              counting from the last one */</span></span></span></span><br></pre></td></tr></table></figure>
<h5 id="3-6-5-4_:nth-of-type()伪类">3.6.5.4 <code>:nth-of-type()</code>伪类</h5><p>这个伪类其实可以看成对<code>:nth-child()</code>施加了一个限制，那就是元素类型必须相同。<code>:nth-of-type(an+b)</code>伪类可以代表在文档树中在它之前有<code>an+b-1</code>个兄弟，且<code>元素类型必须相同</code>的元素，<code>n</code>可以为任何的正数或0，且有一个父元素。这个可以参考上面的<code>:nth-child()</code>语法。它同样接受<code>odd</code>和<code>even</code>作为参数。</p>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">img</span>:<span class="value"><span class="function">nth-of-type</span>(<span class="number">2</span>n+<span class="number">1</span>) &#123; float: right</span></span>; &#125;</span><br><span class="line"><span class="rule"><span class="attribute">img</span>:<span class="value"><span class="function">nth-of-type</span>(<span class="number">2</span>n) &#123; float: left</span></span>; &#125;</span><br></pre></td></tr></table></figure>
<p>再看一个例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">/*#demo p:nth-of-type(even) &#123;</span><br><span class="line">	color: red;</span><br><span class="line">&#125;*/</span><br><span class="line">#demo :nth-child(even) &#123;</span><br><span class="line">	color: blue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id="demo"&gt;</span><br><span class="line">	&lt;p&gt;1&lt;/p&gt;</span><br><span class="line">	&lt;p&gt;2&lt;/p&gt;</span><br><span class="line">	&lt;p&gt;3&lt;/p&gt;</span><br><span class="line">	&lt;a href=""&gt;4&lt;/a&gt;</span><br><span class="line">	&lt;p&gt;5&lt;/p&gt;</span><br><span class="line">	&lt;p&gt;6&lt;/p&gt;</span><br><span class="line">	&lt;p&gt;7&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>你可以在浏览器中对比以下这两个选择器的效果哟。</p>
<h5 id="3-6-5-5_:nth-last-of-type()伪类">3.6.5.5 <code>:nth-last-of-type()</code>伪类</h5><p>这个伪类和<code>:nth-of-type()</code>，只是从最后一个元素开始计算索引啦。<code>:nth-last-of-type(an+b)</code>伪类可以代表在文档树中在它之<code>后</code>有<code>an+b-1</code>个兄弟，且<code>元素类型必须相同</code>的元素，<code>n</code>可以为任何的正数或0，且有一个父元素。这个可以参考上面的<code>:nth-child()</code>语法。它同样接受<code>odd</code>和<code>even</code>作为参数。</p>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">body</span> &gt; <span class="tag">h2</span><span class="pseudo">:nth-of-type(n+2)</span><span class="pseudo">:nth-last-of-type(n+2)</span></span><br></pre></td></tr></table></figure>
<h5 id="3-6-5-6_:first-child伪类">3.6.5.6 <code>:first-child</code>伪类</h5><p>和<code>:nth-child(1)</code>相同。<code>:first-child</code>伪类代表一个元素为其他元素的第一个子元素。</p>
<p>实例：</p>
<p>下面的例子代表了一个<code>p</code>元素是<code>div</code>中的第一个元素。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span> &gt; <span class="rule"><span class="attribute">p</span>:<span class="value">first-child</span></span></span><br></pre></td></tr></table></figure>
<p>选择器可以匹配下面HTML中<code>div</code>中的<code>p</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span> The last P before the note.<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"note"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">p</span>&gt;</span> The first P inside the note.<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是不能匹配下面<code>div</code>中<code>p</code>元素，因为<code>p</code>不是<code>div</code>中的第一个子元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span> The last P before the note.<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"note"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">h2</span>&gt;</span> Note <span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">p</span>&gt;</span> The first P inside the note.<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="3-6-5-7_:last-child伪类">3.6.5.7 <code>:last-child</code>伪类</h5><p>和<code>:nth-last-child(1)</code>相同。<code>:last-child</code>伪类代表一个元素为其他元素的最后一个子元素。</p>
<p>实例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">ol</span> &gt; <span class="rule"><span class="attribute">li</span>:<span class="value">last-child</span></span></span><br></pre></td></tr></table></figure>
<h5 id="3-6-5-8_:first-of-type伪类">3.6.5.8 <code>:first-of-type</code>伪类</h5><p>和<code>:nth-of-type(1)</code>相同。<code>:first-of-type</code>伪类代表一个元素，它是父元素中第一个具有相同元素名的元素。</p>
<p>实例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dl dt:first-of-type &#123;</span><br><span class="line">	color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;dl&gt;</span><br><span class="line"> &lt;dt&gt;gigogne&lt;/dt&gt;</span><br><span class="line"> &lt;dd&gt;</span><br><span class="line">  &lt;dl&gt;</span><br><span class="line">   &lt;dt&gt;fusée&lt;/dt&gt;</span><br><span class="line">   &lt;dd&gt;multistage rocket&lt;/dd&gt;</span><br><span class="line">   &lt;dt&gt;table&lt;/dt&gt;</span><br><span class="line">   &lt;dd&gt;nest of tables&lt;/dd&gt;</span><br><span class="line">  &lt;/dl&gt;</span><br><span class="line"> &lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure>
<h5 id="3-6-5-9_:last-of-type伪类">3.6.5.9 <code>:last-of-type</code>伪类</h5><p>和<code>:nth-last-of-type(1)</code>相同。<code>:last-of-type</code>伪类代表一个元素，它是父元素中最后一个具有相同元素名的元素。</p>
<p>实例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">tr</span> &gt; <span class="rule"><span class="attribute">td</span>:<span class="value">last-of-type</span></span></span><br></pre></td></tr></table></figure>
<h5 id="3-6-5-10_:only-child伪类">3.6.5.10 <code>:only-child</code>伪类</h5><p>该伪类代表了一个元素，它的父元素除了它没有其他元素。其实等价于<code>:first-child:last-child</code>。</p>
<h5 id="3-6-5-11_:only-of-type伪类">3.6.5.11 <code>:only-of-type</code>伪类</h5><p>该伪类代表了一个元素，它的父元素除了它没有其他元素，且和指定的元素类型相同。等价于<code>:first-of-type:last-of-type</code>。</p>
<h5 id="3-6-5-12_:empty伪类">3.6.5.12 <code>:empty</code>伪类</h5><p><code>:empty</code>伪类代表了一个元素始终没有子元素。</p>
<p><strong>实例：</strong></p>
<p><code>p:empty</code>可以代表以下<code>html</code>片段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而<code>foo:empty</code>不能代表以下片段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">foo</span>&gt;</span>bar<span class="tag">&lt;/<span class="title">foo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">foo</span>&gt;</span><span class="tag">&lt;<span class="title">bar</span>&gt;</span>bla<span class="tag">&lt;/<span class="title">bar</span>&gt;</span><span class="tag">&lt;/<span class="title">foo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">foo</span>&gt;</span>this is not <span class="tag">&lt;<span class="title">bar</span>&gt;</span>:empty<span class="tag">&lt;/<span class="title">bar</span>&gt;</span><span class="tag">&lt;/<span class="title">foo</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-6-6_空白">3.6.6 空白</h4><p>本节有意留为空白。（本节之前定义了一个<code>:contains()</code>伪类）</p>
<h4 id="3-6-7_否定伪类">3.6.7 否定伪类</h4><p>否定伪类，<code>:not(x)</code>是一个功能性的符号，它接受一个简单选择器作为参数。它代表了这些不是参数所代表的元素。</p>
<p>否定不能嵌套，<code>:not(:not(...))</code>是无效的。要注意当伪元素不是简单选择器，所以它们不是<code>:not()</code>的有效参数。</p>
<p><strong>实例：</strong></p>
<p>以下选择器匹配在HTML中没有被禁用的按钮：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">button</span>:<span class="value"><span class="function">not</span>([DISABLED])</span></span></span><br></pre></td></tr></table></figure>
<p>默认的命名空间声明不会影响否定伪类的参数，除非该参数是一个通用选择器或类型选择器。</p>
<p><strong>实例：</strong></p>
<p>假设默认的命名空间为<code>http://example.com/</code>，下面的选择器代表了所有不在该命名空间的元素：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*|*:not(*)</span><br></pre></td></tr></table></figure>
<h2 id="4-_伪元素">4. 伪元素</h2><p>在文档语言规定之外，伪元素创建了一个关于文档树的抽象引用。例如，文档语言不提供机制来访问的一个元素的内容的第一个字母或第一行。伪元素允许作者引用这个本来无法访问的信息。伪元素还能提供作者一种方式去引用源文档中不存在的内容（<code>::before</code>和<code>::after</code>）。</p>
<p>一个伪元素是由<code>::</code>跟着伪元素名称组成的。</p>
<p><code>::</code>符号在文档中被引入是为了在伪类和伪元素之间建立一个区别。为了与现有的样式表的兼容性，用户代理必须同样接受一个冒号<code>:</code>的写法。</p>
<h3 id="4-1_::first-line伪元素">4.1 <code>::first-line</code>伪元素</h3><p><code>::first-line</code>伪元素描述了元素的内容中被格式化的第一行。</p>
<p><strong>CSS实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">p</span>:<span class="value">:first-line &#123; text-transform: uppercase &#125;</span></span></span><br></pre></td></tr></table></figure>
<p>上面的规则意思为将每个<code>p</code>元素的第一行的每个字母变为大写。</p>
<p>注意，第一行的长度取决于许多因素，包括该页面的宽度，字体大小等。因此，一个普通的HTML段落，如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">P</span>&gt;</span>This is a somewhat long HTML </span><br><span class="line">paragraph that will be broken into several </span><br><span class="line">lines. The first line will be identified</span><br><span class="line">by a fictional tag sequence. The other lines </span><br><span class="line">will be treated as ordinary lines in the </span><br><span class="line">paragraph.<span class="tag">&lt;/<span class="title">P</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中折行如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">THIS IS A SOMEWHAT LONG HTML PARAGRAPH THAT</span><br><span class="line">will be broken into several lines. The first</span><br><span class="line">line will be identified by a fictional tag </span><br><span class="line">sequence. The other lines will be treated as </span><br><span class="line">ordinary lines in the paragraph.</span><br></pre></td></tr></table></figure>
<p>该段落可能可能被用户代理<code>重写</code>，包括虚构的标签<code>::first-line</code>。这个虚构的标签序列有助于说明属性如何继承。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">P</span>&gt;</span><span class="tag">&lt;<span class="title">P::first-line</span>&gt;</span> This is a somewhat long HTML </span><br><span class="line">paragraph that <span class="tag">&lt;/<span class="title">P::first-line</span>&gt;</span> will be broken into several</span><br><span class="line">lines. The first line will be identified </span><br><span class="line">by a fictional tag sequence. The other lines </span><br><span class="line">will be treated as ordinary lines in the </span><br><span class="line">paragraph.<span class="tag">&lt;/<span class="title">P</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果伪元素折断了一个真实的元素，所需的效果通常被描述为一个虚构的标签序列关闭，然后重新打开该元素。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">P</span>&gt;</span><span class="tag">&lt;<span class="title">SPAN</span> <span class="attribute">class</span>=<span class="value">"test"</span>&gt;</span> This is a somewhat long HTML</span><br><span class="line">paragraph that will be broken into several</span><br><span class="line">lines.<span class="tag">&lt;/<span class="title">SPAN</span>&gt;</span> The first line will be identified</span><br><span class="line">by a fictional tag sequence. The other lines </span><br><span class="line">will be treated as ordinary lines in the </span><br><span class="line">paragraph.<span class="tag">&lt;/<span class="title">P</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>用户代理会像下面这样处理：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">P</span>&gt;</span><span class="tag">&lt;<span class="title">P::first-line</span>&gt;</span><span class="tag">&lt;<span class="title">SPAN</span> <span class="attribute">class</span>=<span class="value">"test"</span>&gt;</span> This is a</span><br><span class="line">somewhat long HTML</span><br><span class="line">paragraph that will <span class="tag">&lt;/<span class="title">SPAN</span>&gt;</span><span class="tag">&lt;/<span class="title">P::first-line</span>&gt;</span><span class="tag">&lt;<span class="title">SPAN</span> <span class="attribute">class</span>=<span class="value">"test"</span>&gt;</span> be</span><br><span class="line">broken into several</span><br><span class="line">lines.<span class="tag">&lt;/<span class="title">SPAN</span>&gt;</span> The first line will be identified</span><br><span class="line">by a fictional tag sequence. The other lines</span><br><span class="line">will be treated as ordinary lines in the </span><br><span class="line">paragraph.<span class="tag">&lt;/<span class="title">P</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="4-1-1_CSS中格式化的第一行的定义">4.1.1 CSS中格式化的第一行的定义</h4><p>在CSS中，<code>::first-line</code>伪元素只能在<code>block-like</code>容器上有效果，这些容器有<code>block box</code>，<code>inline-block</code>，<code>table-caption</code>和<code>table-cell</code>。</p>
<p>一个元素的格式化第一行可能发生在相同流的一个<code>block-level</code>后代中（例如，一个<code>block-level</code>后代没有脱离流）。例如，在<code>&lt;DIV&gt;&lt;P&gt;This line...&lt;/P&gt;&lt;/DIV&gt;</code>中<code>DIV</code>的第一行为<code>p</code>元素的第一行。</p>
<p><code>table-cell</code>和<code>inline-block</code>的第一行不能成为一个祖先元素的格式化的第一行。因此，在<code>&lt;DIV&gt;&lt;P STYLE=&quot;display: inline-block&quot;&gt;Hello&lt;BR&gt;Goodbye&lt;/P&gt; etcetera&lt;/DIV&gt;</code>中，<code>DIV</code>的格式化第一行不是<code>Hello</code>的那一行。</p>
<p>一个用户代理应当表现的就好像<code>::first-line</code>的虚拟开始标签伪元素被嵌套到最内层的<code>block-level</code>元素中。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">DIV</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">P</span>&gt;</span>First paragraph<span class="tag">&lt;/<span class="title">P</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">P</span>&gt;</span>Second paragraph<span class="tag">&lt;/<span class="title">P</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">DIV</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>加上虚拟标签后：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">DIV</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">P</span>&gt;</span><span class="tag">&lt;<span class="title">DIV::first-line</span>&gt;</span><span class="tag">&lt;<span class="title">P::first-line</span>&gt;</span>First paragraph<span class="tag">&lt;/<span class="title">P::first-line</span>&gt;</span><span class="tag">&lt;/<span class="title">DIV::first-line</span>&gt;</span><span class="tag">&lt;/<span class="title">P</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">P</span>&gt;</span><span class="tag">&lt;<span class="title">P::first-line</span>&gt;</span>Second paragraph<span class="tag">&lt;/<span class="title">P::first-line</span>&gt;</span><span class="tag">&lt;/<span class="title">P</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">DIV</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>::first-line</code>伪元素类似于一个<code>inline-level</code>元素，但有一定的限制。以下CSS属性应用到一个<code>::first-line</code>伪元素：字体属性、背景属性、颜色属性、<code>word-spacing</code>，<code>letter-spacing</code>，<code>text-decoration</code>，<code>vertical-align</code>，<code>text-transform</code>，<code>line-height</code>。用户代理也可能应用其他属性。</p>
<p>在CSS继承时，发生在第一行的子元素的一部分只从<code>::first-line</code>伪元素继承<code>::first-line</code>上可应用的属性。对于所有的其他属性，继承时从第一行伪元素的非鱼伪元素父元素中继承。</p>
<h3 id="4-2_::first-letter伪元素">4.2 <code>::first-letter</code>伪元素</h3><p><code>::first-letter</code>代表了一个元素的第一个字母，如果在该行中在它前面没有任何其他内容。<code>::first-letter</code>伪元素可能被用于<code>首字母大写</code>等用途。</p>
<p>标点符号，即第一个字母前面或后面也应包括在内。</p>
<p><img src="http://www.w3.org/TR/css3-selectors/first-letter2.png" alt="enter image description here"></p>
<p>当第一个字母为数字时，<code>::first-line</code>也同样被应用，例如，在<code>67 million dollars is a lot of money.</code>中的<code>6</code>。</p>
<h4 id="4-2-1_在CSS中的应用">4.2.1 在CSS中的应用</h4><p>在CSS中，<code>::first-letter</code>伪元素只能在<code>block-like</code>容器上有效果，这些容器有<code>block</code>，<code>list-item</code>，<code>inline-block</code>，<code>table-caption</code>和<code>table-cell</code>。</p>
<p><code>::first-letter</code>伪元素可和所有这些包含文本的元素或有一个后代包含文本且在相同的流的元素使用。用户代理也应该表现为好像虚拟的标签被加上。</p>
<p><strong>实例：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>The first text.</span><br></pre></td></tr></table></figure>
<p>表现为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">div::first-letter</span>&gt;</span><span class="tag">&lt;<span class="title">p::first-letter</span>&gt;</span>T<span class="tag">&lt;/<span class="title">...</span>&gt;</span><span class="tag">&lt;/<span class="title">...</span>&gt;</span>he first text.</span><br></pre></td></tr></table></figure>
<p><code>table-cell</code>和<code>inline-block</code>的第一个字母不能成为一个祖先元素的的第一字母。因此，在<code>&lt;DIV&gt;&lt;P STYLE=&quot;display: inline-block&quot;&gt;Hello&lt;BR&gt;Goodbye&lt;/P&gt; etcetera&lt;/DIV&gt;</code>中，<code>DIV</code>的第一字母不是<code>H</code>。实际上，<code>DIV</code>没有第一个字母。</p>
<p>如果元素是一个<code>list item</code>，<code>::first-letter</code>应用在主体框标记后的第一个字母。如果<code>list item</code>设置了<code>list-style-position: inside</code>，用户代理将忽略该列表项的<code>::first-letter</code>。如果一个元素有<code>::before</code>和<code>::after</code>内容，<code>::first-letter</code>应用的时候包含了<code>::before</code>和<code>::after</code>的内容。</p>
<p><strong>实例：</strong></p>
<p>例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">p</span>:<span class="value">:before &#123;content: <span class="string">"Note: "</span>&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><code>p::first-letter</code>匹配<code>Note</code>中的<code>N</code>。</p>
<p>在CSS中，<code>::first-letter</code>伪元素类似于一个<code>inline-level</code>元素，如果该元素的<code>float</code>为<code>none</code>；否则，它和浮动元素相同。</p>
<h3 id="4-3_空白">4.3 空白</h3><p>这里是故意留白的。（之前定义了<code>::selection</code>伪元素）</p>
<h3 id="4-4_::before和::after伪元素">4.4 <code>::before</code>和<code>::after</code>伪元素</h3><p>这两个伪元素在<a href="http://www.w3.org/TR/css3-selectors/#CSS21" target="_blank" rel="external">CSS21</a>中定义。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/CSS/">CSS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/selector/">selector</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/02/05/css-selectors/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/02/05/css-selectors/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/21/css3-animation/" title="CSS3 Animation" itemprop="url">CSS3 Animation</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-01-21T05:47:42.000Z" itemprop="datePublished"> 發表於 2015-01-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文是<a href="http://www.w3.org/TR/web-animations/" target="_blank" rel="external">Web Animations 1.0</a>的学习和翻译，如有翻译不好的可以看看原文哟。</p>
<h2 id="1_介绍">1 介绍</h2><p><code>CSS</code>的<a href="http://www.w3.org/TR/css3-animations/#CSS3-TRANSITIONS" target="_blank" rel="external">transition</a>提供了一种在它们基本属性改变时插入<code>CSS</code>属性值的方式。这提供了一种简单的方法来实现一些简单的动画，但动画的开始和结束状态是由现有的属性值来控制，<code>transition</code>在动画如何进行上给作者提供了很少的控制。</p>
<p>该提案中介绍了定义动画，其中作者可以使用<code>keyframe</code>来指定<code>CSS</code>属性随着时间的变化。<code>Animation</code>类似于<code>transition</code>，因为它们随时间改变CSS属性的表象值（presentational value）。主要的区别是，<code>transition</code>是当属性值改变时触发，<code>animation</code>是在<code>animation</code>属性被应用后明确的执行。正因为如此，<code>animations</code>对于正在被动画的属性需要明确的值。这些值是使用动画关键帧（keyframes）来指定的，将在下面描述。</p>
<p>动画的许多方面可以被控制，包括多少次动画迭代，是否交替开始和结束之间的值，动画是否应该运行还是暂停。动画同样可以延迟它的开始时间。</p>
<h2 id="2_取值">2 取值</h2><p>该规范遵循<a href="http://www.w3.org/TR/css3-animations/#CSS21" target="_blank" rel="external">CSS21</a>中的<a href="http://www.w3.org/TR/CSS21/about.html#property-defs" target="_blank" rel="external">CSS属性定义约定</a>。在该规范中没有定义的值的类型被定义在<code>CSS Level 2 Revision 1</code><a href="http://www.w3.org/TR/css3-animations/#CSS21" target="_blank" rel="external">[CSS21]</a>。其他CSS模块可能扩展这些值类型的定义：例如<a href="http://www.w3.org/TR/css3-animations/#CSS3VAL" target="_blank" rel="external">[CSS3VAL)]</a>，当与该模块结合时，扩展<code>&lt;length&gt;</code>值类型的定义将在本规范中使用。</p>
<p>除了在它们的定义中列出的属性的特定值，在该规范中定义的所有属性也接受了<a href="http://dev.w3.org/csswg/css3-values/#common-keywords" target="_blank" rel="external">initial</a>和<a href="http://www.w3.org/TR/CSS21/cascade.html#value-def-inherit" target="_blank" rel="external">inherit</a>关键字作为他们的属性值。因为可读性原因，并未明确重复。</p>
<h2 id="3_动画">3 动画</h2><p><code>CSS</code>动画影响属性的计算值。在动画的执行期间，对于属性的计算值是由动画控制。这将会覆盖在正常样式系统中指定的值。动画覆盖所有一般规则，但会被<code>!important</code>规则所覆盖。</p>
<p>如果在一个时间点有多个动画为同一个属性指定了行为，则该动画名出现在<a href="http://www.w3.org/TR/css3-animations/#animation-name" target="_blank" rel="external">animation-name</a>值的最后一个会覆盖其他动画。</p>
<p>一个动画在动画应用程序之前、动画延迟到期前和动画结束后不会影响计算值。</p>
<center><br><img src="http://www.w3.org/TR/css3-animations/sandwich.png" alt="enter image description here"><br></center>

<center><br>图片1：动画属性值的计算<br></center>

<p>上图显示了属性值如何计算。本身的样式显示在图的顶部，当动画没有运行和动画被延迟时，计算值是从本身样式衍生而来。在动画运行期间，计算样式是由动画值衍生而来。</p>
<p>动画的开始时间是后面的两个时刻：样式被解析出指定了动画的时间，或文档的<code>load</code>事件被触发。因此，在文档的样式表中指定的动画是在文档加载后开始。通过修改元素样式的指定动画会在文档被加载后且该样式被解析后开始。这可能在伪元素样式规则下立即执行，例如<code>hover</code>，或者是脚本引擎将控制返回给浏览器。</p>
<p>当元素有一个<a href="http://www.w3.org/TR/css3-animations/#animation-name" target="_blank" rel="external">animation-name</a>的值引用了一个有效的<code>keyframes</code>规则时，动画才会应用到元素上。一旦动画开始，它会继续直到结束，或者<a href="http://www.w3.org/TR/css3-animations/#animation-name" target="_blank" rel="external">animation-name</a>被移除。用于关键帧和动画属性的值当动画开始时被快照。在动画执行期间改变它们是没有效果的。另外要注意，改变<a href="http://www.w3.org/TR/css3-animations/#animation-name" target="_blank" rel="external">animation-name</a>的值并不一定会重新启动动画（例如：如果一个动画列表被应用，且其中一个从列表中移除，只有那个动画会暂停，其他动画会继续运行）。为了重新启动动画，它必须被移除，然后重新应用。</p>
<p>动画的结束是由<a href="http://www.w3.org/TR/css3-animations/#animation-duration" target="_blank" rel="external">animation-duration</a>、<a href="http://www.w3.org/TR/css3-animations/#animation-iteration-count" target="_blank" rel="external">animation-iteration-count</a>和<a href="http://www.w3.org/TR/css3-animations/#animation-fill-mode" target="_blank" rel="external">animatioin-fill-mode</a>属性结合一起定义的。</p>
<p><strong>实例1：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">animation-name</span>:<span class="value"> diagonal-slide</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">animation-duration</span>:<span class="value"> <span class="number">5s</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">animation-iteration-count</span>:<span class="value"> <span class="number">10</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="at_rule">@<span class="keyword">keyframes</span> diagonal-slide </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="tag">from</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">to</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上会产生用五秒将元素<code>(0, 0)</code>移动到<code>(100px, 100px)</code>，并且重复十次。</p>
<p>当设置<code>display</code>属性为<code>none</code>时，会终止任何被应用在元素和它后代的运行中的动画。如果元素的<code>diaplay</code>为<code>none</code>，当更新它的<code>display</code>值不为<code>none</code>的任何值时所有通过<a href="http://www.w3.org/TR/css3-animations/#animation-name" target="_blank" rel="external">animation-name</a>运用到元素的动画会开始运行，也同样包括它后代的<code>display</code>不为<code>none</code>的动画。</p>
<p>虽然作者可以使用动画来创建动态变化的内容，动态变化的内容可以导致在某些用户癫痫。有关如何避免内容导致癫痫发作的信息，可以看<a href="http://www.w3.org/TR/WCAG20/#seizure" target="_blank" rel="external">Guideline 2.3: Seizures: Do not design content in a way that is known to cause seizures</a></p>
<h2 id="4_关键帧（keyframes）">4 关键帧（keyframes）</h2><p>关键帧被用于在动画过程中指定用于在各个点的动画属性的值。关键帧指定了动画的一个周期的行为，动画可以迭代一次或多次。</p>
<p>关键帧是使用专门的<code>CSS</code>的<code>@</code>规则来指定。一个<code>@keyframes</code>规则包含了关键字<code>@keyframes</code>，然后跟着标识符给出动画的名称（它会被<a href="http://www.w3.org/TR/css3-animations/#animation-name" target="_blank" rel="external">animation-name</a>引用到），最后是一组样式规则（由大括号分隔）。</p>
<p>对于关键帧样式规则的<strong>关键帧选择器（keyframe selector）</strong>包含了由逗号分隔的百分比值列表或关键字<code>from</code>或<code>to</code>。选择器用于指定沿该关键帧代表的该动画的持续时间的百分比。关键帧本身是通过在选择器声明的属性值块中指定。关键字<code>from</code>等价于<code>0%</code>，关键字<code>to</code>等价于<code>100%</code>。</p>
<p>如果<code>0%</code>或<code>from</code>没有被指定，那么用户代理会使用将要动画的属性的计算值构造一个<code>0%</code>的关键帧。如果<code>100%</code>或<code>to</code>没有被指定，那么用户代理会使用将要动画的属性的计算值构造一个<code>100%</code>的关键帧。如果关键帧选择器指定了一个负的或者是大于<code>100%</code>百分比值，该关键帧将被忽略。</p>
<p>一个关键帧规则的<strong>关键帧声明块（keyframe declaration block）</strong>包含属性和值，那些不能动画的属性将在规则中被忽略，除了<a href="http://www.w3.org/TR/css3-animations/#animation-timing-function" target="_blank" rel="external">animation-timing-function</a>之外，该属性的行为将在下面说明。此外，关键帧规则声明中想具有<code>!important</code>资格将被忽略（没有!important优先级）。</p>
<p>动画所使用的<code>@keyframes</code>规则将是在被排序后的规则顺序中最后一个遇到的，且匹配在<a href="http://www.w3.org/TR/css3-animations/#animation-name" target="_blank" rel="external">animation-name</a>引用到）属性中指定的动画名称 。<code>@keyframes</code>规则不会层叠；因此，一个动画永远不会从多个<code>@keyframes</code>规则中获得关键帧。</p>
<p>为了确定该组的关键帧，所有的选择器的值按时间递增顺序排序。如果有任何重复，那么<code>@keyframes</code>规则内指定的最后一个关键帧将被用于提供那时关键帧的信息。如果有多个关键帧指定了相同的关键帧选择器值时，在<code>@keyframes</code>规则中不会重叠。</p>
<p>如果一个属性不是为关键帧指定，或者它的指定是无效的，动画的那个属性进行就好像那个关键帧不存在一样。概念上，就好像构造一组关键帧的每个属性存在于任何关键帧，且动画是为每个属性独立运行的。</p>
<p><strong>实例2：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">keyframes</span> wobble </span>&#123;</span><br><span class="line">  0% <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><br><span class="line">  40% <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">150px</span></span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><br><span class="line">  60% <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">75px</span></span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><br><span class="line">  100% <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四个关键帧在动画名为<code>wobble</code>的动画中指定。在第一个关键帧中，显示了动画周期的开始，<code>left</code>属性的值被动画到<code>100px</code>。在<code>40%</code>时，<code>left</code>为<code>150px</code>。以此类推。下面的图展示了动画的状态，如果动画持续时间被指定为10s的话。</p>
<p><ceter><br><img src="http://www.w3.org/TR/css3-animations/animation1.png" alt="enter image description here"><br></ceter></p>
<p>下面是关键帧规则的语法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">keyframes_rule: KEYFRAMES_SYM S+ IDENT S* <span class="string">'&#123;'</span> S* keyframes_blocks <span class="string">'&#125;'</span> S*;</span><br><span class="line"></span><br><span class="line">keyframes_blocks: [ keyframe_selector <span class="string">'&#123;'</span> S* declaration? [ <span class="string">';'</span> S* declaration? ]* <span class="string">'&#125;'</span> S* ]* ;</span><br><span class="line"></span><br><span class="line">keyframe_selector: [ FROM_SYM | TO_SYM | PERCENTAGE ] S* [ <span class="string">','</span> S* [ FROM_SYM | TO_SYM | PERCENTAGE ] S* ]*;</span><br><span class="line"></span><br><span class="line">@&#123;K&#125;&#123;E&#125;&#123;Y&#125;&#123;F&#125;&#123;R&#125;&#123;A&#125;&#123;M&#125;&#123;E&#125;&#123;S&#125;   &#123;<span class="keyword">return</span> KEYFRAMES_SYM;&#125;</span><br><span class="line">&#123;F&#125;&#123;R&#125;&#123;O&#125;&#123;M&#125;                   &#123;<span class="keyword">return</span> FROM_SYM;&#125;</span><br><span class="line">&#123;T&#125;&#123;O&#125;                         &#123;<span class="keyword">return</span> TO_SYM;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1_关键帧的缓动函数">4.1 关键帧的缓动函数</h3><p>关键帧样式同样可以定义缓动函数，这个缓动函数将用于动画从这个帧运行到下个帧。</p>
<p><strong>实例3：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">keyframes</span> bounce </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="tag">from</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">animation-timing-function</span>:<span class="value"> ease-out</span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><br><span class="line">  25% <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">50px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">animation-timing-function</span>:<span class="value"> ease-in</span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><br><span class="line">  50% <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">animation-timing-function</span>:<span class="value"> ease-out</span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><br><span class="line">  75% <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">75px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">animation-timing-function</span>:<span class="value"> ease-in</span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">to</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动画名为<code>bounce</code>的动画指定了五个关键帧。在第一个关键帧到第二个关键帧之间使用的缓动函数为<code>ease-out</code>（也即0%到25%），25%到50%之间使用的缓动函数为<code>ease-in</code>，以此类推了。</p>
<p>在<code>100%</code>或<code>to</code>上指定的缓动函数将被忽略。</p>
<h3 id="4-2_animation-name属性">4.2 <code>animation-name</code>属性</h3><p><code>animation-name</code>属性定义了应用的动画列表。每一个名字被用于选择关键帧规则，以提供该动画的属性值。如果该名字没有匹配任何关键帧<code>@</code>规则，没有属性进行动画且动画将不会执行（这里指的是该名字指定的动画，而不是说整个动画不会执行）。此外，如果动画名称为<code>none</code>，那么将不会有动画。这可以用于覆盖层叠而来的任何动画。如果多个动画尝试修改同一个属性，那么靠近列表的最后的动画会胜出。</p>
<p>对于下面列出的其他动画属性的值，按名称列出的每个动画应该有相应的值（简单点说，比如我定义了animation-name: aa bb; 在animation-duration中应该有相应的值，例如animation-name: 2s 4s;或者其他）。如果对于其他动画属性值的列表不具有相同的长度，<code>animation-name</code>列表的长度决定了启动动画时检查每个列表项的数量。列表是从第一个值开始匹配：不使用尾部剩余的值。如果其他属性中的一个没有足够的逗号分隔的值去匹配<code>animation-name</code>属性值的数量时，用户代理必须通过列表中的值计算，直到有足够的值。这些截断和重复不影响属性的计算值。</p>
<ul>
<li>名称：<code>animation-name</code></li>
<li>取值：<code>&lt;single-animation-name&gt; [ ‘,’ &lt;single-animation-name&gt; ]*</code></li>
<li>初始值：<code>none</code></li>
<li>应用于：所有元素，<code>::before</code>和<code>::after</code>伪元素</li>
<li>继承：无</li>
<li>可否动画：否</li>
<li>百分比：<code>N/A</code></li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<p>其中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;single-animation-name&gt; = none | &lt;IDENT&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-3_animation-duration属性">4.3 <code>animation-duration</code>属性</h3><p><code>animation-duration</code>属性一个动画完成一个周期的时间。</p>
<ul>
<li>名称：<code>animation-duration</code></li>
<li>取值：<code>&lt;time&gt; [, &lt;time&gt;]*</code></li>
<li>初始值：<code>0s</code></li>
<li>应用于：所有元素，<code>::before</code>和<code>::after</code>伪元素</li>
<li>继承：无</li>
<li>可否动画：否</li>
<li>百分比：<code>N/A</code></li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<p>初始值为<code>0s</code>，这意味着动画不花时间。当持续时间为<code>0s</code>时，<code>animation-fill-mode</code>仍然会被应用，所以一个动画填充为<code>backwards</code>将在一个延迟时间（如果有的话）后显示<code>0%</code>的关键帧，填充为<code>forwards</code>的将显示<code>100%</code>的关键帧，即使动画是瞬时的。同样，动画事件也会被触发。一个负的<code>animation-duration</code>值将导致该声明无效。</p>
<h3 id="4-4_animation-timing-function属性">4.4 <code>animation-timing-function</code>属性</h3><p><code>animation-timing-function</code>属性描述了动画在一个周期内如何进展。更多关于缓动函数：<a href="http://www.w3.org/TR/css3-animations/#CSS3-TRANSITIONS" target="_blank" rel="external">http://www.w3.org/TR/css3-animations/#CSS3-TRANSITIONS</a></p>
<ul>
<li>名称：<code>animation-timing-function</code></li>
<li>取值：<code>&lt;single-timing-function&gt; [ ‘,’ &lt;single-timing-function&gt; ]*</code></li>
<li>初始值：<code>ease</code></li>
<li>应用于：所有元素，<code>::before</code>和<code>::after</code>伪元素</li>
<li>继承：无</li>
<li>可否动画：否</li>
<li>百分比：<code>N/A</code></li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<h3 id="4-5_animation-iteration-count属性">4.5 <code>animation-iteration-count</code>属性</h3><p>这个属性看名字就能看出来了，它定义动画运行周期的次数。初始值为<code>1</code>，意味着动画会从开始到结束运行一次。一个<code>infinite</code>值将会使动画运行无限次。非整数的值将会导致动画运行到一个循环的一部分结束。<code>animation-iteration-count</code>属性值为负值时是无效的。这个属性通常结合<code>animation-direction</code>属性值的<code>alternate</code>使用，这会导致动画交替运行。</p>
<ul>
<li>名称：<code>animation-iteration-count</code></li>
<li>取值：<code>&lt;single-animation-iteration-count&gt; [ ‘,’ &lt;single-animation-iteration-count&gt; ]*</code></li>
<li>初始值：1</li>
<li>应用于：所有元素，<code>::before</code>和<code>::after</code>伪元素</li>
<li>继承：无</li>
<li>可否动画：否</li>
<li>百分比：<code>N/A</code></li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<p>其中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;single-animation-iteration-count&gt; = infinite | &lt;number&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-6_animation-direction属性">4.6 <code>animation-direction</code>属性</h3><p><code>animation-direction</code>属性定义了动画运行的方向。当一个动画运行是<code>reverse</code>（倒着运行）时，缓动函数也将是相反的。例如，当指定的缓动函数为<code>ease-in</code>，倒着运行时缓动函数为<code>ease-out</code>。</p>
<ul>
<li>名称：<code>animation-direction</code></li>
<li>取值：<code>&lt;single-animation-direction&gt; [ ‘,’ &lt;single-animation-direction&gt; ]*</code></li>
<li>初始值：<code>normal</code></li>
<li>应用于：所有元素，<code>::before</code>和<code>::after</code>伪元素</li>
<li>继承：无</li>
<li>可否动画：否</li>
<li>百分比：<code>N/A</code></li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<p>其中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;single-animation-direction&gt; = normal | reverse | alternate | alternate-reverse</span><br></pre></td></tr></table></figure>
<p>属性值的意义：</p>
<p><strong>normal</strong><br>动画的所有迭代按着指定的运行</p>
<p><strong>reverse</strong><br>动画的所有迭代按着定义的相反方向来运行</p>
<p><strong>alternate</strong><br>动画周期在奇数次按着<code>normal</code>方向运行，偶数次按着<code>reverse</code>方向运行。也就是交替运行</p>
<p><strong>alternate-reverse</strong><br>这个和<code>alternate</code>相反。奇数次按着<code>reverse</code>方向运行，偶数次按着<code>normal</code>方向运行</p>
<h3 id="4-7_animation-play-state属性">4.7 <code>animation-play-state</code>属性</h3><p><code>animation-play-state</code>属性定义了动画是否运行还是暂停。一个运行中的动画可以通过设置该属性为<code>pasued</code>。为了继续运行这个暂停的动画可以设置该属性为<code>running</code>。一个暂停的动画将继续处于静止状态显示动画的当前值，就好像动画的时间是常数。当已暂停的动画被恢复，它从当前值重新启动，而没必要从动画的开始。</p>
<ul>
<li>名称：<code>animation-play-state</code></li>
<li>取值：<code>&lt;single-animation-play-state&gt; [ ‘,’ &lt;single-animation-play-state&gt; ]*</code></li>
<li>初始值：<code>running</code></li>
<li>应用于：所有元素，<code>::before</code>和<code>::after</code>伪元素</li>
<li>继承：无</li>
<li>可否动画：否</li>
<li>百分比：<code>N/A</code></li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<p>其中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;single-animation-play-state&gt; = running | paused</span><br></pre></td></tr></table></figure>
<h3 id="4-8_animation-delay属性">4.8 <code>animation-delay</code>属性</h3><p><code>animation-delay</code>属性定义了动画什么时候开始。它允许动画开始执行一段时间（就是延迟一段时间执行）后在它被应用之后。当<code>animation-delay</code>的值为<code>0s</code>，意味着动画会在被应用后立即执行。否则，该值指定了从动画被应用时刻的偏移，以及动画将用该偏移延迟执行。</p>
<p>如果<code>animation-delay</code>的值是负的时间偏移，则动画将在它被应用的时刻执行，但是会出现在指定的偏移开始执行。也就是说，动画会出现从运行周期的一部分开始。</p>
<ul>
<li>名称：<code>animation-delay</code></li>
<li>取值：<code>&lt;time&gt; [, &lt;time&gt;]*</code></li>
<li>初始值：0s</li>
<li>应用于：所有元素，<code>::before</code>和<code>::after</code>伪元素</li>
<li>继承：无</li>
<li>可否动画：否</li>
<li>百分比：<code>N/A</code></li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<h3 id="4-9_animation-fill-mode属性">4.9 <code>animation-fill-mode</code>属性</h3><p><code>animation-fill-mode</code>属性定义了什么值被应用在动画之外的执行时间。默认情况下，动画不会影响在它被应用的时间和它开始执行的时间之间的属性值。同样，默认情况下动画也不会影响在动画结束后的属性值。<code>animation-fill-mode</code>可以覆盖这种行为。</p>
<p>如果<code>animation-fill-mode</code>的值为<code>backwards</code>，则动画会应用在定义在动画第一个迭代开始的关键帧的属性值，在定义在<code>animation-delay</code>的时间之间。</p>
<p>如果<code>animation-fill-mode</code>的值为<code>forwards</code>，则在动画结束后，动画将应用在动画结束后的属性值。</p>
<p>如果<code>animation-fill-mode</code>的值为<code>both</code>，则动画会遵循<code>backwards</code>和<code>forwards</code>的规则。也就是说，它会扩展两个方向的动画属性。</p>
<ul>
<li>名称：<code>animation-fill-mode</code></li>
<li>取值：<code>&lt;single-animation-fill-mode&gt; [ ‘,’ &lt;single-animation-fill-mode&gt; ]*</code></li>
<li>初始值：<code>none</code></li>
<li>应用于：所有元素，<code>::before</code>和<code>::after</code>伪元素</li>
<li>继承：无</li>
<li>可否动画：否</li>
<li>百分比：<code>N/A</code></li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<p>其中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;single-animation-fill-mode&gt; = none | forwards | backwards | both</span><br></pre></td></tr></table></figure>
<h3 id="4-10_animation简写属性">4.10 <code>animation</code>简写属性</h3><p><code>animation</code>属性是一个逗号分隔的动画定义列表，其中结合了7个动画属性成单个组件的值。</p>
<ul>
<li>名称：<code>animation</code></li>
<li>取值：<code>&lt;single-animation&gt; [ ‘,’ &lt;single-animation&gt; ]*</code></li>
<li>初始值：看单个属性的初始值</li>
<li>应用于：所有元素，<code>::before</code>和<code>::after</code>伪元素</li>
<li>继承：无</li>
<li>可否动画：否</li>
<li>百分比：<code>N/A</code></li>
<li>媒体：视觉</li>
<li>计算值：看单个属性</li>
</ul>
<p>其中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;single-animation&gt; = &lt;single-animation-name&gt; || &lt;time&gt; || &lt;single-animation-timing-function&gt; || &lt;time&gt; || &lt;single-animation-iteration-count&gt; || &lt;single-animation-direction&gt; || &lt;single-animation-fill-mode&gt; || &lt;single-animation-play-state&gt;</span><br></pre></td></tr></table></figure>
<p>要注意，在每个动画定义中顺序是非常重要的：第一个<code>&lt;time&gt;</code>值被赋给<code>animation-duration</code>，第二个<code>&lt;time&gt;</code>值赋给<code>animation-delay</code>。</p>
<h2 id="5_动画事件">5 动画事件</h2><p>事件相关可以自己看文档啦：<a href="http://www.w3.org/TR/css3-animations/#animation-events" target="_blank" rel="external">http://www.w3.org/TR/css3-animations/#animation-events</a></p>
<p>这里说下动画的三个事件：</p>
<ul>
<li>animationStart：发生在动画开始</li>
<li>animationEnd：发生在动画结束</li>
<li>animationiteration：发生在动画每个迭代的结束</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/CSS/">CSS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Animation/">Animation</a><a href="/tags/CSS3/">CSS3</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/01/21/css3-animation/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/01/21/css3-animation/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/18/css3-transform/" title="CSS3 Transform" itemprop="url">CSS3 Transform</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-01-18T03:47:42.000Z" itemprop="datePublished"> 發表於 2015-01-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文是<a href="http://www.w3.org/TR/css-transforms-1/" target="_blank" rel="external">CSS Transforms Module Level 1</a>的翻译，翻译主要还是自己去熟悉标准、学习标准，最后再分享出来。文中如有读不通的地方可以移步官方文档哟，英语渣渣呀。</p>
<h2 id="摘要">摘要</h2><p><code>CSS</code>变换允许元素的样式在二维或三维空间变换。该规范集合了<a href="http://www.w3.org/TR/css3-2d-transforms/" target="_blank" rel="external">CSS 2D 变换</a>、<a href="http://www.w3.org/TR/css3-3d-transforms/" target="_blank" rel="external">CSS 3D 变换</a>和<a href="http://www.w3.org/TR/2009/WD-SVG-Transforms-20090320/" target="_blank" rel="external">SVG 变换</a>的规范。<a href="http://www.w3.org/TR/CSS/" target="_blank" rel="external">CSS</a>是一种用于在<code>screen</code>、<code>paper</code>等中描述结构化文档（例如：HTML和XML）的语言。</p>
<h2 id="1_介绍">1 介绍</h2><p><code>CSS</code>的<a href="http://www.w3.org/TR/REC-CSS2/visuren.html" target="_blank" rel="external">视觉格式化模型</a>在每一个定位元素里描述了一个坐标系统。在该坐标空间中的位置和大小可以被看作是以像素来表达，</p>
<p>这个坐标空间可以通过<a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform" target="_blank" rel="external">transform</a>属性来修改。使用<code>transform</code>，元素可以在二维或三维空间转化，旋转和伸缩。</p>
<p>一些额外到属性使得变换更加简单，且允许作者控制如何与被嵌套的三维变换进行交互。</p>
<ul>
<li><a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform-origin" target="_blank" rel="external"><code>transform-origin</code></a>属性提供了一种方便的控制被应用变换到元素变换时的原点的方法。</li>
<li><a href="http://www.w3.org/TR/css-transforms-1/#propdef-perspective" target="_blank" rel="external"><code>perspective</code></a>属性允许作者使子元素与三维空间变换出现，就好像它们在一个共同的三维空间中一样。<a href="http://www.w3.org/TR/css-transforms-1/#propdef-perspective-origin" target="_blank" rel="external">perspective-origin</a>属性提供了控制哪个透视被应用的原点，有效的改变了<code>消失点（vanishing point）</code>的位置。</li>
<li><a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform-style" target="_blank" rel="external"><code>transform-style</code></a>允许3D变换的元素和它们3D变换的后代共享一个共同的三维空间，允许三维对象等级制度的构建。</li>
<li><a href="http://www.w3.org/TR/css-transforms-1/#propdef-backface-visibility" target="_blank" rel="external"><code>backface-visibility</code></a>属性</li>
</ul>
<blockquote>
<p>注意：然而<a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform" target="_blank" rel="external">transform</a>属性的有些值允许一个元素在三维坐标系统中被变换，该元素自身却不是一个三维对象。作为替代，它们存在于一个两维平面（平坦面），并没有任何深度。</p>
</blockquote>
<h2 id="2_模块交互">2 模块交互</h2><p>该模块定义了一组CSS属性，它会影响应用了这些属性元素的视觉渲染；这些影响会在元素根据<a href="http://www.w3.org/TR/css-transforms-1/#css21" target="_blank" rel="external">CSS21</a>中<a href="http://www.w3.org/TR/CSS2/visuren.html" target="_blank" rel="external">视觉格式模型</a>确定尺寸和位置后被应用。这些属性的一些值会导致创建一个<a href="http://www.w3.org/TR/CSS2/visuren.html#containing-block" target="_blank" rel="external">包含块</a>，或<a href="http://www.w3.org/TR/CSS21/visuren.html#x43" target="_blank" rel="external">堆栈上下文</a>。</p>
<p>三维变换同样会影响到元素的视觉分层，并且因此会覆盖在<a href="http://www.w3.org/TR/css-transforms-1/#css21" target="_blank" rel="external">CSS21</a>中<a href="http://www.w3.org/TR/CSS2/zindex.html" target="_blank" rel="external">附录 E</a>中描述的从后到前的绘制顺序。</p>
<p>当元素的<a href="http://dev.w3.org/csswg/css-backgrounds-4/#background-attachment" target="_blank" rel="external">background-attachment</a>的值为<code>fixed</code>时，变换还会影响到元素背景的渲染，这个在<a href="http://www.w3.org/TR/css-transforms-1/#css3bg" target="_blank" rel="external"><br>CSS3BG</a>中被定义。</p>
<h2 id="3_CSS值">3 CSS值</h2><p>此规范遵循<a href="http://www.w3.org/TR/css-transforms-1/#css21" target="_blank" rel="external">CSS21</a>中<a href="http://www.w3.org/TR/CSS21/about.html#property-defs" target="_blank" rel="external">CSS属性定义约定</a>。值的类型在此规范中没有定义，而是定义在<a href="http://www.w3.org/TR/css-transforms-1/#css3val" target="_blank" rel="external">CSS Values and Units Module Level 3</a>中定义。</p>
<p>除了在它们的定义中列出的属性的特定值，在这个规范中定义的所有属性也接受了<a href="http://www.w3.org/TR/CSS21/cascade.html#value-def-inherit" target="_blank" rel="external">inherit</a>关键字作为他们的属性值。因为可读性原因，并未明确重复。</p>
<h2 id="4_术语">4 术语</h2><p>当在本规范中使用时，术语在本节被分配了含义。</p>
<p><strong>边界框（bounding box）</strong><br>边界框是一个对于没有关联<code>CSS</code>布局中的所有<code>SVG</code>元素的对象边界框和所有其他元素的边框(border box)。一个<code>table</code>的边界框是<a href="http://www.w3.org/TR/CSS21/tables.html#model" target="_blank" rel="external">table包含框</a>的边框，而不是它的<code>table</code>框。</p>
<p><strong>可变换元素（transformable element）</strong><br>一个可变换元素是下面一种类型的元素：</p>
<ul>
<li>一个元素的布局由<code>CSS</code>盒模型支配，且它是一个<a href="http://www.w3.org/TR/CSS2/visuren.html#block-level" target="_blank" rel="external">block-level</a>或<a href="http://www.w3.org/TR/CSS2/visuren.html#x13" target="_blank" rel="external">原子的inline-level</a>元素，或者它的<a href="http://www.w3.org/TR/CSS21/visuren.html#propdef-display" target="_blank" rel="external">display</a>属性被计算成<code>table-row</code>、<code>table-row-group</code>、<code>table-header-group</code>、<code>table-footer-group</code>、<code>table-cell</code>或<code>table-caption</code></li>
<li>一个在<code>SVG</code>命名空间的元素，且它不受<code>CSS</code>盒模型支配，且它有属性<a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform" target="_blank" rel="external">transform</a>、<a href="http://www.w3.org/TR/2011/REC-SVG11-20110816/pservers.html#PatternElementPatternTransformAttribute" target="_blank" rel="external">patternTransform</a>或<a href="http://www.w3.org/TR/2011/REC-SVG11-20110816/pservers.html#LinearGradientElementGradientTransformAttribute" target="_blank" rel="external">gradientTransform</a></li>
</ul>
<p><strong>用户坐标系（user coordinate system）</strong><br><strong>局部坐标系（local coordinate system）</strong><br>在一般情况下，一个坐标系定义了当前画布上的位置和距离。当前局部坐标系（也包含用户坐标系）为当前活动的坐标系，这是用于定义坐标和长度如何被定位和计算，它们各自在当前画布中。</p>
<p><strong>透视矩阵（perspective matrix）</strong><br>从<a href="http://www.w3.org/TR/css-transforms-1/#propdef-perspective" target="_blank" rel="external">perspective</a>和<a href="http://www.w3.org/TR/css-transforms-1/#propdef-perspective-origin" target="_blank" rel="external">perspective-origin</a>属性值中计算出来的矩阵，将在下面讲到。</p>
<p><strong>变换矩阵（transformation matrix）</strong><br>一个矩阵定义了数学上从一个坐标系映射到另一个。它是从<a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform" target="_blank" rel="external">transform</a>和<a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform-origin" target="_blank" rel="external">transform-origin</a>属性的值计算而来，将在下面讲到。</p>
<p><strong>当前变换矩阵（current transformation matrix）</strong><br>一个矩阵定义了从局部坐标系到视口坐标系（viewport coordinate system）的映射。</p>
<p><strong>累计3D变换矩阵（accumulated 3D transformation matrix）</strong><br>一个矩阵从元素的<a href="http://www.w3.org/TR/css-transforms-1/#3d-rendering-context" target="_blank" rel="external">3D渲染上下文</a>中计算出来，将在下面讲到。</p>
<p><strong>2D矩阵（2D matrix）</strong><br>一个6个项的3<em>2的变换矩阵，或者是16个项的4</em>4矩阵且在这些项中m31, m32, m13, m23, m43, m14, m24, m34等于0，m33, m44等于1。</p>
<p><strong>3D矩阵（3D matrix）</strong><br>一个4*4的矩阵且不履行的2D矩阵的要求。</p>
<p><strong>特性变换函数（identity transform function）</strong><br>一个<a href="http://www.w3.org/TR/css-transforms-1/#transform-functions" target="_blank" rel="external">变换函数</a>其实等价于一个特性4*4矩阵（看这里：<a href="http://www.w3.org/TR/css-transforms-1/#mathematical-description" target="_blank" rel="external">Mathematical Description of Transform Functions</a>）。特性变换函数的例子有<code>translate(0)</code>、<code>translate3d(0, 0, 0)</code>、<code>translateX(0)</code>、<code>translateY(0)</code>、<code>translateZ(0)</code>、<code>scale(1)</code>、<code>scaleX(1)</code>、<code>scaleY(1)</code>、<code>scaleZ(1)</code>、<code>rotate(0)</code>、<code>rotate3d(1, 1, 1, 0)</code>、<code>rotateX(0)</code>、<code>rotateY(0)</code>、<code>rotateZ(0)</code>、<code>skew(0, 0)</code>、<code>skewX(0)</code>、<code>skewY(0)</code>、<code>matrix(1, 0, 0, 1, 0, 0)</code>和<code>matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)</code>。一种特别的情况是透视（perspective）：<code>perspective(infinity)</code>。<code>M34</code>的值变得无穷小，变换函数因此假定它等于单位矩阵。</p>
<p><strong>3D渲染上下文（3D rendering context）</strong><br>一个包含块层次结构的一个或多个水平，通过元素的<a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform-style" target="_blank" rel="external">transform-style</a>属性的<code>preserve-3d</code>计算值实例化，其元素有一个共同的三维坐标系。</p>
<h2 id="5_二维子集（Two_Dimensional_Subset）">5 二维子集（Two Dimensional Subset）</h2><p>用户代理可能不能总是渲染出三维变换，那么它们只支持该规范的一个二维子集。在这种情况下，<a href="http://www.w3.org/TR/css-transforms-1/#three-d-transform-functions" target="_blank" rel="external">三维变换</a>和<a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform-style" target="_blank" rel="external">transform-style</a>、<a href="http://www.w3.org/TR/css-transforms-1/#propdef-perspective" target="_blank" rel="external">perspective</a>、<a href="http://www.w3.org/TR/css-transforms-1/#propdef-perspective-origin" target="_blank" rel="external">perspective-origin</a>和<a href="http://www.w3.org/TR/css-transforms-1/#propdef-backface-visibility" target="_blank" rel="external">backface-visibility</a>属性将不被支持。<a href="http://www.w3.org/TR/css-transforms-1/#3d-transform-rendering" target="_blank" rel="external">3D变换渲染</a>章节也不会应用到。矩阵分解使用从“图形宝石II，由吉姆·阿尔沃编辑”中的<code>unmatrix</code>的方法所采取的技术，简化为2D的情况。<a href="http://www.w3.org/TR/css-transforms-1/#mathematical-description" target="_blank" rel="external">Mathematical Description of Transform Functions</a>章节荏苒是有效的，只是它们减少为一个3*3的变换矩阵，其中<code>a</code>等于<code>m11</code>，<code>b</code>等于<code>m12</code>，<code>c</code>等于<code>m21</code>，<code>d</code>等于<code>m22</code>，<code>e</code>等于<code>m41</code>，<code>f</code>等于<code>m42</code>。</p>
<center><br><img src="http://www.w3.org/TR/css-transforms-1/3x3matrix.png" alt="enter image description here"><br></center><br><center><br>图片一：二维变换的3*3矩阵<br></center>

<p><strong>实例一：</strong></p>
<p>如果用户代理不提供三维变换支持，作者可以很容易地提供一个备用方案。下面的例子中对于<a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform" target="_blank" rel="external">transform</a>属性有两条属性定义。第一个定义包含了两个二维的变换函数。第二个包含了一个二维的和一个三维的变换函数。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">scale</span>(<span class="number">2</span>) <span class="function">rotate</span>(<span class="number">45deg</span>)</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">scale</span>(<span class="number">2</span>) <span class="function">rotate3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">45deg</span>)</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>有了3D的支持，第二条定义会覆盖第一条。如果没有3D的支持，第二条定义是不合法的，用户代理会退回到第一条定义。</p>
<h2 id="6_变换渲染模型（The_Transform_Rendering_Model）">6 变换渲染模型（The Transform Rendering Model）</h2><p>当指定了一个除<a href="http://www.w3.org/TR/css-transforms-1/#none" target="_blank" rel="external">none</a>之外的<a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform" target="_blank" rel="external">transform</a>属性值时在元素上建立了一个<a href="http://www.w3.org/TR/css-transforms-1/#local-coordinate-system" target="_blank" rel="external">局部坐标系</a>，并且它被应用。映射是从元素已经渲染到的局部坐标系中通过元素的<a href="http://www.w3.org/TR/css-transforms-1/#transformation-matrix" target="_blank" rel="external">变换矩阵</a>给定。变换是累积的。也就是说，元素在父坐标系中建立自己的局部坐标系。从用户的视角来看，一个元素有效地累积祖先的所有<a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform" target="_blank" rel="external">变换</a>属性以及任何的局部变换被应用。这些变换的累积为元素定义了<a href="http://www.w3.org/TR/css-transforms-1/#current-transformation-matrix-ctm" target="_blank" rel="external">当前变换矩阵（current transformation matrix）</a>（CTM）。</p>
<p>坐标空间是有两个轴的一个坐标系：<code>X</code>轴是水平向右增加，<code>Y</code>轴是垂直向下增加。三维变换函数则扩展了这个坐标空间到三维，添加了垂直于屏幕平面一个<code>Z</code>轴，并且沿着观察者的方向增加。</p>
<center><br><img src="http://www.w3.org/TR/css-transforms-1/coordinates.svg" alt="enter image description here"><br></center>

<center><br>图片2：初始坐标空间的示范<br></center>

<p><a href="http://www.w3.org/TR/css-transforms-1/#transformation-matrix" target="_blank" rel="external">变换矩阵</a>是通过<a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform" target="_blank" rel="external">transform</a>和<a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform-origin" target="_blank" rel="external">transform-origin</a>通过以下步骤计算而来：</p>
<ol>
<li>通过特性矩阵开始</li>
<li>通过<a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform-origin" target="_blank" rel="external">transform-origin</a>的计算出的<code>X</code>，<code>Y</code>值来转换</li>
<li>从左到右乘以在<a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform" target="_blank" rel="external">transform</a>属性中的每一个变换函数</li>
<li>通过<a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform-origin" target="_blank" rel="external">transform-origin</a>的负计算<code>X</code>，<code>Y</code>值来转换</li>
</ol>
<p>变换应用到<a href="http://www.w3.org/TR/css-transforms-1/#transformable-element" target="_blank" rel="external">可变换元素</a>上。</p>
<blockquote>
<p>注意：变换会影响画布上的视觉布局（visual layout），但对CSS布局本身没有影响。这也意味着不会影响在IE浏览器下的<a href="http://www.w3.org/TR/cssom-view/#dom-element-getclientrects" target="_blank" rel="external">getClientRects()</a>和标准浏览器的<a href="http://www.w3.org/TR/cssom-view/#dom-element-getboundingclientrect" target="_blank" rel="external">getBoundingClientRect()</a>函数的值。</p>
</blockquote>
<p><strong>实例二：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">translate</span>(<span class="number">100px</span>, <span class="number">100px</span>)</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码会将元素在<code>X</code>和<code>Y</code>方向上移动<code>100px</code>。</p>
<center><br><img src="http://www.w3.org/TR/css-transforms-1/examples/translate1.svg" alt="enter image description here"><br></center>

<p><strong>实例三：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">transform-origin</span>:<span class="value"> <span class="number">50px</span> <span class="number">50px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">rotate</span>(<span class="number">45deg</span>)</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p><a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform-origin" target="_blank" rel="external">transform-origin</a>属性将变换的原点在<code>X</code>和<code>Y</code>方向上分别移动了<code>50px</code>。旋转变换将元素以原点顺时针方向旋转45度。在所有的变换函数被应用后，原点的转化被转化为在<code>X</code>和<code>Y</code>方向上返回<code>-50px</code>。</p>
<center><br><img src="http://www.w3.org/TR/css-transforms-1/examples/origin1.svg" alt="enter image description here"><br></center>

<p><strong>实例四：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">translate</span>(<span class="number">80px</span>, <span class="number">80px</span>) <span class="function">scale</span>(<span class="number">1.5</span>, <span class="number">1.5</span>) <span class="function">rotate</span>(<span class="number">45deg</span>)</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>该变换分别将元素在<code>X</code>和<code>Y</code>方向移动<code>80px</code>，然后将元素缩放150%，然后绕<code>Z</code>轴顺时针旋转45度。可以注意到缩放和旋转是以元素的中心来操作的，由于元素具有<code>50％ 50％</code>的默认变换原点。</p>
<center><br><img src="http://www.w3.org/TR/css-transforms-1/examples/compound_transform.svg" alt="enter image description here"><br></center>

<blockquote>
<p>注意：一个相同的渲染可以通过用等效变换的嵌套元素来获得：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"transform: translate(80px, 80px)"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"transform: scale(1.5, 1.5)"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"transform: rotate(45deg)"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于布局是由CSS盒模型支配的元素，<code>transform</code>属性不影响变换元素周围的内容的流动。然而，溢出区域的范围考虑到了被变换元素。它的行为类似于元素通过相对定位来偏移时的情况。因此，如果<a href="http://www.w3.org/TR/css-overflow-3/#overflow" target="_blank" rel="external">overflow</a>属性的值为<code>scroll</code>或<code>auto</code>时，根据需要为了看到内容，滚动条会出现，因为被变换到了可视区域的外面。</p>
<p>对于布局是由CSS盒模型支配的元素，任何非<a href="http://www.w3.org/TR/css-transforms-1/#none" target="_blank" rel="external">none</a>值的<code>transform</code>会导致创建一个堆栈上下文和包含块。这个对象作为一个包含块，为它固定定位的后代。</p>
<p>在根元素上的<a href="http://www.w3.org/TR/css3-background/#fixed0" target="_blank" rel="external">固定背景</a>受到任何为那个元素被指定的变换的影响。对于任何其他元素被一个变换所影响（例如，应用一个变换到它们自身或者任何它们的祖先元素），当<a href="http://dev.w3.org/csswg/css-backgrounds-4/#background-attachment" target="_blank" rel="external">background-attachment</a>属性的值为<code>fixed</code>时，它会被认为好像值是<code>scroll</code>。<a href="http://dev.w3.org/csswg/css-backgrounds-4/#background-attachment" target="_blank" rel="external">background-attachment</a>的计算值不会受到影响。</p>
<h3 id="6-1_3D变换渲染（3D_Transform_Rendering）">6.1 3D变换渲染（3D Transform Rendering）</h3><p>通常情况下，元素是在平面上渲染，并且作为其包含块会被渲染到同一平面。通常，这个平面就是被页面其他部分共享的平面。二维变换函数可以改变的元素的呈现，但是元素仍然作为其包含块被渲染到同一平面。</p>
<p>三维变换可导致变换矩阵具有非零的<code>Z</code>分量。这会导致元素对于它的包含块渲染到不同到平面，这可能会导致影响那个元素相对于其他元素的从前到后的渲染顺序，以及会导致它与其他元素相交。这种行为取决于元素是否是<a href="http://www.w3.org/TR/css-transforms-1/#3d-rendering-context" target="_blank" rel="external">3D渲染上下文</a>中的一员，将在下面描述。</p>
<p><strong>实例五：</strong></p>
<p>这个例子展示了被应用了三维变换元素的效果。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line"><span class="tag">div</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">150px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">150px</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.container</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid black</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#ccc</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.transformed</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">rotateY</span>(<span class="number">50deg</span>)</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> blue</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"transformed"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<center><br><img src="http://www.w3.org/TR/css-transforms-1/examples/simple-3d-example.png" alt="enter image description here"><br></center>

<p>该变换沿着<code>Y</code>轴旋转了50度。可以注意到这会使蓝色的盒子更窄，但不是立体的。</p>
<p><a href="http://www.w3.org/TR/css-transforms-1/#propdef-perspective" target="_blank" rel="external">perspective</a>和<a href="http://www.w3.org/TR/css-transforms-1/#propdef-perspective-origin" target="_blank" rel="external">perspective-origin</a>属性可以被用于添加一种深度的感觉到场景中，它是使元素在<code>Z</code>轴更高（更接近观看者），从而会显得更大，那些远的将会显得更小。<code>d</code>缩放成比例于<code>d/(d − Z)</code>，<a href="http://www.w3.org/TR/css-transforms-1/#propdef-perspective" target="_blank" rel="external">perspective</a>的值，是从绘图平面（drawing plane）到观看者的眼睛假定位置的距离。</p>
<center><br><img src="http://www.w3.org/TR/css-transforms-1/perspective_distance.png" alt="enter image description here"><br></center>

<center><br>图片3：示意图展示了缩放如何依赖于<a href="http://www.w3.org/TR/css-transforms-1/#propdef-perspective" target="_blank" rel="external">perspective</a>属性和<code>Z</code>的位置。在上面的示意图，<code>Z</code>是<code>d</code>的一半。为了使其显示的原始圆（实线轮廓）出现在Z（虚线圆），画布上的实体圆将扩大两倍，如浅蓝色的圆。在底部的示意图，圆按比例缩小，致使虚线圆出现在画布后面，并且z的大小是距原始位置三分之一。<br></center>

<p>通常情况下，观看者的眼睛的假定位置为图的中心。这个位置可以根据需要移动－例如，如果一个网页包含多个图形应该共享一个共同的视角，可以通过设置<a href="http://www.w3.org/TR/css-transforms-1/#propdef-perspective-origin" target="_blank" rel="external">perspective-origin</a>。</p>
<center><br><img src="http://www.w3.org/TR/css-transforms-1/perspective_origin.png" alt="enter image description here"><br></center>

<center><br>图片4：示意图展示了将视角上移的效果。<br></center>

<p><a href="http://www.w3.org/TR/css-transforms-1/#perspective-matrix" target="_blank" rel="external">透视矩阵</a>将按照以下来计算：</p>
<ol>
<li>通过特性矩阵开始</li>
<li>通过<a href="http://www.w3.org/TR/css-transforms-1/#propdef-perspective-origin" target="_blank" rel="external">perspective-origin</a>的计算<code>X</code>，<code>Y</code>值来转换</li>
<li>乘以从<a href="http://www.w3.org/TR/css-transforms-1/#propdef-perspective" target="_blank" rel="external">perspective</a>变换函数获得的矩阵，其中长度是由<a href="http://www.w3.org/TR/css-transforms-1/#propdef-perspective" target="_blank" rel="external">perspective</a>属性的值提供</li>
<li>通过<a href="http://www.w3.org/TR/css-transforms-1/#propdef-perspective-origin" target="_blank" rel="external">perspective-origin</a>的负计算<code>X</code>，<code>Y</code>值来转换</li>
</ol>
<p><strong>实例6：</strong></p>
<p>这个例子说明了<code>perspective</code>如何被用于一个三维变换，使其看起来更加真实。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line"><span class="tag">div</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">150px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">150px</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.container</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">perspective</span>:<span class="value"> <span class="number">500px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid black</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.transformed</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">rotateY</span>(<span class="number">50deg</span>)</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> blue</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"transformed"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<center><br><img src="http://www.w3.org/TR/css-transforms-1/examples/simple-perspective-example.png" alt="enter image description here"><br></center>

<p>内部的元素和前面的例子中是有着一样的变换，但它的渲染现在被它父元素的<code>perspective</code>属性影响。<code>perspective</code>导致有正的<code>Z</code>坐标（更接近观看者）的顶点在<code>X</code>和<code>Y</code>轴伸缩，使那些远离的按比例缩小，给人一种深度的感觉。</p>
<p>具有三维变换的元素，当它不包含在3D渲染上下文中，渲染时会有适当变换被应用，但不与任何其他元素相交。三维变换在这种情况下，可以被认为就像一个喷绘效果，就像二维变换。类似地，变换不影响绘制顺序。例如，一个正Z平移变换使元素看起来更大，但不会导致元素渲染到没有Z平移元素的前面。</p>
<p>具有三维变换的元素，当它包含在3D渲染上下文中，它可以明显的与在相同3D渲染上下文中的其他元素进行交互；参与到相同3D渲染上下文的元素集合可能会隐藏彼此或者相交，基于它们计算后的变换。它们被渲染就好像它们全是兄弟元素，定位在一个共同的三维坐标空间。在该三维空间中每个元素的位置由通过是对于给定元素是一个包含块的每个元素建立了3D渲染上下文的元素的变换矩阵的累积决定，将在下面描述。</p>
<p><strong>实例7：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line"><span class="tag">div</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">150px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">150px</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.container</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">perspective</span>:<span class="value"> <span class="number">500px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid black</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.transformed</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">rotateY</span>(<span class="number">50deg</span>)</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> blue</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.child</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">transform-origin</span>:<span class="value"> top left</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">rotateX</span>(<span class="number">40deg</span>)</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> lime</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"transformed"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"child"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个例子展示了在<a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform-style" target="_blank" rel="external">transform-style: preserve-3d</a>缺席的情况下嵌套的3D变换如何被渲染。蓝色的<code>div</code>就像前面例子中一样被变换，其渲染受到了父元素<code>perspective</code>的影响。绿黄色的元素也有一个3D变换，是一个绕<code>X</code>轴的旋转。然而，绿黄的元素被渲染到父元素到平面上，因为它不是3D渲染上下文的一个成员，父元素是扁平的。</p>
<center><br><img src="http://www.w3.org/TR/css-transforms-1/examples/3d-rendering-context-flat.png" alt="enter image description here"><br></center>

<p>元素建立和参与到3D渲染上下文如下所示：</p>
<ul>
<li>一个<a href="http://www.w3.org/TR/css-transforms-1/#3d-rendering-context" target="_blank" rel="external">3D渲染上下文</a>由<a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform-style" target="_blank" rel="external">transform-style</a>属性的计算值为<code>preserve-3d</code>的<a href="http://www.w3.org/TR/css-transforms-1/#transformable-element" target="_blank" rel="external">可变换元素</a>建立，且它自身不是3D渲染上下文的一部分。需要注意的是这样的元素始终是一个包含块。一个建立了3D渲染上下文的元素同样会参与到那个上下文中。（这种就是上面的.container）</li>
<li>一个<a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform-style" target="_blank" rel="external">transform-style</a>属性的计算值为<code>preserve-3d</code>的元素，且它自身也参与到了一个3D渲染上下文，它扩展那个3D渲染上下文，而不是建立一个新的。</li>
<li>如果元素的包含块建立或扩展了3D渲染上下文，该元素则参与到了3D渲染上下文中。</li>
</ul>
<p>变换的最终值用于元素在3D渲染上下文中的渲染，这个最终值是由<a href="http://www.w3.org/TR/css-transforms-1/#accumulated-3d-transformation-matrix" target="_blank" rel="external">累计3D变换矩阵（accumulated 3D transformation matrix）</a>累积计算而来，下面计算步骤：</p>
<ol>
<li>通过特性矩阵开始</li>
<li>对于在3D渲染上下文的根和问题元素之间的任何包含块：<ol>
<li>将被累积的矩阵（accumulated matrix）乘以元素包含块上的透视矩阵（perspective matrix）（如果有包含块的话）。包含块不是必须为一个3D渲染上下文的成员。</li>
<li>应用被累积矩阵的平移，等价于元素相对于它的包含块在水平和垂直方向的偏移</li>
<li>将被累积的矩阵乘以<a href="http://www.w3.org/TR/css-transforms-1/#transformation-matrix" target="_blank" rel="external">变换矩阵</a></li>
</ol>
</li>
</ol>
<p><strong>实例8：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line"><span class="tag">div</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">150px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">150px</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.container</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">perspective</span>:<span class="value"> <span class="number">500px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid black</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.transformed</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">transform-style</span>:<span class="value"> preserve-<span class="number">3</span>d</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">rotateY</span>(<span class="number">50deg</span>)</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> blue</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.child</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">transform-origin</span>:<span class="value"> top left</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">rotateX</span>(<span class="number">40deg</span>)</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> lime</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个例子和前面的例子是相同的，只是在蓝色元素上额外添加了<a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform-style" target="_blank" rel="external">transform-style: preserve-3d</a>属性。蓝色元素现在建立了一个3D渲染上下文，其中的绿黄元素就是一个成员。现在蓝色和绿黄元素共享共同的三维空间，所以绿黄元素渲染为从其父元素倾斜，是由容器的透视所影响。</p>
<center><br><img src="http://www.w3.org/TR/css-transforms-1/examples/3d-rendering-context-3d.png" alt="enter image description here"><br></center>

<p>在相同的3D渲染上下文元素可以彼此相交。用户代理必须通过细分所描述的<a href="http://en.wikipedia.org/wiki/Newell%27s_algorithm" target="_blank" rel="external">纽维尔算法</a>交叉元素的面来渲染交集。</p>
<p>在3D渲染上下文中没有变换的元素在<code>Z=0</code>平面渲染，但仍可能与变换元素相交。</p>
<p>在一个3D渲染上下文内，非相交元素的渲染顺序是基于应用的被累积矩阵在<code>Z</code>轴上的位置。</p>
<p><strong>实例9：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line"><span class="tag">div</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">150px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">150px</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.container</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="function">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.3</span>)</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">transform-style</span>:<span class="value"> preserve-<span class="number">3</span>d</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">perspective</span>:<span class="value"> <span class="number">500px</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.container</span> &gt; <span class="tag">div</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.container</span> &gt; <span class="pseudo">:first-child</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">rotateY</span>(<span class="number">45deg</span>)</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> orange</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">10px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">135px</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.container</span> &gt; <span class="pseudo">:last-child</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">translateZ</span>(<span class="number">40px</span>)</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="function">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0.75</span>)</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">50px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该例子展示了元素在3D上下文中可以相交，容器元素为它自身和两个孩子建立了3D渲染上下文。孩子互相相交，且橘色多元素与容器相交。（目前浏览器支持还不是很好，可能看不到下面图片的效果）</p>
<center><br><img src="http://www.w3.org/TR/css-transforms-1/examples/3d-intersection.png" alt="enter image description here"><br></center>

<p>使用三维变换，有可能将元素变换的反面朝向观看者。3D变换元素在两侧显示相同的内容，所以背面看起来像前面的镜像。通常情况下，元素的反面朝向观看者并保持可见。然而，<a href="http://www.w3.org/TR/css-transforms-1/#propdef-backface-visibility" target="_blank" rel="external">backface-visibility</a>属性允许作者使元素不可见，当元素的背面朝向观看者的时候。这种行为是<code>生动</code>的；如果一个<a href="http://www.w3.org/TR/css-transforms-1/#propdef-backface-visibility" target="_blank" rel="external">backface-visibility: hidden</a>的元素正在动画，使得其正面和反面分别交替地可见，此时只有当正面朝向观察者的时候才是可见的。</p>
<h3 id="6-2_透视变换盒的处理（Processing_of_Perspective-Transformed_Boxes）">6.2 透视变换盒的处理（Processing of Perspective-Transformed Boxes）</h3><p><a href="http://www.w3.org/TR/css-transforms-1/#accumulated-3d-transformation-matrix" target="_blank" rel="external">累计3D变换矩阵（accumulated 3D transformation matrix）</a>是一个4*4的矩阵，而将被变换的对象是二维盒子。要变换盒子的每个脚（a, b）</p>
<p>// todo</p>
<h2 id="7_transform属性">7 <code>transform</code>属性</h2><p>一个变换被应用到坐标系的元素是通过<code>transform</code>属性来渲染。这个属性包含了一个<a href="http://www.w3.org/TR/css-transforms-1/#transform-functions" target="_blank" rel="external">变换函数</a>列表。一个坐标系的最终变换值是将列表中的每个函数转换其相应的矩阵来取得的，就像在<a href="http://www.w3.org/TR/css-transforms-1/#mathematical-description" target="_blank" rel="external">变换函数的数学描述</a>中定义的，然后将这些矩阵相乘。</p>
<ul>
<li>名称：<code>transform</code></li>
<li>取值：<code>none | &lt;transform-list&gt;</code></li>
<li>初始值：<code>none</code></li>
<li>应用于：<a href="http://www.w3.org/TR/css-transforms-1/#transformable-element" target="_blank" rel="external">可变换元素</a></li>
<li>继承：无</li>
<li>媒体：视觉</li>
<li>计算值：指定的值，相对的值会转化成绝对值</li>
<li>百分比：相对于<a href="http://www.w3.org/TR/css-transforms-1/#bounding-box" target="_blank" rel="external">边界框</a>的尺寸</li>
</ul>
<p>对于变换的结果，任何除了<a href="http://www.w3.org/TR/css-transforms-1/#none" target="_blank" rel="external"><code>none</code></a>的计算值会创建一个堆栈上下文和包含块。这个对象会为它固定定位的后代扮演包含块的角色。</p>
<p>上面取值的<code>&lt;transform-list&gt;</code>为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;transform-<span class="built_in">list</span>&gt; = &lt;transform-function&gt;+</span><br></pre></td></tr></table></figure>
<h2 id="8_transform-origin属性">8 <code>transform-origin</code>属性</h2><ul>
<li>名称：<code>transform-origin</code></li>
<li><p>取值：<code>[ left | center | right | top | bottom | &lt;percentage&gt; | &lt;length&gt; ]
| 
[ left | center | right | &lt;percentage&gt; | &lt;length&gt; ]
[ top | center | bottom | &lt;percentage&gt; | &lt;length&gt; ] &lt;length&gt;?
|
[ center | [ left | right ] ] &amp;&amp; [ center | [ top | bottom ] ] &lt;length&gt;?</code></p>
</li>
<li><p>初始值：<code>50% 50%</code></p>
</li>
<li>应用于：<a href="http://www.w3.org/TR/css-transforms-1/#transformable-element" target="_blank" rel="external">可变换元素</a></li>
<li>继承：无</li>
<li>媒体：视觉</li>
<li>计算值：对于<code>&lt;length&gt;</code>的取值为绝对值，否则为百分比</li>
<li>百分比：相对于<a href="http://www.w3.org/TR/css-transforms-1/#bounding-box" target="_blank" rel="external">边界框</a>的尺寸</li>
<li>能否动画：一个<a href="http://dev.w3.org/csswg/css3-transitions/#animtype-lpcalc" target="_blank" rel="external">长度、百分比或计算值</a>的<a href="http://dev.w3.org/csswg/css3-transitions/#animtype-simple-list" target="_blank" rel="external">简单列表</a></li>
</ul>
<p>对于<code>SVG</code>元素没有关联的<code>CSS</code>布局框时该属性默认值为<code>0 0</code>。</p>
<p><code>transform</code>和<code>transform-origin</code>属性的值是被用于计算<a href="http://www.w3.org/TR/css-transforms-1/#transformation-matrix" target="_blank" rel="external">变换矩阵</a>，像上面描述的一样。</p>
<p>如果只指定了一个值，第二个被假设为<code>center</code>。如果指定了一个或两个值，第三个值被假设为<code>0px</code>。</p>
<p>如果定义了两个或多个值时，或者这些值没有一个关键字时，或只使用了<code>center</code>关键字，然后第一个关键字代表水平位置，第二个关键字代表垂直位置。第三个值代表<code>Z</code>轴位置且它必须是<code>&lt;length&gt;</code>类型。</p>
<p>属性值的意义：</p>
<p><strong><code>&lt;percentage&gt;</code></strong><br> 对于水平偏移的百分比是相对于<a href="http://www.w3.org/TR/css-transforms-1/#bounding-box" target="_blank" rel="external">边界框</a>的宽度，对于垂直偏移的百分比是相对于<a href="http://www.w3.org/TR/css-transforms-1/#bounding-box" target="_blank" rel="external">边界框</a>的高度。水平和垂直的偏移值代表了从<a href="http://www.w3.org/TR/css-transforms-1/#bounding-box" target="_blank" rel="external">边界框</a>左上角的偏移。</p>
<p> <strong><code>&lt;length&gt;</code></strong><br> 一个<code>length</code>值给出了固定的长度作为偏移。水平和垂直的偏移值代表了从<a href="http://www.w3.org/TR/css-transforms-1/#bounding-box" target="_blank" rel="external">边界框</a>左上角的偏移。</p>
<p>对于<code>SVG</code>元素没有关联的<code>CSS</code>布局框时水平和垂直的偏移值代表了从元素的局部坐标空间的原点的偏移。</p>
<p><strong>top</strong><br>计算为垂直位置的<code>0%</code></p>
<p><strong>right</strong><br>计算为水平位置的<code>100%</code></p>
<p><strong>bottom</strong><br>计算为垂直位置的<code>100%</code></p>
<p><strong>left</strong><br>计算为水平位置的<code>0%</code></p>
<p><strong>center</strong><br>当水平位置没有指定时计算为水平位置的<code>50%</code>，或垂直位置的<code>50%</code></p>
<h2 id="9_transform-style属性">9 <code>transform-style</code>属性</h2><ul>
<li>名称：<code>transform-style</code></li>
<li>取值：<code>flat | preserve-3d</code></li>
<li>初始值：<code>flat</code></li>
<li>应用于：<a href="http://www.w3.org/TR/css-transforms-1/#transformable-element" target="_blank" rel="external">可变换元素</a></li>
<li>继承：无</li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
<li>百分比：<code>N/A</code></li>
<li>可动画：否</li>
</ul>
<p><code>transform-style</code>的<code>preserve-3d</code>值会创建一个堆栈上下文。</p>
<p>下面的<code>CSS</code>属性值要求用户代理在被应用之前创建后代元素的扁平表示，所以会覆盖<code>transform-style: preserve-3d</code>的行为。</p>
<ul>
<li><a href="http://www.w3.org/TR/css-overflow-3/#overflow" target="_blank" rel="external"><code>overflow</code></a>：除了<code>visible</code>的任何值</li>
<li><a href="http://www.w3.org/TR/filter-effects/#effects" target="_blank" rel="external"><code>filter</code></a>：除了<code>none</code>的任何值</li>
<li><a href="http://www.w3.org/TR/css-masking/#propdef-clip" target="_blank" rel="external"><code>clip</code></a>：除了<code>auto</code>的任何值</li>
<li><a href="http://www.w3.org/TR/css-masking/#propdef-clip-path" target="_blank" rel="external"><code>clip-path</code></a>：除了<code>none</code>的任何值</li>
<li><a href="http://www.w3.org/TR/compositing-1/#propdef-isolation" target="_blank" rel="external"><code>isolation</code></a>：使用值<code>isolate</code></li>
<li><a href="http://www.w3.org/TR/css-masking/#propdef-mask-image" target="_blank" rel="external"><code>mask-image</code></a>：除了<code>none</code>的任何值</li>
<li><a href="http://www.w3.org/TR/css-masking/#propdef-mask-box-image-source" target="_blank" rel="external"><code>mask-box-image-source</code></a>：除了<code>none</code>的任何值</li>
<li><a href="http://www.w3.org/TR/compositing-1/#propdef-mix-blend-mode" target="_blank" rel="external"><code>mix-blend-mode</code></a>：除了<code>normal</code>的任何值</li>
</ul>
<p><code>transform-style</code>的计算值不会被影响。</p>
<p><code>transform</code>和<code>transform-origin</code>属性的值是被用于计算<a href="http://www.w3.org/TR/css-transforms-1/#transformation-matrix" target="_blank" rel="external">变换矩阵</a>，像上面描述的一样。</p>
<h2 id="10_perspective属性">10 <code>perspective</code>属性</h2><ul>
<li>名称：<code>perspective</code></li>
<li>取值：<code>none | &lt;length&gt;</code></li>
<li>初始值：<code>none</code></li>
<li>应用于：<a href="http://www.w3.org/TR/css-transforms-1/#transformable-element" target="_blank" rel="external">可变换元素</a></li>
<li>继承：无</li>
<li>媒体：视觉</li>
<li>计算值：绝对长度或none</li>
<li>百分比：<code>N/A</code></li>
<li>可否动画：同<a href="http://dev.w3.org/csswg/css3-transitions/#animtype-length" target="_blank" rel="external">length</a></li>
</ul>
<p><code>&lt;length&gt;</code>的值必须是正数的。</p>
<p>属性值的意义：</p>
<p><strong><code>&lt;length&gt;</code></strong><br>距离投影中心的距离。</p>
<p><strong><code>none</code></strong><br>没有透视变换被应用。它的效果类似于一个无穷大的<code>&lt;length&gt;</code>值。所有的对象在画布上呈平面显示。</p>
<p>使用这个属性的非<code>none</code>值时会建立一个堆栈上下文。它同样建立了一个包含块，就像<a href="http://www.w3.org/TR/css-transforms-1/#propdef-transform" target="_blank" rel="external">transform</a>属性一样。</p>
<p><a href="http://www.w3.org/TR/css-transforms-1/#propdef-perspective" target="_blank" rel="external">perspective</a>和<a href="http://www.w3.org/TR/css-transforms-1/#propdef-perspective-origin" target="_blank" rel="external">perspective-origin</a>属性的值是用于计算<a href="http://www.w3.org/TR/css-transforms-1/#perspective-matrix" target="_blank" rel="external">透视矩阵</a>，就如上面描述的。</p>
<h2 id="11_perspective-origin属性">11 <code>perspective-origin</code>属性</h2><ul>
<li>名称：<code>perspective-origin</code></li>
<li><p>取值：<code>[ left | center | right | top | bottom | &lt;percentage&gt; | &lt;length&gt; ]
| 
[ left | center | right | &lt;percentage&gt; | &lt;length&gt; ]
[ top | center | bottom | &lt;percentage&gt; | &lt;length&gt; ] &lt;length&gt;?
|
[ center | [ left | right ] ] &amp;&amp; [ center | [ top | bottom ] ] &lt;length&gt;?</code></p>
</li>
<li><p>初始值：<code>50% 50%</code></p>
</li>
<li>应用于：<a href="http://www.w3.org/TR/css-transforms-1/#transformable-element" target="_blank" rel="external">可变换元素</a></li>
<li>继承：无</li>
<li>媒体：视觉</li>
<li>计算值：对于<code>&lt;length&gt;</code>的取值为绝对值，否则为百分比</li>
<li>百分比：相对于<a href="http://www.w3.org/TR/css-transforms-1/#bounding-box" target="_blank" rel="external">边界框</a>的尺寸</li>
<li>能否动画：一个<a href="http://dev.w3.org/csswg/css3-transitions/#animtype-lpcalc" target="_blank" rel="external">长度、百分比或计算值</a>的<a href="http://dev.w3.org/csswg/css3-transitions/#animtype-simple-list" target="_blank" rel="external">简单列表</a></li>
</ul>
<p><a href="http://www.w3.org/TR/css-transforms-1/#propdef-perspective" target="_blank" rel="external">perspective</a>和<a href="http://www.w3.org/TR/css-transforms-1/#propdef-perspective-origin" target="_blank" rel="external">perspective-origin</a>属性的值是用于计算<a href="http://www.w3.org/TR/css-transforms-1/#perspective-matrix" target="_blank" rel="external">透视矩阵</a>，就如上面描述的。</p>
<p>如果只指定了一个值，第二个被假设为<code>center</code>。</p>
<p>如果两个值中至少一个不是关键字，第一个关键字代表水平位置，第二个关键字代表垂直位置。</p>
<p><code>perspective-origin</code>的值代表了从<a href="http://www.w3.org/TR/css-transforms-1/#bounding-box" target="_blank" rel="external">边界框</a>左上角透视原点的一个偏移。</p>
<p><strong><code>&lt;percentage&gt;</code></strong><br> 对于水平偏移的百分比是相对于<a href="http://www.w3.org/TR/css-transforms-1/#bounding-box" target="_blank" rel="external">边界框</a>的宽度，对于垂直偏移的百分比是相对于<a href="http://www.w3.org/TR/css-transforms-1/#bounding-box" target="_blank" rel="external">边界框</a>的高度。水平和垂直的偏移值代表了从<a href="http://www.w3.org/TR/css-transforms-1/#bounding-box" target="_blank" rel="external">边界框</a>左上角的偏移。</p>
<p> <strong><code>&lt;length&gt;</code></strong><br> 一个<code>length</code>值给出了固定的长度作为偏移。水平和垂直的偏移值代表了从<a href="http://www.w3.org/TR/css-transforms-1/#bounding-box" target="_blank" rel="external">边界框</a>左上角的偏移。</p>
<p><strong>top</strong><br>计算为垂直位置的<code>0%</code></p>
<p><strong>right</strong><br>计算为水平位置的<code>100%</code></p>
<p><strong>bottom</strong><br>计算为垂直位置的<code>100%</code></p>
<p><strong>left</strong><br>计算为水平位置的<code>0%</code></p>
<p><strong>center</strong><br>当水平位置没有指定时计算为水平位置的<code>50%</code>，或垂直位置的<code>50%</code></p>
<h2 id="12_backface-visibility属性">12 <code>backface-visibility</code>属性</h2><p><code>backface-visibility</code>属性决定了当一个被变换元素的背面朝向观看者时背面是否可见。使用特性矩阵，元素的前面是朝向观看者的。当应用了一个绕<code>Y</code>轴旋转180度的变换时背面朝向了观看者。</p>
<ul>
<li>名称：<code>backface-visibility</code></li>
<li>取值：<code>visible | hidden</code></li>
<li>初始值：<code>visible</code></li>
<li>应用于：<a href="http://www.w3.org/TR/css-transforms-1/#transformable-element" target="_blank" rel="external">可变换元素</a></li>
<li>继承：无</li>
<li>媒体：视觉</li>
<li>计算值：指定值</li>
<li>百分比：<code>N/A</code></li>
<li>可否动画：否</li>
</ul>
<p>一个<code>backface-visibility: hidden</code>的元素的可见性由以下决定：</p>
<ol>
<li>对于一个在<a href="http://www.w3.org/TR/css-transforms-1/#3d-rendering-context" target="_blank" rel="external">3D渲染上下文</a>的元素，计算它的累积3D变换矩阵。对于一个不在<a href="http://www.w3.org/TR/css-transforms-1/#3d-rendering-context" target="_blank" rel="external">3D渲染上下文</a>的元素，计算它的<a href="http://www.w3.org/TR/css-transforms-1/#transformation-matrix" target="_blank" rel="external">变换矩阵</a></li>
<li>如果矩阵的第三行第三列是负数的，则元素应该被隐藏。否则它是可见的。</li>
</ol>
<h2 id="13_SVG的transform属性">13 SVG的<code>transform</code>属性</h2><h2 id="14_SVG动画">14 SVG动画</h2><p>这两个章节没有翻译，有兴趣的自行研究哟。<a href="http://www.w3.org/TR/css-transforms-1/#svg-transform" target="_blank" rel="external">SVG</a></p>
<h2 id="15_变换函数">15 变换函数</h2><p><code>transform</code>属性的值一个<code>&lt;transform-function&gt;</code>的列表。允许的变换函数集合在下面给出了。当在该规范中<a href="http://www.w3.org/TR/css3-values/#angle-value" target="_blank" rel="external"><code>&lt;angle&gt;</code></a>被使用时，一个等价于0的<a href="http://www.w3.org/TR/css3-values/#number-value" target="_blank" rel="external"><code>&lt;number&gt;</code></a>是同样被允许的，它被认为是角度0一样。</p>
<h3 id="15-1_2D变换函数">15.1 2D变换函数</h3><p><a href="http://www.w3.org/TR/css-transforms-1/#two-d-transform-functions" target="_blank" rel="external">2D Transform Functions</a></p>
<h3 id="15-2_3D变换函数">15.2 3D变换函数</h3><p><a href="http://www.w3.org/TR/css-transforms-1/#three-d-transform-functions" target="_blank" rel="external">3D Transform Functions</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/CSS/">CSS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/CSS3/">CSS3</a><a href="/tags/Transform/">Transform</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/01/18/css3-transform/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/01/18/css3-transform/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/13/css-flexbox/" title="CSS3 Flexbox" itemprop="url">CSS3 Flexbox</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-01-13T03:47:42.000Z" itemprop="datePublished"> 發表於 2015-01-13</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>这篇文章主要是<code>W3C</code>官方<a href="http://www.w3.org/TR/css-flexbox-1/" target="_blank" rel="external">CSS Flexible Box Layout Module Level 1</a>的学习，内容可能有删减。<code>Flex</code>绝对是<code>CSS</code>未来布局的趋势，有了<code>Flex</code>什么垂直居中、水平居中、响应式等都是小菜一碟了。所以把它彻底搞懂还是很有必要的，文章比较长，不过如果能耐心的读完，对<code>Flex</code>肯定会有一个透彻的了解。</p>
<h2 id="摘要">摘要</h2><p>这份规范描述了为用户界面设计而优化的框模型（<code>box model</code>）。在<code>Flex</code>布局模型中，<code>flex</code>容器的孩子可以布置在任何方向，并且能<code>伸缩</code>它们的尺寸，它们可以伸展它们的尺寸以此填充未使用的空间，或者收缩它们的尺寸以避免溢出父元素。对于子元素的水平和垂直对齐将变得非常容易操作。这些框嵌套（水平内垂直或垂直内水平）可用于在两个维度来构建布局。</p>
<h2 id="1_介绍">1 介绍</h2><p><code>CSS 2.1</code>定义了四种布局模式－确定它们尺寸以及位置的算法是基于它们与兄弟和祖先盒子的关系：</p>
<ul>
<li><code>block</code>布局：为文档（document）布局而设计</li>
<li><code>inline</code>布局：为文本布局而设计</li>
<li><code>table</code>布局：为以表格形式的二维数据的布局而设计</li>
<li><code>position</code>布局：为非常明确的定位，且不考虑文档中的其他元素的布局而设计</li>
</ul>
<p>该模块引入了一个新的布局模式，<strong><code>flex</code>布局</strong>，它是为更加复杂的应用和网页而设计的。</p>
<h3 id="1-1_概述">1.1 概述</h3><p><code>flex</code>布局表面上类似于<code>block</code>布局。它缺少许多在<code>block</code>布局中使用的更复杂的以文本(<code>text-</code>)和文档(<code>document-</code>)为中心的属性，例如<a href="http://www.w3.org/TR/CSS21/visuren.html#floats" target="_blank" rel="external">floats</a>和<a href="http://www.w3.org/TR/css3-multicol/" target="_blank" rel="external">columns</a>。作为回报，它获得了简单和更加强大的工具，使它能以多种方式来分配空间和对齐内容，而这些就是web应用和网页所需要的。以下是<code>flex</code>容器的内容：</p>
<ul>
<li>它可以在任何方向上布局（向左，向右，向下，甚至向上！）</li>
<li>可以将显示的内容顺序<a href="http://www.w3.org/TR/css-flexbox-1/#valdef-flex-direction-row-reverse" target="_blank" rel="external">颠倒</a>（<code>flex-direction: row-reverse</code>）或者<a href="http://www.w3.org/TR/css-flexbox-1/#order-property" target="_blank" rel="external">重新安排</a>它们的顺序（<code>order</code>）</li>
<li>可以线性布局在单个（<a href="http://www.w3.org/TR/css-flexbox-1/#main-axis" target="_blank" rel="external">主</a>）轴，也可以沿（<a href="http://www.w3.org/TR/css-flexbox-1/#cross-axis" target="_blank" rel="external">侧</a>）轴<a href="http://www.w3.org/TR/css-flexbox-1/#flex-wrap-property" target="_blank" rel="external">包裹</a>在多行中</li>
<li>可以<code>伸缩</code>它们的尺寸以响应可用的空间</li>
<li>能够相对于它们的容器<a href="http://www.w3.org/TR/css-flexbox-1/#alignment" target="_blank" rel="external">对齐</a>，或者彼此对齐</li>
<li>可以动态的沿着主轴折叠或不折叠，同时保持容器的侧轴尺寸</li>
</ul>
<h3 id="1-2_模块交互">1.2 模块交互</h3><p>该模块扩展了<code>[CSS21]</code>中<code>display</code>属性的定义，添加了新的<code>block-level</code>和<code>inline-level</code>的<code>display</code>类型，并且定义一个新的类型的格式化上下文连同属性来控制其布局。该模块中定义的属性都不能应用在<code>::first-line</code>和<code>::first-letter</code>伪元素中。</p>
<h2 id="2_Flex布局盒模型以及术语">2 <code>Flex</code>布局盒模型以及术语</h2><p>一个<code>flex</code>容器是一个元素<a href="http://www.w3.org/TR/CSS21/visuren.html#propdef-display" target="_blank" rel="external"><code>display</code></a>属性的计算值为<a href="http://www.w3.org/TR/css-flexbox-1/#valdef-display-flex" target="_blank" rel="external"><code>flex</code></a>或<a href="http://www.w3.org/TR/css-flexbox-1/#valdef-display-inline-flex" target="_blank" rel="external"><code>inline-flex</code></a>时，生成的盒子。在<code>flex</code>容器内的常规流子元素，称之为<code>flex items</code>，并且使用<code>flex</code>布局模型来布局。</p>
<p>不同于<code>block</code>和<code>inline</code>布局，它们的布局是基于<code>block</code>和<code>inline</code>流的方向来计算的，而对于<code>flex</code>布局，是基于<code>flex directions</code>（flex方向？）的。为了更容易简单的说明<code>flex</code>布局，本节中定义了一组<code>flex</code>相关的<code>flow-relative</code>术语。<a href="http://www.w3.org/TR/css-flexbox-1/#propdef-flex-flow" target="_blank" rel="external"><code>flex-flow</code></a>的值决定了这些术语如何映射到物理方向（上/右/下/左），轴（垂直/水平），以及尺寸（宽/高）。</p>
<p><img src="http://www.w3.org/TR/css-flexbox-1/images/flex-direction-terms.svg" alt="enter image description here"></p>
<p><strong>主轴（main axis）</strong><br><strong>主轴维度（main dimension）</strong><br><code>flex</code>容器的主轴，伸缩项目（flex items）主要沿着这条轴进行排列布局</p>
<p><strong>主轴起点（main-start）</strong><br><strong>主轴终点(main-end)</strong><br>伸缩项目放置在<code>flex</code>容器内从主轴起点（main-start）向主轴终点（main-start）方向</p>
<p><strong>主轴尺寸（main size）</strong><br><strong>主轴尺寸属性（main size property）</strong><br>一个伸缩项目的宽度或高度，它是在<code>主轴维度（main dimension）</code>里面的，且是项目的<code>主尺寸</code>。伸缩项目的<code>主尺寸属性</code>是<code>宽度</code>或<code>高度</code>属性，它是在<code>主轴维度（main dimension）</code>里面的。</p>
<p><strong>侧轴（cross axis）</strong><br><strong>侧轴维度（cross dimension）</strong><br>垂直于主轴称为侧轴。它的方向主要取决于主轴方向</p>
<p><strong>侧轴起点（cross-start）</strong><br><strong>侧轴终点(cross-end)</strong><br>伸缩行的配置从容器的侧轴起点边开始，往侧轴终点边结束</p>
<p><strong>侧轴尺寸（cross size）</strong><br><strong>侧轴尺寸属性（cross size property）</strong><br>一个伸缩项目的宽度或高度，它是在<code>侧轴维度（main dimension）</code>里面的，且是项目的<code>主尺寸</code>。伸缩项目的<code>侧轴尺寸属性</code>是<code>宽度</code>或<code>高度</code>属性，它是在<code>侧轴维度（main dimension）</code>里面的。</p>
<h2 id="3_Flex容器：display属性为flex或inline-flex">3 Flex容器：<code>display</code>属性为<code>flex</code>或<code>inline-flex</code></h2><ul>
<li>名称：<code>display</code></li>
<li>取值：<code>flex ｜ inline-flex</code></li>
</ul>
<p>属性取值的意义：</p>
<ul>
<li>flex：该值使元素生成一个<code>block-level</code>的<code>flex</code>容器盒子</li>
<li>inline-flex：该值使元素生成一个<code>inline-level</code>的<code>flex</code>容器盒子</li>
</ul>
<p>一个<code>flex</code>容器为它的内容建立了一个新的<code>flex</code>格式上下文。这和建立块级上下文是相同的，不同之处在于<code>flex</code>布局是用于代替<code>block</code>布局的：浮动不会闯入到<code>flex</code>容器中，并且<strong><code>flex</code>容器到外边距也不会与其内容的外边距折叠</strong>。<code>Flex</code>容器为它的内容形成一个包含块，就像块容器一样。<a href="http://www.w3.org/TR/css-overflow-3/#overflow" target="_blank" rel="external">overflow</a>属性是可以应用于<code>flex</code>容器的。</p>
<p><code>Flex</code>容器不是块容器（block containers），所以一些假定为<code>block</code>布局而设计的属性是不能应用于<code>flex</code>布局的。特别是：</p>
<ul>
<li>所有的在多列模块中的<code>column-*</code>属性对<code>flex</code>容器是不起作用的</li>
<li><a href="http://www.w3.org/TR/CSS21/visuren.html#propdef-float" target="_blank" rel="external"><code>float</code></a>和<a href="http://www.w3.org/TR/CSS21/visuren.html#propdef-clear" target="_blank" rel="external"><code>clear</code></a>属性对<a href="http://www.w3.org/TR/css-flexbox-1/#flex-item" target="_blank" rel="external">伸缩项目</a>是不起作用的，也不会使它脱离常规流。然而<code>float</code>属性仍然会影响盒子的<code>display</code>属性的计算值。具体怎么影响<a href="http://www.w3.org/TR/CSS21/visuren.html#dis-pos-flo" target="_blank" rel="external">Relationships between ‘display’, ‘position’, and ‘float’</a></li>
<li><a href="http://www.w3.org/TR/CSS21/visudet.html#propdef-vertical-align" target="_blank" rel="external"><code>vertical-align</code></a>对伸缩项目是不起作用的</li>
<li><code>::first-line</code>和<code>::first-letter</code>伪元素是不可以应用于<code>flex</code>容器的，并且<code>flex</code>容器也不会为它的祖先贡献第一格式化行或首字母</li>
</ul>
<p>如果一个元素的<code>display</code>属性指定为<code>inline-flex</code>时，在某些情况下，它的<code>display</code>属性会被计算为<code>flex</code>：<a href="http://www.w3.org/TR/CSS2/visuren.html#dis-pos-flo" target="_blank" rel="external">CSS 2.1 章节9.7</a>中的<code>Table</code>会被修改为包含一个附加行，当它指定值为<code>inline-flex</code>时，会被计算为<code>flex</code>。</p>
<h2 id="4_伸缩项目(flex_items)">4 伸缩项目(flex items)</h2><p>不严格地说，伸缩容器（flex containers）的伸缩项目是从元素内容生成的常规流盒子，从而进一步生成了伸缩容器。</p>
<p>每一个伸缩容器的常规流子元素会变成一个伸缩项目，并且包含在伸缩容器中的每个连续运行的文本会被包裹在一个匿名的伸缩项目中。然而，一个匿名的伸缩项目仅仅只包含空白时，它并不会被渲染出来，就好像它被设置了<code>display: none</code>一样。</p>
<p>一个伸缩项目为它的内容建立了一个新的格式上下文，像通常一样，它的格式上下文的类型是由它的<code>display</code>属性决定的。然而，伸缩项目是<code>flex-level</code>盒子，而不是<code>block-level</code>盒子：它们参与到了它们容器到<code>flex</code>格式上下文中，而不是块级格式上下文。</p>
<p><strong>实例：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"display:flex"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- flex item: block child --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"item1"</span>&gt;</span>block<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- flex item: floated element; floating is ignored --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"item2"</span> <span class="attribute">style</span>=<span class="value">"float: left;"</span>&gt;</span>float<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- flex item: anonymous block box around inline content --&gt;</span></span><br><span class="line">    anonymous item 3</span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- flex item: inline child --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">span</span>&gt;</span></span><br><span class="line">        item 4</span><br><span class="line">        <span class="comment">&lt;!-- flex items do not split around blocks --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">not-an-item</span>&gt;</span>item 4<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">        item 4</span><br><span class="line">    <span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果一个元素的常规流子元素指定的<a href="http://www.w3.org/TR/2014/WD-css-display-3-20140911/#propdef-display-outside" target="_blank" rel="external">display-outside</a>生成的伸缩容器是<code>inline-level</code>，它将会计算成<code>block-level</code>。</p>
<p>在一个设置了<code>display: table</code>的伸缩项目上，该<code>table</code>的包装盒子会变成一个伸缩项目，并且<a href="http://www.w3.org/TR/css-flexbox-1/#propdef-order" target="_blank" rel="external"><code>order</code></a>和<a href="http://www.w3.org/TR/css-flexbox-1/#propdef-align-self" target="_blank" rel="external"><code>align-self</code></a>属性可以应用到它。任何标题框的内容会贡献到<code>table</code>包装盒的最小含量和最大内容尺寸的计算。然而，像<a href="http://www.w3.org/TR/CSS21/visudet.html#propdef-width" target="_blank" rel="external"><code>width</code></a>和<a href="http://www.w3.org/TR/CSS21/visudet.html#propdef-height" target="_blank" rel="external"><code>height</code></a>属性，<code>flex</code>的普通写法可以应用于<code>table</code>，如下所示：伸缩项目的最终尺寸是通过执行布局来计算的，就好像计算<code>table</code>包装盒边缘之间的距离。<code>table</code>盒子的内容边缘是<code>table</code>盒子的<code>padding + border</code>区域，并且<code>table</code>盒子是伸缩项目。</p>
<h3 id="4-1_绝对定位的Flex儿子">4.1 绝对定位的<code>Flex</code>儿子</h3><p>一个伸缩容器的绝对定位的子元素不参与到<code>flex</code>布局中。然而，它会参与到<a href="http://www.w3.org/TR/css-flexbox-1/#algo-flex-order" target="_blank" rel="external">重新排序</a>中（详细见：<a href="http://www.w3.org/TR/css-flexbox-1/#propdef-order" target="_blank" rel="external">order</a>），会对他们的绘制顺序有一个影响。</p>
<p>一个伸缩容器的绝对定位的子元素的<a href="http://www.w3.org/TR/CSS21/visudet.html#abs-non-replaced-width" target="_blank" rel="external">静态位置</a>被确定为使得子元素就好像是 伸缩容器的唯一伸缩项目那样去定位，这会假设子元素和伸缩容器的使用尺寸(used size)为固定大小的盒子。</p>
<p>换句话说，一个伸缩容器的绝对定位的子元素的<a href="http://www.w3.org/TR/CSS21/visudet.html#abs-non-replaced-width" target="_blank" rel="external">静态位置</a>被确定为：当将子元素的<a href="http://www.w3.org/TR/css-flexbox-1/#static-position-rectangle" target="_blank" rel="external">静态位置矩形</a>设置到伸缩容器的内容盒子后，然后再将绝对定位的儿子在这个矩形中通过在伸缩容器上设置的<a href="http://www.w3.org/TR/css-flexbox-1/#propdef-justify-content" target="_blank" rel="external"><code>justify-content</code></a>值和设置在伸缩项目上的<a href="http://www.w3.org/TR/css-flexbox-1/#propdef-align-self" target="_blank" rel="external">align-self</a>值来进行对齐。</p>
<blockquote>
<p><strong>静态位置矩形：</strong><br>静态位置矩形是<a href="http://www.w3.org/TR/css3-align/#alignment-container" target="_blank" rel="external">对齐容器</a>用于决定绝对定位元素的静态位置偏移。在<code>block</code>布局中它对应了<a href="http://www.w3.org/TR/CSS21/visudet.html#abs-non-replaced-width" target="_blank" rel="external"> CSS2.1§10.3.7</a>中描述的<code>假想盒子</code>的位置。</p>
</blockquote>
<h3 id="4-2_伸缩容器的外边距和内边距">4.2 伸缩容器的外边距和内边距</h3><p>毗邻的伸缩项目的<code>margin</code>是不会折叠的。自动外边距则在相应的维度吸收额外的空间，并且可以用于对齐和相邻伸缩项目之间的距离。<a href="http://www.w3.org/TR/css-flexbox-1/#auto-margins" target="_blank" rel="external">可以看<code>auto</code>外边距的对齐</a>。</p>
<p>在伸缩项目上设置的百分比的外边距和内边距总是相对于它们自身的尺寸来解析，而不像<code>blocks</code>，它们并不总是相对于他们的包含块的行内尺寸来解析。</p>
<h3 id="4-3_伸缩项目的Z轴顺序">4.3 伸缩项目的Z轴顺序</h3><p>伸缩项目的绘制和行内块是相同的，只是<a href="http://www.w3.org/TR/css-flexbox-1/#propdef-order" target="_blank" rel="external"><code>order</code></a>会修改文档的顺序，从而代替原始文档的顺序，并且<a href="http://www.w3.org/TR/css3-positioning/#z-index" target="_blank" rel="external">z-index</a>设置了除<code>auto</code>值之外的其他值是会创建一个层叠上下文，即使<code>position</code>被设置为<code>static</code>。</p>
<h3 id="4-4_被折叠的项目（Collapsed_Items）">4.4 被折叠的项目（Collapsed Items）</h3><p>当在一个伸缩容器上指定了<code>visibility:collapse</code>，此时伸缩项目成为了一个被折叠的项目，产生了一种类似于在<code>table-row</code>和<code>table-column</code>元素上设置<code>visibility:collapse</code>的效果：被折叠的伸缩项目完全从渲染中移除，但是它留下了一个<code>支柱</code>，以此保持伸缩线侧轴尺寸的稳定。因此，如果一个伸缩容器只有一个伸缩行（flex line），动态折叠和未折叠的项目会保证对伸缩容器的侧轴没有影响，并且不会造成页面布局的其余部分<code>摆动</code>。伸缩行换行会在折叠后重新做，然而，一个有着多行的伸缩容器的侧轴尺寸可能改变，也可能不改变。</p>
<p>尽管被折叠的项目不会重新渲染，但是它们出现在格式化结构中。所以，它不像<code>display: none</code>项目，影响是依赖的盒子出现在格式化结构中，并且仍然作用在折叠的元素上。</p>
<p><strong>实例：</strong></p>
<p>在下面的例子中，一个侧栏被设置以适应其内容的尺寸。<a href="http://www.w3.org/TR/CSS21/visufx.html#propdef-visibility" target="_blank" rel="external"><code>visibility: collapse</code></a>被用于动态对隐藏导航栏部分，且不影响他们的宽度，即使最宽的部分是一个折叠部分。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line">  <span class="at_rule">@<span class="keyword">media</span> (min-width: <span class="number">60em</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* two column layout only when enough room (relative to default text size) */</span></span><br><span class="line">    <span class="tag">header</span> + <span class="tag">div</span> <span class="rules">&#123; <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>; &#125;</span></span><br><span class="line">    <span class="id">#main</span> <span class="rules">&#123;</span><br><span class="line">      <span class="rule"><span class="attribute">flex</span>:<span class="value"> <span class="number">1</span></span></span>;         <span class="comment">/* Main takes up all remaining space */</span></span><br><span class="line">      <span class="rule"><span class="attribute">order</span>:<span class="value"> <span class="number">1</span></span></span>;        <span class="comment">/* Place it after (to the right of) the navigation */</span></span><br><span class="line">      <span class="rule"><span class="attribute">min-width</span>:<span class="value"> <span class="number">12em</span></span></span>; <span class="comment">/* Optimize main content area sizing */</span></span><br><span class="line">    &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* menu items use flex layout so that visibility:collapse will work */</span></span><br><span class="line">  <span class="tag">nav</span> &gt; <span class="tag">ul</span> &gt; <span class="tag">li</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">flex-flow</span>:<span class="value"> column</span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line">  <span class="comment">/* dynamically collapse submenus when not targetted */</span></span><br><span class="line">  <span class="tag">nav</span> &gt; <span class="tag">ul</span> &gt; <span class="rule"><span class="attribute">li</span>:<span class="value"><span class="function">not</span>(:target):<span class="function">not</span>(:hover) &gt; ul &#123;</span><br><span class="line">    visibility: collapse</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line">…</span><br><span class="line"><span class="tag">&lt;/<span class="title">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">article</span> <span class="attribute">id</span>=<span class="value">"main"</span>&gt;</span></span><br><span class="line">    Interesting Stuff to Read</span><br><span class="line">  <span class="tag">&lt;/<span class="title">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">li</span> <span class="attribute">id</span>=<span class="value">"nav-about"</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#nav-about"</span>&gt;</span>About<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">        …</span><br><span class="line">      <span class="tag">&lt;<span class="title">li</span> <span class="attribute">id</span>=<span class="value">"nav-projects"</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#nav-projects"</span>&gt;</span>Projects<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"…"</span>&gt;</span>Art<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"…"</span>&gt;</span>Architecture<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"…"</span>&gt;</span>Music<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">li</span> <span class="attribute">id</span>=<span class="value">"nav-interact"</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#nav-interact"</span>&gt;</span>Interact<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">        …</span><br><span class="line">    <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了计算<code>支柱</code>的尺寸，<code>flex</code>布局首先以所有项目未折叠来处理，然后重新运行使所有的折叠项目用<code>支柱</code>来替换，且维持该项目原始行的原始侧轴。可以看<a href="http://www.w3.org/TR/css-flexbox-1/#layout-algorithm" target="_blank" rel="external">Flex布局算法</a>与<code>visibility: collapse</code>的相互作用。</p>
<blockquote>
<p>在任何伸缩项目上使用<code>visibility: collapse</code>会导致<code>flex</code>布局算法会重复中途部分，并且运行最昂贵的步骤。所以建议作者继续使用<code>display: none</code>，如果不需要动态的折叠或不折叠项目时，因为它对于布局引擎更加高效。</p>
</blockquote>
<h3 id="4-5_伸缩项目隐含的最小尺寸">4.5 伸缩项目隐含的最小尺寸</h3><p>为了给伸缩项目提供更合理的默认最小尺寸，规范中引入了一个新的值<code>auto</code>作为<a href="http://www.w3.org/TR/CSS21/visudet.html#propdef-min-width" target="_blank" rel="external"><code>min-width</code></a>和<a href="http://www.w3.org/TR/CSS21/visudet.html#propdef-min-height" target="_blank" rel="external"><code>min-height</code></a>属性的初始值（在<a href="http://www.w3.org/TR/css-flexbox-1/#biblio-css21" target="_blank" rel="external">CSS2.1</a>中定义）。</p>
<ul>
<li>名称：<code>min-width</code>，<code>min-height</code></li>
<li>取值：<code>auto</code></li>
<li>新的计算值：指定的百分比或绝对长度或关键字</li>
<li>新的初始值：<code>auto</code></li>
</ul>
<p><strong>auto</strong><br>在<a href="http://www.w3.org/TR/css-flexbox-1/#main-axis" target="_blank" rel="external">主轴</a>上，在一个<code>overflow</code>为<code>visible</code>的伸缩项目上，当在伸缩项目当主轴上指定了最小尺寸属性，下面的表格给出了最小尺寸：</p>
<h2 id="5_排序和方向（Ordering_and_Orientation）">5 排序和方向（Ordering and Orientation）</h2><p>一个伸缩容器的内容可以布置在任何方向或者任何排序。这使得作者很容易达到的效果，而在之前这些需要复杂或者易碎的方法才能达到，例如使用<a href="http://www.w3.org/TR/CSS21/visuren.html#propdef-float" target="_blank" rel="external"><code>float</code></a>和<a href="http://www.w3.org/TR/CSS21/visuren.html#propdef-clear" target="_blank" rel="external"><code>clear</code></a>属性的<code>hacks</code>。这些功能是通过<a href="http://www.w3.org/TR/css-flexbox-1/#propdef-flex-direction" target="_blank" rel="external"><code>flex-direction</code></a>、<a href="http://www.w3.org/TR/css-flexbox-1/#propdef-flex-wrap" target="_blank" rel="external"><code>flex-wrap</code></a>和<a href="http://www.w3.org/TR/css-flexbox-1/#propdef-order" target="_blank" rel="external"><code>order</code></a>属性来暴露。</p>
<blockquote>
<p><code>flex</code>布局的重排序功能只会影响视觉到渲染。</p>
</blockquote>
<p>作者不可以使用<code>order</code>或<code>flex-flow</code>和<code>flex-direction</code>的<code>*-reverse</code>值来替代正确源排序，因为这会破坏文档的可访问性。</p>
<h3 id="5-1_伸缩流方向：flex-direction属性">5.1 伸缩流方向：<code>flex-direction</code>属性</h3><ul>
<li>名称：<code>flex-direction</code></li>
<li>取值：<code>row | row-reverse | column | column-reverse</code></li>
<li>初始值：<code>row</code></li>
<li>应用于：伸缩容器</li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<p><code>flex-direction</code>属性指定了伸缩项目如何在伸缩容器中放置，是通过设置伸缩容器的主轴的方向。这决定了伸缩项目在布局中的方向。</p>
<p>属性值的意义：</p>
<ul>
<li>row：伸缩容器的主轴和当前的<a href="http://www.w3.org/TR/css-writing-modes-3/#writing-mode0" target="_blank" rel="external">书写模式</a>的<a href="http://www.w3.org/TR/css-writing-modes-3/#inline-axis-" target="_blank" rel="external">行内轴</a>方向是一致的。<a href="http://www.w3.org/TR/css-flexbox-1/#main-start" target="_blank" rel="external"><code>main-start</code></a>和<a href="http://www.w3.org/TR/css-flexbox-1/#main-end" target="_blank" rel="external"><code>main-end</code></a>的方向等价于<a href="http://www.w3.org/TR/css-writing-modes-3/#inline-start" target="_blank" rel="external"><code>inline-start</code></a>和<a href="http://www.w3.org/TR/css-writing-modes-3/#inline-end" target="_blank" rel="external"><code>inline-end</code></a>的方向，各自的在当前书写模式</li>
<li>row-reverse：和<code>row</code>比较相同，只是<a href="http://www.w3.org/TR/css-flexbox-1/#main-start" target="_blank" rel="external"><code>main-start</code></a>和<a href="http://www.w3.org/TR/css-flexbox-1/#main-end" target="_blank" rel="external"><code>main-end</code></a>它们的方向交换了</li>
<li>column：伸缩容器的主轴和当前的<a href="http://www.w3.org/TR/css-writing-modes-3/#writing-mode0" target="_blank" rel="external">书写模式</a>的<a href="http://www.w3.org/TR/css-writing-modes-3/#block-axis-" target="_blank" rel="external">块轴</a>方向是一致的。<a href="http://www.w3.org/TR/css-flexbox-1/#main-start" target="_blank" rel="external"><code>main-start</code></a>和<a href="http://www.w3.org/TR/css-flexbox-1/#main-end" target="_blank" rel="external"><code>main-end</code></a>的方向等价于<a href="http://www.w3.org/TR/css-writing-modes-3/#block-start" target="_blank" rel="external"><code>block-start</code></a>和<a href="http://www.w3.org/TR/css-writing-modes-3/#block-end" target="_blank" rel="external"><code>black-end</code></a>的方向，各自的在当前书写模式</li>
<li>column-reverse：和<code>column</code>比较相同，只是<a href="http://www.w3.org/TR/css-flexbox-1/#main-start" target="_blank" rel="external"><code>main-start</code></a>和<a href="http://www.w3.org/TR/css-flexbox-1/#main-end" target="_blank" rel="external"><code>main-end</code></a>它们的方向交换了</li>
</ul>
<blockquote>
<p><code>reverse</code>的取值不是反转了盒子的排序：就像<a href="http://www.w3.org/TR/css-writing-modes-3/#writing-mode0" target="_blank" rel="external">书写模式</a>和<a href="http://www.w3.org/TR/css-writing-modes-3/#propdef-direction" target="_blank" rel="external">direction</a>，它只是改变了流的方向。</p>
</blockquote>
<h3 id="5-2_伸缩行换行：flex-wrap属性">5.2 伸缩行换行：<code>flex-wrap</code>属性</h3><ul>
<li>名称：<code>flex-wrap</code></li>
<li>取值：<code>nowrap | wrap | wrap-reverse</code></li>
<li>初始值：<code>nowrap</code></li>
<li>应用于：伸缩容器</li>
<li>继承：无</li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<p><code>flex-wrap</code>属性控制了伸缩容器是否在<a href="http://www.w3.org/TR/css-flexbox-1/#single-line" target="_blank" rel="external">单行</a>显示还是在<a href="http://www.w3.org/TR/css-flexbox-1/#multi-line" target="_blank" rel="external">多行</a>显示，并且侧轴的方向，决定了新的行层叠的方向。</p>
<p>属性值的意义：</p>
<ul>
<li>nowrap：伸缩容器在单行显示。<a href="http://www.w3.org/TR/css-flexbox-1/#cross-start" target="_blank" rel="external"><code>cross-start</code></a>的方向等价于当前<a href="http://www.w3.org/TR/css-writing-modes-3/#writing-mode0" target="_blank" rel="external">书写模式</a>中<a href="http://www.w3.org/TR/css-writing-modes-3/#inline-start" target="_blank" rel="external"><code>inline-start</code></a>或<a href="http://www.w3.org/TR/css-writing-modes-3/#block-start" target="_blank" rel="external"><code>block-start</code></a>中一个的方向。无论哪个是<a href="http://www.w3.org/TR/css-flexbox-1/#cross-start" target="_blank" rel="external"><code>cross-start</code></a>，<a href="http://www.w3.org/TR/css-flexbox-1/#cross-end" target="_blank" rel="external"><code>cross-end</code></a>是和<a href="http://www.w3.org/TR/css-flexbox-1/#cross-start" target="_blank" rel="external"><code>cross-start</code></a>的方向正好相反</li>
<li>wrap：伸缩容器在多行显示。<a href="http://www.w3.org/TR/css-flexbox-1/#cross-start" target="_blank" rel="external"><code>cross-start</code></a>的方向等价于当前<a href="http://www.w3.org/TR/css-writing-modes-3/#writing-mode0" target="_blank" rel="external">书写模式</a>中<a href="http://www.w3.org/TR/css-writing-modes-3/#inline-start" target="_blank" rel="external"><code>inline-start</code></a>或<a href="http://www.w3.org/TR/css-writing-modes-3/#block-start" target="_blank" rel="external"><code>block-start</code></a>中一个的方向。无论哪个是<a href="http://www.w3.org/TR/css-flexbox-1/#cross-start" target="_blank" rel="external"><code>cross-start</code></a>，<a href="http://www.w3.org/TR/css-flexbox-1/#cross-end" target="_blank" rel="external"><code>cross-end</code></a>是和<a href="http://www.w3.org/TR/css-flexbox-1/#cross-start" target="_blank" rel="external"><code>cross-start</code></a>的方向正好相反</li>
<li>wrap-reverse：和<code>wrap</code>相同，只是<code>cross-start</code>和<code>cross-end</code>交换了</li>
</ul>
<h3 id="5-3_伸缩方向和换行：flex-flow属性">5.3 伸缩方向和换行：<code>flex-flow</code>属性</h3><ul>
<li>名称：<code>flex-flow</code></li>
<li>取值：<code>&lt;flex-direction&gt; || &lt;flex-wrap&gt;</code></li>
<li>初始值：取决于<code>flex-direction</code>和<code>flex-wrap</code>的初始值</li>
<li>应用于：伸缩容器</li>
<li>继承：取决于<code>flex-direction</code>和<code>flex-wrap</code>的初始值</li>
<li>媒体：视觉</li>
<li>计算值：取决于<code>flex-direction</code>和<code>flex-wrap</code>的初始值</li>
</ul>
<p><code>flex-flow</code>属性是<code>flex-direction</code>和<code>flex-wrap</code>的简写。它一起定义了伸缩容器的主轴和侧轴。</p>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span> <span class="rules">&#123; <span class="rule"><span class="attribute">flex-flow</span>:<span class="value"> row</span></span>; &#125;</span></span><br><span class="line"><span class="comment">/* Initial value. Main-axis is</span><br><span class="line">   inline, no wrap. */</span></span><br></pre></td></tr></table></figure>
<p><img src="http://www.w3.org/TR/css-flexbox-1/images/flex-flow1.svg" alt="enter image description here"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span> <span class="rules">&#123; <span class="rule"><span class="attribute">flex-flow</span>:<span class="value"> column wrap</span></span>; &#125;</span></span><br><span class="line"><span class="comment">/* Main-axis is block-direction (top to bottom)</span><br><span class="line">   and lines wrap in the inline direction (rightwards). */</span></span><br></pre></td></tr></table></figure>
<p><img src="http://www.w3.org/TR/css-flexbox-1/images/flex-flow2.svg" alt="enter image description here"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span> <span class="rules">&#123; <span class="rule"><span class="attribute">flex-flow</span>:<span class="value"> row-reverse wrap-reverse</span></span>; &#125;</span></span><br><span class="line"><span class="comment">/* Main-axis is the opposite of inline direction</span><br><span class="line">   (right to left). New lines wrap upwards. */</span></span><br></pre></td></tr></table></figure>
<p><img src="http://www.w3.org/TR/css-flexbox-1/images/flex-flow3.svg" alt="enter image description here"></p>
<h3 id="5-4_显示顺序：order属性">5.4 显示顺序：<code>order</code>属性</h3><p>伸缩项目在默认情况下是按着它们源文档中出现的顺序来布局的。<code>order</code>属性可以被用于改变这些顺序。</p>
<ul>
<li>名称：<code>order</code></li>
<li>取值：<a href="http://www.w3.org/TR/css-syntax-3/#typedef-integer" target="_blank" rel="external"><code>&lt;integer&gt;</code></a></li>
<li>初始值：0</li>
<li>应用于：伸缩项目和伸缩容器的绝对定位儿子</li>
<li>继承：无</li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
<li>是否可以动画：是</li>
</ul>
<p><code>order</code>属性控制在伸缩容器内子元素在伸缩容器中的顺序，通过将它们分配到有序组。它只接受单一的<a href="http://www.w3.org/TR/css-syntax-3/#typedef-integer" target="_blank" rel="external"><code>&lt;integer&gt;</code></a>作为属性值，并且指定的就是伸缩项目属于的有序组。</p>
<p>一个伸缩容器把它的内容布局在<code>被修改的文档顺序</code>，从最小数字的有序组开始，并以此类推。当项目具有相同的值时，它们就按照他们在源文档中的顺序来布局。这个会影响<a href="http://www.w3.org/TR/CSS2/zindex.html" target="_blank" rel="external">绘制顺序</a>，就好像伸缩项目在源文档中被重排序。</p>
<p>实例：</p>
<p>下图显示了一个简单的标签式界面，标签中的活动窗格永远是第一个：</p>
<p><img src="http://www.w3.org/TR/css-flexbox-1/images/flex-order-example.png" alt="enter image description here"></p>
<p>这可以通过以下<code>CSS</code>代码来实现：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.tabs</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.tabs</span> &gt; * <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">min-width</span>:<span class="value"> min-content</span></span>;</span><br><span class="line">  <span class="comment">/* Prevent tabs from getting too small for their content. */</span></span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.tabs</span> &gt; <span class="class">.current</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">order</span>:<span class="value"> -<span class="number">1</span></span></span>; <span class="comment">/* Lower than the default of 0 */</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-4-1_重排序和可访问性">5.4.1 重排序和可访问性</h4><p><code>order</code>属性不会影响非视觉媒体的排序。同样的，<code>order</code>不影响连续导航模式的默认遍历顺序。作者只能在视觉媒体中使用<code>order</code>属性。</p>
<p><strong>实例：</strong></p>
<p>许多网页在标记上具有类似的形状，在顶部的头部，在底部的页脚，然后一个内容区域和一个或在中间的两个附加列。一般情况下，内容最好首先出现在页面的源代码中，在其他列之前。然而，这是非常常见的设计，例如简单的将附加列放在左边而内容区域放在右边，这是难以实现的。这在许多方面已经得到解决，这经常被命名为“圣杯布局”，它有两个附加列。例如，利用网页代码和以下草图实现所需的布局：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">header</span>&gt;</span>...<span class="tag">&lt;/<span class="title">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">'main'</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">article</span>&gt;</span>...<span class="tag">&lt;/<span class="title">article</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">nav</span>&gt;</span>...<span class="tag">&lt;/<span class="title">nav</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">aside</span>&gt;</span>...<span class="tag">&lt;/<span class="title">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="title">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://www.w3.org/TR/css-flexbox-1/images/flex-order-page.svg" alt="enter image description here"></p>
<p>这种布局可以轻松的通过<code>Flex</code>布局来实现：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#main</span> <span class="rules">&#123; <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>; &#125;</span></span><br><span class="line"><span class="id">#main</span> &gt; <span class="tag">article</span> <span class="rules">&#123; <span class="rule"><span class="attribute">order</span>:<span class="value"> <span class="number">2</span></span></span>; <span class="rule"><span class="attribute">min-width</span>:<span class="value"> <span class="number">12em</span></span></span>; <span class="rule"><span class="attribute">flex</span>:<span class="value"><span class="number">1</span></span></span>; &#125;</span></span><br><span class="line"><span class="id">#main</span> &gt; <span class="tag">nav</span>     <span class="rules">&#123; <span class="rule"><span class="attribute">order</span>:<span class="value"> <span class="number">1</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>; &#125;</span></span><br><span class="line"><span class="id">#main</span> &gt; <span class="tag">aside</span>   <span class="rules">&#123; <span class="rule"><span class="attribute">order</span>:<span class="value"> <span class="number">3</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>; &#125;</span></span><br></pre></td></tr></table></figure>
<p>作为一个额外的奖励，我们是所有的列默认情况下等高的，主内容则尽可能宽的填充屏幕。此外，这可以结合<code>media queries</code>来实现在窄屏幕下将所有的列垂直布局。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">media</span> all and (max-width: <span class="number">600px</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* Too narrow to support three columns */</span></span><br><span class="line">  <span class="id">#main</span> <span class="rules">&#123; <span class="rule"><span class="attribute">flex-flow</span>:<span class="value"> column</span></span>; &#125;</span></span><br><span class="line">  <span class="id">#main</span> &gt; <span class="tag">article</span>, <span class="id">#main</span> &gt; <span class="tag">nav</span>, <span class="id">#main</span> &gt; <span class="tag">aside</span> <span class="rules">&#123;</span><br><span class="line">    <span class="comment">/* Return them to document order */</span></span><br><span class="line">    <span class="rule"><span class="attribute">order</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> auto</span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6_伸缩行（Flex_Lines）">6 伸缩行（Flex Lines）</h2><p>伸缩项目在伸缩容器内被布局，并通过伸缩行来对齐。假设容器（hypothetical containers）则被布局算法用于分组和对齐。一个伸缩容器可以是<a href="http://www.w3.org/TR/css-flexbox-1/#single-line" target="_blank" rel="external">单行</a>，也可以是<a href="http://www.w3.org/TR/css-flexbox-1/#multi-line" target="_blank" rel="external">多行</a>的，这取决于<code>flex-wrap</code>属性：</p>
<ul>
<li>一个<code>单行</code>的伸缩容器将它的所有儿子布局在单行，即使这会导致它的内容溢出。</li>
<li>一个<code>多行</code>的伸缩容器将伸缩项目跨越多行，这类似于当文本太宽时折行出新行以适应现有行。当附加的行被创建时，它们通过<code>flex-wrap</code>属性并沿着侧轴堆栈在伸缩容器内。每一行至少包含一个<code>伸缩项目</code>，除非伸缩容器本身是空的。</li>
</ul>
<p><strong>实例：</strong></p>
<p>这个例子显示了四个按钮，并且在水平方向不能完全适应（容不下四个）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line"><span class="id">#flex</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">flex-flow</span>:<span class="value"> row wrap</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">300px</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.item</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">80px</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"flex"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">'item'</span>&gt;</span>1<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">'item'</span>&gt;</span>2<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">'item'</span>&gt;</span>3<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">'item'</span>&gt;</span>4<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为容器只有<code>300px</code>，只有三个的项目适应到单行。它们占了<code>240px</code>，并且剩下了<code>60px</code>的剩余空间。因为伸缩容器的<code>flex-flow</code>属性指定了这是一个多行的，所以伸缩容器会创建一个附加的行来包含最后一个项目。</p>
<p><img src="http://www.w3.org/TR/css-flexbox-1/images/multiline-no-flex.svg" alt="enter image description here"></p>
<p>一旦内容被分成多行，每行都是独立布局的；伸缩尺寸和<code>justify-content</code>和<code>align-self</code>属性仅仅将项目认为是单行的。</p>
<p>当一个伸缩容器有多行时，<a href="http://www.w3.org/TR/css-flexbox-1/#cross-size" target="_blank" rel="external">侧轴尺寸</a>的每一行是该行包含的伸缩项目的最小必须尺寸，并且所有的行在伸缩容器内的对齐是通过<a href="http://www.w3.org/TR/css-flexbox-1/#propdef-align-content" target="_blank" rel="external">align-content</a>属性来对齐的。当一个伸缩容器（即使是一个多行的伸缩容器，flex-wrap: wrap）只有一行时，该行 的侧轴尺寸是伸缩容器侧轴的尺寸，此时应用<a href="http://www.w3.org/TR/css-flexbox-1/#propdef-align-content" target="_blank" rel="external">align-content</a>没有效果。一行的<a href="http://www.w3.org/TR/css-flexbox-1/#main-size" target="_blank" rel="external">主轴尺寸</a>总是和伸缩容器的内容盒子的主轴尺寸的大小一样。</p>
<p><strong>实例：</strong></p>
<p>这里是一个和前面相同的例子，只是我们在伸缩项目上设置了<code>flex: auto</code>。第一行有剩余的<code>60px</code>，所有的项目具有相同的伸缩性，所以三个项目中的每一个都会得到额外的<code>20px</code>。最后一个项目则会伸缩到整行。</p>
<p><img src="http://www.w3.org/TR/css-flexbox-1/images/multiline-flex.svg" alt="enter image description here"></p>
<h2 id="7_伸缩性">7 伸缩性</h2><p><code>flex</code>布局的定义方面是使伸缩项目可伸缩的能力，改变它们的宽度/高度，以填补在<a href="http://www.w3.org/TR/css-flexbox-1/#main-dimension" target="_blank" rel="external">主轴维度</a>中的可用空间。这是通过<a href="http://www.w3.org/TR/css-flexbox-1/#propdef-flex" target="_blank" rel="external">flex</a>属性来完成的。伸缩容器将它的可用空间成比例的分配到它的伸缩项目中，这个比例通过伸缩项目的<a href="http://www.w3.org/TR/css-flexbox-1/#flex-grow-factor" target="_blank" rel="external">伸缩增长因素</a>决定，或者成比例缩小它们以防止溢出，这个比例是通过伸缩项目的<a href="http://www.w3.org/TR/css-flexbox-1/#flex-shrink-factor" target="_blank" rel="external">伸缩缩小因素</a>决定。</p>
<h3 id="7-1_flex简写">7.1 <code>flex</code>简写</h3><ul>
<li>名称：<code>flex</code></li>
<li>取值：<code>none | auto | [ &lt;‘flex-grow’&gt; &lt;‘flex-shrink’&gt;? || &lt;‘flex-basis’&gt; ]</code></li>
<li>应用于：伸缩项目</li>
<li>初始值：单个属性决定</li>
<li>媒体：视觉</li>
<li>计算值：单个属性决定</li>
</ul>
<p><code>flex</code>属性指定了组件的伸缩长度：<a href="http://www.w3.org/TR/css-flexbox-1/#flex-grow-factor" target="_blank" rel="external">伸缩增长因素</a>、<a href="http://www.w3.org/TR/css-flexbox-1/#flex-shrink-factor" target="_blank" rel="external">伸缩缩小因素</a>和<a href="http://www.w3.org/TR/css-flexbox-1/#flex-basis" target="_blank" rel="external">伸缩基础</a>。当一个盒子是伸缩项目时，<code>flex</code>属性被咨询并代替<a href="http://www.w3.org/TR/css-flexbox-1/#main-size-property" target="_blank" rel="external">主轴尺寸属性</a>去决定盒子的<a href="http://www.w3.org/TR/css-flexbox-1/#main-size" target="_blank" rel="external">主轴尺寸</a>。如果一个盒子不是伸缩项目，<code>flex</code>属性对其没有效果。</p>
<p>下面是各取值组件的意义：</p>
<ul>
<li><a href="http://www.w3.org/TR/css-flexbox-1/#propdef-flex-grow" target="_blank" rel="external">flex-grow</a>：这个<code>&lt;number&gt;</code>组件是<a href="http://www.w3.org/TR/css-flexbox-1/#propdef-flex-grow" target="_blank" rel="external">flex-grow</a>的普通写法，它指定了<code>伸缩增长因素</code>，它决定了该伸缩项目相对于有正的可用空间的伸缩容器中其他伸缩项目的增长比例。当省略时，它被设置为<code>1</code>。</li>
<li><a href="http://www.w3.org/TR/css-flexbox-1/#propdef-flex-shrink" target="_blank" rel="external">flex-shrink</a>：这个<code>&lt;number&gt;</code>组件是<a href="http://www.w3.org/TR/css-flexbox-1/#propdef-flex-shrink" target="_blank" rel="external">flex-shrink</a>的普通写法，它指定了<code>伸缩缩小因素</code>，它决定了该伸缩项目相对于有负的可用空间的伸缩容器中其他伸缩项目的缩小比例。当省略时，它被设置为<code>1</code>。当分发负的空间时，<a href="http://www.w3.org/TR/css-flexbox-1/#flex-shrink-factor" target="_blank" rel="external">伸缩缩小因素</a>是乘以<a href="http://www.w3.org/TR/css-flexbox-1/#flex-basis" target="_blank" rel="external">伸缩基础</a>的。</li>
<li><a href="http://www.w3.org/TR/css-flexbox-1/#propdef-flex-basis" target="_blank" rel="external">flex-basis</a>：该组件，具有和<code>width</code>属性相同的属性值，是设置<a href="http://www.w3.org/TR/css-flexbox-1/#propdef-flex-basis" target="_blank" rel="external">flex-basis</a>的普通写法，指定了<code>伸缩基础</code>：是伸缩项目的初始<a href="http://www.w3.org/TR/css-flexbox-1/#main-size" target="_blank" rel="external">主轴尺寸</a>，它是在根据伸缩因素分发可用空间之前设置的。当在<code>flex</code>简写中省略了它，它的指定值为<code>0%</code>。</li>
</ul>
<p><img src="http://www.w3.org/TR/css-flexbox-1/images/rel-vs-abs-flex.svg" alt="enter image description here"></p>
<p>上面这个图片展示了绝对和相对的<code>flex</code>。</p>
<ul>
<li>auto：关键字<code>auto</code>相当于<code>1 1 main-size</code></li>
<li>none：关键字<code>none</code>相当于<code>0 0 main-size</code></li>
</ul>
<p><code>flex</code>属性的组件的初始值是等价于<code>0 1 main-size</code>的。</p>
<h3 id="7-2_flex的常用值">7.2 <code>flex</code>的常用值</h3><p>下面的列表总结了最常见的<code>flex</code>值的效果：</p>
<p><strong>flex: 0 main-size</strong><br><strong>flex: initial</strong><br>等价于<code>flex: 0 1 main-size</code>（这个是初始值）。当有正当可用空间时，这会使得当伸缩项目是不可伸缩的，但是当空间不足时允许伸缩项目收缩到它的最小尺寸。</p>
<p><strong>flex: auto</strong><br>等价于<code>flex: 1 1 main-size</code>。</p>
<p><strong>flex: none</strong><br>等价于<code>flex: 0 0 main-size</code></p>
<p><strong>flex: <code>&lt;position-number&gt;</code></strong><br>等价于<code>flex: &lt;position-number&gt; 1 0％</code></p>
<h3 id="7-3_伸缩性的组件">7.3 伸缩性的组件</h3><p>伸缩性的各个组件可以通过独立的普通写法属性来控制。</p>
<blockquote>
<p>作者被建议使用<code>flex</code>简写法来设置，而不是通过各个组件来设置，因为简写法可以正确的重置任何未指定的组件以适应常见的用途。</p>
</blockquote>
<h4 id="7-3-1_flex-grow属性">7.3.1 <code>flex-grow</code>属性</h4><ul>
<li>名称：<code>flex-grow</code></li>
<li>取值：<code>&lt;number&gt;</code></li>
<li>应用于：伸缩项目</li>
<li>初始值：0</li>
<li>继承：无</li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
<li>是否能动画：是</li>
</ul>
<p><code>flex-grow</code>属性用<code>&lt;number&gt;</code>来设置<a href="http://www.w3.org/TR/css-flexbox-1/#flex-grow-factor" target="_blank" rel="external">伸缩增长因素</a>，负值是不允许的。</p>
<h4 id="7-3-2_flex-shrink属性">7.3.2 <code>flex-shrink</code>属性</h4><ul>
<li>名称：<code>flex-shrink</code></li>
<li>取值：<code>&lt;number&gt;</code></li>
<li>应用于：伸缩项目</li>
<li>初始值：1</li>
<li>继承：无</li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
<li>是否能动画：是</li>
</ul>
<p><code>flex-shrink</code>属性用<code>&lt;number&gt;</code>来设置<a href="http://www.w3.org/TR/css-flexbox-1/#flex-shrink-factor" target="_blank" rel="external">伸缩缩小因素</a>，负值是不允许的。</p>
<h4 id="7-3-2_flex-basis属性">7.3.2 <code>flex-basis</code>属性</h4><ul>
<li>名称：<code>flex-basis</code></li>
<li>取值：<code>main-size | &lt;‘width’&gt;</code></li>
<li>应用于：伸缩项目</li>
<li>初始值：<code>main-size</code></li>
<li>继承：无</li>
<li>媒体：视觉</li>
<li>计算值：指定的值，长度将被转换为绝对值</li>
<li>百分比：相对于伸缩容器的内部<a href="http://www.w3.org/TR/css-flexbox-1/#main-size" target="_blank" rel="external">主尺寸</a>（inner main size）</li>
<li>是否能动画：是</li>
</ul>
<p><code>flex-basis</code>属性设置<a href="http://www.w3.org/TR/css-flexbox-1/#flex-basis" target="_blank" rel="external">伸缩基础</a>，它接受和<code>width</code>和<code>height</code>属性相同的属性值。</p>
<p>当在伸缩项目上设置了<code>main-size</code>关键字，会去检索<a href="http://www.w3.org/TR/css-flexbox-1/#main-size-property" target="_blank" rel="external">主轴尺寸属性</a>的值。</p>
<p><code>flex-basis</code>是和<code>width</code>在水平书写模式解析一样：百分比的值是相对于伸缩项目的包含块，例如，它的伸缩容器，如果包含块的尺寸是<a href="http://www.w3.org/TR/css-flexbox-1/#indefinite" target="_blank" rel="external">不确定的</a>，其结果和<code>auto</code>的主尺寸一样。类似的，<code>flex-basis</code>决定了内容盒子的尺寸，除非指定了<code>box-sizing</code>等。</p>
<h2 id="8_对齐（Alignment）">8 对齐（Alignment）</h2><p>当一个伸缩容器的内容完成了伸缩后，并且所有的伸缩项目的尺寸都最后确定了，它们可以在伸缩容器中对齐。</p>
<p><a href="http://www.w3.org/TR/CSS21/box.html#propdef-margin" target="_blank" rel="external">margin</a>属性可以以一种类似的方式来对齐项目，但是更强大。</p>
<h3 id="8-1_用auto的margin来对齐">8.1 用<code>auto</code>的margin来对齐</h3><p>在伸缩项目上的<code>auto margins</code>和块级流中的<code>auto margins</code>在效果上是非常类似的：</p>
<ul>
<li>在计算伸缩基础和伸缩的长度期间，<code>auto margins</code>被当作为<code>0</code></li>
<li>优先于通过<a href="http://www.w3.org/TR/css-flexbox-1/#propdef-justify-content" target="_blank" rel="external">justify-content</a>和<a href="http://www.w3.org/TR/css-flexbox-1/#propdef-align-self" target="_blank" rel="external">align-self</a>的对齐，在相应维度中任何正的可用空间被分配到<code>auto margins</code></li>
<li>溢出的盒子会忽略它们的<code>auto margins</code>，且溢出会在<a href="http://www.w3.org/TR/css-writing-modes-3/#end" target="_blank" rel="external">end</a>方向</li>
</ul>
<blockquote>
<p>要注意：如果可用空间被分发到<code>auto margins</code>，则对齐属性在这个维度上没有效果，因为在伸缩后<code>margins</code>偷走了所有到可用空间。</p>
</blockquote>
<p><strong>实例：</strong></p>
<p>一种<code>auto</code>的<code>margins</code>是在主轴上将伸缩项目清晰的分成组。下面的例子展示了如何使用它去模仿一个通用的<code>UI</code>图案－一个有许多动作的单一栏有一些左对齐，另外的右对齐。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line"><span class="tag">nav</span> &gt; <span class="tag">ul</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="tag">nav</span> &gt; <span class="tag">ul</span> &gt; <span class="tag">li</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">min-width</span>:<span class="value"> min-content</span></span>;</span><br><span class="line">  <span class="comment">/* Prevent items from getting too small for their content. */</span></span><br><span class="line">&#125;</span></span><br><span class="line"><span class="tag">nav</span> &gt; <span class="tag">ul</span> &gt; <span class="id">#login</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> auto</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=/<span class="attribute">about</span>&gt;</span>About<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=/<span class="attribute">projects</span>&gt;</span>Projects<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=/<span class="attribute">interact</span>&gt;</span>Interact<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">id</span>=<span class="value">'login'</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=/<span class="attribute">login</span>&gt;</span>Login<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">nav</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="8-2_轴对齐：justify-content属性">8.2 轴对齐：<code>justify-content</code>属性</h3><ul>
<li>名称：<code>justify-content</code></li>
<li>取值：<code>flex-start | flex-end | center | space-between | space-around</code></li>
<li>初始值：<code>flex-start</code></li>
<li>应用于：伸缩容器</li>
<li>继承：无</li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<p><code>justify-content</code>属性沿着伸缩容器当前行的<a href="http://www.w3.org/TR/css-flexbox-1/#main-axis" target="_blank" rel="external">主轴</a>来对齐项目。当任何伸缩长度和任何<a href="http://www.w3.org/TR/css-flexbox-1/#auto-margins" target="_blank" rel="external">auto margins</a>被解析后，会被执行。通常情况下，当在一行中的任何伸缩项目都是不可伸缩的或者是可伸缩但达到了它们的最大尺寸时，它会帮助分配剩余的额外空间。当项目溢出行时，它也施加了一些控制在项目对对齐上。</p>
<p>属性取值就不翻译了，看个图片就明白了：</p>
<p><img src="http://www.w3.org/TR/css-flexbox-1/images/flex-pack.svg" alt="enter image description here"></p>
<h3 id="8-3_侧轴对齐：align-items和align-self属性">8.3 侧轴对齐：<code>align-items</code>和<code>align-self</code>属性</h3><p><strong>align-items：</strong></p>
<ul>
<li>名称：<code>align-items</code></li>
<li>取值：<code>flex-start | flex-end | center | baseline | stretch</code></li>
<li>初始值：<code>stretch</code></li>
<li>应用于：伸缩容器</li>
<li>继承：无</li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<p><strong>align-self：</strong></p>
<ul>
<li>名称：<code>align-self</code></li>
<li>取值：<code>auto | flex-start | flex-end | center | baseline | stretch</code></li>
<li>初始值：<code>auto</code></li>
<li>应用于：伸缩项目</li>
<li>继承：无</li>
<li>媒体：视觉</li>
<li>计算值：<code>auto</code>的计算值是父亲的<code>align-items</code>属性值，否则为指定的值</li>
</ul>
<p>伸缩项目可以在伸缩容器当前行的侧轴上对齐，类似于<code>justify-content</code>，只是在垂直方向上。<code>align-items</code>为伸缩容器的项目设置了默认的对齐方式，包括匿名的伸缩项目。在单独的伸缩项目上<code>align-self</code>则允许默认的对齐方式被覆盖。</p>
<p>如果任何伸缩项目的侧轴的<code>margins</code>为<code>auto</code>，则<code>align-self</code>的设置没有效果。</p>
<p>下面还是用一个图片来看看各属性值的意义：</p>
<p><img src="http://www.w3.org/TR/css-flexbox-1/images/flex-align.svg" alt="enter image description here"></p>
<h3 id="8-4_align-content属性">8.4 <code>align-content</code>属性</h3><ul>
<li>名称：<code>align-content</code></li>
<li>取值：<code>flex-start | flex-end | center | space-between | space-around | stretch</code></li>
<li>初始值：<code>stretch</code></li>
<li>应用于：多行的伸缩容器</li>
<li>继承：无</li>
<li>媒体：视觉</li>
<li>计算值：指定的值</li>
</ul>
<p>当在侧轴上有额外的空间时，<code>align-content</code>属性是对齐在伸缩容器中的伸缩行，类似于<code>justify-content</code>在主轴上对齐单个的伸缩项目。要注意的是，当<strong>伸缩容器只有一行时</strong>，该属性是没有效果的。</p>
<p>属性值的意义看下图啦：</p>
<p><img src="http://www.w3.org/TR/css-flexbox-1/images/align-content-example.svg" alt="enter image description here"></p>
<h3 id="8-5_Flex基线（Flex_Baselines）">8.5 <code>Flex</code>基线（Flex Baselines）</h3><p>伸缩容器的基线由以下来决定：</p>
<p><strong>主轴基线</strong></p>
<ol>
<li>如果伸缩项目中的任何一个伸缩项目的第一行参与到了<a href="http://www.w3.org/TR/css-flexbox-1/#baseline-participation" target="_blank" rel="external">基线对齐</a>，伸缩容器的主轴基线是这些项目的伸缩基线</li>
<li>否则，如果伸缩容器有至少一个伸缩项目，它的第一个伸缩项目有一个平行于伸缩容器主轴的基线，则伸缩容器的主轴基线就是那个基线</li>
<li>否则，伸缩容器的主轴基线由第一个项目的内容盒子来合成，或者如果那个失败了，则由伸缩容器的内容盒子来合成</li>
</ol>
<p><strong>侧轴基线</strong></p>
<ol>
<li>如果伸缩容器至少有一个伸缩项目，且它的第一个伸缩项目有一个平行于伸缩容器侧轴的基线，则伸缩容器的侧轴基线就是那个基线</li>
<li>否则，伸缩容器的侧轴基线由第一个项目的内容盒子来合成，或者如果那个失败了，则由伸缩容器的内容盒子来合成</li>
</ol>
<p>当根据上面的规则来计算基线时，如果盒子贡献了基线且它有一个<code>overflow</code>的值允许滚动时，这个盒子在决定基线时必须认为它在初始的滚动位置。</p>
<p>当决定一个<code>table cell</code>的基线时，一个伸缩容器提供了类似于行框（line box）或<code>table-row</code>所做的那样的基线。</p>
<h2 id="9_Flex布局算法">9 Flex布局算法</h2><h2 id="10_分割Flex布局">10 分割Flex布局</h2><p>// todo</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/CSS/">CSS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/CSS3/">CSS3</a><a href="/tags/Flexbox/">Flexbox</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/01/13/css-flexbox/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/01/13/css-flexbox/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/07/css3-media-query/" title="CSS3 Media Query" itemprop="url">CSS3 Media Query</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://cookfront.github.io/about" title="cookfront@gmail.com" target="_blank" itemprop="author">cookfront@gmail.com</a>
		
  <p class="article-time">
    <time datetime="2015-01-07T03:47:42.000Z" itemprop="datePublished"> 發表於 2015-01-07</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>2015年的第一篇文章，新的一年更加努力的学习前端，重新开始，之前翻译的文章以及自己写的和一些笔记都放在了这里<a href="https://github.com/cookfront/learn-note/tree/master/blog-backup/2014" target="_blank" rel="external">2014‘s Blog</a>。</p>
<p>下面就进入正题了，这篇文章主要是<a href="http://www.w3.org/TR/css3-mediaqueries/" target="_blank" rel="external">W3C官方 Media Query</a>的一个学习和翻译。主要还是为了以后脑子不好使，可以回过头来看看复习复习。</p>
<h2 id="摘要和背景">摘要和背景</h2><p>在<code>HTML4</code>和<code>CSS2</code>只支持对于不同的<a href="http://www.w3.org/TR/CSS2/media.html" target="_blank" rel="external">媒体类型</a>来设置样式，例如一个文档在屏幕（screen）上显示时使用<code>sans-serif</code>字体，而在打印（print）时使用<code>serif</code>字体，这里的<code>screen</code>和<code>print</code>是定义好的两种媒体类型。而<code>Media Query</code>扩充了<code>Media Type</code>的功能，并且使我们能够更精准的应用样式表。</p>
<p>例如，在<code>HTML4</code>中：</p>
<p><strong>实例一</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">type</span>=<span class="value">"text/css"</span> <span class="attribute">media</span>=<span class="value">"screen"</span> <span class="attribute">href</span>=<span class="value">"sans-serif.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">type</span>=<span class="value">"text/css"</span> <span class="attribute">media</span>=<span class="value">"print"</span> <span class="attribute">href</span>=<span class="value">"serif.css"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者：</p>
<p><strong>实例二</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">media</span> screen </span>&#123;</span><br><span class="line">  * <span class="rules">&#123; <span class="rule"><span class="attribute">font-family</span>:<span class="value"> sans-serif &#125;</span><br><span class="line">&#125;</span></span></span></span><br></pre></td></tr></table></figure>
<p>一个<code>Media Query</code>包含了一个<code>Media Type</code>以及0个或多个来检查特定的媒体特性条件的表达式。在这些媒体特性中能在<code>Media Query</code>中被使用的是<code>width</code>，<code>height</code>和<code>color</code>。通过使用<code>Media Query</code>，页面的呈现可以在特定的终端中显示，而不需要去改变内容。</p>
<h2 id="兼容性">兼容性</h2><p>在了解<code>Media Query</code>之前需要了解浏览器对它的支持情况，以便在项目中更好的使用。可以在这里看到<a href="http://caniuse.com/#search=media%20query" target="_blank" rel="external">Media Query</a>对于浏览器的一个支持情况。对于IE永远是坑爹的，它只有在<code>IE8+</code>才支持<code>Media Query</code>。</p>
<p>那么在不支持的情况下有什么办法呢，社区的大牛给我们提供了<a href="https://github.com/scottjehl/Respond" target="_blank" rel="external">Respond.js</a>，它可以支持<code>IE8</code>及以下的浏览器。</p>
<h2 id="Media_Queries">Media Queries</h2><p>就如上面摘要提到的，一个<code>Media Query</code>包含了一个<code>Media Type</code>以及0个或多个来检查特定的媒体特性条件的表达式。</p>
<p>在本节中有关媒体<code>Media Query</code>的声明我们假设遵循了下面的<a href="#%E8%AF%AD%E6%B3%95">语法</a>章节。没有遵循语法的<code>Media Query</code>将在<a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a>章节讲到。</p>
<p><strong>实例三：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"screen and (color)"</span> <span class="attribute">href</span>=<span class="value">"example.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个实例表达了一个确定的样式表（example.css）应用于一个确定的媒体类型（screen）以及确定的特性（必须为彩色屏幕）</p>
<p><strong>实例四：</strong></p>
<p>对于上面的实例三，我们也可以用<code>@import</code>语句：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">import</span> <span class="function">url</span>(color.css) screen and (color)</span>;</span><br></pre></td></tr></table></figure>
<p>一个<code>media queries</code>是一个逻辑表达式，它可能为真也可能为假。<code>media queries</code>为真当媒体类型匹配当前正在运行的用户代理所在设备的媒体类型，且在<code>media queries</code>中所有表达式为真时，我们的<code>media queries</code>就为真。</p>
<p>对于媒体类型为<code>all</code>的<code>media queries</code>有一种简写法，也就是只有<code>@media and ()...</code>：</p>
<p><strong>实例五：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 以下两个样式表是等价的 */</span></span><br><span class="line"><span class="at_rule">@<span class="keyword">media</span> all and (min-width:<span class="number">500px</span>) </span>&#123; … &#125;</span><br><span class="line"><span class="at_rule">@<span class="keyword">media</span> (min-width:<span class="number">500px</span>) </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下两个样式表是等价的 */</span></span><br><span class="line"><span class="at_rule">@<span class="keyword">media</span> (orientation: portrait) </span>&#123; … &#125;</span><br><span class="line"><span class="at_rule">@<span class="keyword">media</span> all and (orientation: portrait) </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p>许多的<code>media queries</code>可以构成一个媒体查询列表。对于以逗号分隔的<code>media queries</code>，只要其中一个或多个为<code>true</code>时我们的列表就为真，否则为<code>false</code>，在<code>media queries</code>语法中，逗号代表了逻辑或，而<code>and</code>关键字代表了逻辑与。</p>
<p><strong>实例六：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">media</span> screen and (color), projection and (color) </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p>如果媒体查询列表为空（或者说为空字符串或空白），它将被认为为真：</p>
<p><strong>实例七：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">media</span> all </span>&#123; … &#125;</span><br><span class="line"><span class="at_rule">@<span class="keyword">media</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p>逻辑否可以通过<code>not</code>关键字。其实就是和编程一样啦，大家懂的，加上了<code>not</code>，假就是真，真就是假。</p>
<p><strong>实例八：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"not screen and (color)"</span> <span class="attribute">href</span>=<span class="value">"example.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>关键字<code>only</code>是用于隐藏老的用户代理的样式表。它的功能仅仅在于此了。而对于其他用户代理，处理以<code>only</code>开头的<code>media queries</code>时，要像<code>only</code>不存在一样。</p>
<p><strong>实例九：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"only screen and (color)"</span> <span class="attribute">href</span>=<span class="value">"example.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>media queries</code>语法可以用于<code>HTML</code>、<code>XHTML</code>、<code>XML</code>和<code>CSS</code>规则等<code>@media</code>和<code>@import</code>中。</p>
<p><strong>实例十：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> media=<span class="string">"screen and (color), projection and (color)"</span> rel=<span class="string">"stylesheet"</span> href=<span class="string">"example.css"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> media=<span class="string">"screen and (color), projection and (color)"</span> rel=<span class="string">"stylesheet"</span> href=<span class="string">"example.css"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;?xml-stylesheet media=<span class="string">"screen and (color), projection and (color)"</span> rel=<span class="string">"stylesheet"</span> href=<span class="string">"example.css"</span> ?&gt;</span><br><span class="line"></span><br><span class="line">@<span class="function">import <span class="title">url</span><span class="params">(example.css)</span> screen <span class="title">and</span> <span class="params">(color)</span>, projection <span class="title">and</span> <span class="params">(color)</span></span>;</span><br><span class="line"></span><br><span class="line">@<span class="function">media screen <span class="title">and</span> <span class="params">(color)</span>, projection <span class="title">and</span> <span class="params">(color)</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p>如果有一个媒体特性没有应用到当前正在运行的用户代理的设备上时，包含该表达式的媒体特性讲为假。</p>
<p><strong>实例十一：</strong></p>
<p>媒体特性<code>device-aspect-ratio</code>只应用于视觉设备，所以对于音频设备该表达式将永远为<code>false</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> media=<span class="string">"aural and (device-aspect-ratio: 16/9)"</span> href=<span class="string">"example.css"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>如果衡量单位没有应用于当前设备，表达式也将永远为<code>false</code>。</p>
<p><strong>实例十二：</strong></p>
<p><code>px</code>没有应用于<code>speech</code>媒体类型，所以下面的媒体查询将永远为<code>false</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> media=<span class="string">"speech and (min-device-width: 800px)"</span> href=<span class="string">"example.css"</span> /&gt;</span><br></pre></td></tr></table></figure>
<h2 id="语法">语法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">media_query_list</span><br><span class="line"> : S* [media_query [ <span class="string">','</span> S* media_query ]* ]?</span><br><span class="line"> ;</span><br><span class="line">media_query</span><br><span class="line"> : [ONLY | NOT]? S* media_type S* [ AND S* expression ]*</span><br><span class="line"> | expression [ AND S* expression ]*</span><br><span class="line"> ;</span><br><span class="line">media_type</span><br><span class="line"> : IDENT</span><br><span class="line"> ;</span><br><span class="line">expression</span><br><span class="line"> : <span class="string">'('</span> S* media_feature S* [ <span class="string">':'</span> S* expr ]? <span class="string">')'</span> S*</span><br><span class="line"> ;</span><br><span class="line">media_feature</span><br><span class="line"> : IDENT</span><br><span class="line"> ;</span><br></pre></td></tr></table></figure>
<h2 id="错误处理">错误处理</h2><p>对于不遵循用户代理的<code>media queries</code>需要遵守本节中描述的规则。</p>
<ul>
<li>未知媒体类型：未知媒体类型被计算为<code>false</code>。它可以有效的被认为是不匹配当前设备类型的媒体类型。</li>
<li>未知媒体特性：当某个指定的媒体特性不知道时，用户代理将媒体查询相当于<code>not all</code></li>
</ul>
<p><strong>实例十五：</strong></p>
<p>在这个例子中，第一个媒体查询将相当于<code>not all</code>，并且计算为<code>false</code>，第二个媒体查询计算时就好像第一个媒体查询不存在。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"screen and (max-weight: 3kg) and (color), (color)"</span> <span class="attribute">href</span>=<span class="value">"example.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>未知媒体特性值：和未知媒体特性一样，用户代理会将媒体查询相当于<code>not all</code>，当某个媒体特性值不知道时。</li>
</ul>
<p><strong>实例：</strong></p>
<p>因为在<code>max-width</code>中负值是不允许的，所以相当于<code>not all</code></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">media</span> (min-width: -<span class="number">100px</span>) </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>畸形的媒体查询：具有意外的<code>token</code>的媒体查询相当于<code>not all</code>。</li>
</ul>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">media</span> (example, all,), speech </span>&#123; <span class="comment">/* only applicable to speech devices */</span> &#125;</span><br><span class="line"><span class="at_rule">@<span class="keyword">media</span> &amp;test, screen           </span>&#123; <span class="comment">/* only applicable to screen devices */</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="媒体特性">媒体特性</h2><p>在句法上，媒体特性类似于<code>CSS</code>属性：它们有名字并且接受确定的值。然而，属性和媒体特性之间也有几点重要到不同：</p>
<ul>
<li>属性被用于声明给文档提供信息从而如何呈现文档。而媒体特性则是一些表达式用于描述对于输出设备的要求。</li>
<li>许多的媒体特性能够接受可选的<code>min-</code>和<code>max-</code>前缀来表达<code>大于等于</code>或<code>小于等于</code>。这种语法的使用是为了阻止<code>&lt;</code>和<code>&gt;</code>字符与<code>HTML</code>和<code>XML</code>冲突。这些媒体特性经常使用前缀来使用，当然也会单独使用了。</li>
<li>属性总是需要一个值才能形成一个声明，另一方面，媒体特性也能不需要值。对于一个媒体特性，如果<code>(feature: x)</code>有一个值<code>x</code>，且<code>x</code>是除了0或0加上一个单位的值时，则<code>(feature)</code>会计算为<code>true</code>。而对于使用<code>min-</code>和<code>max-</code>前缀的媒体特性则必须使用一个值。当一个媒体特性用到了<code>min-</code>和<code>max-</code>前缀时，这会被认为是一个畸形的媒体查询。</li>
<li>属性可以接收更多复杂的值，例如，通过其他值计算出来的值。而媒体特性只能接受单一的值：一个关键字、一个数字或者一个数字带有一个单位。</li>
</ul>
<h3 id="width">width</h3><ul>
<li>取值：<code>&lt;length&gt;</code></li>
<li>应用于：视觉或触觉媒体类型</li>
<li>接受<code>min/max</code>前缀：是</li>
</ul>
<p><code>width</code>媒体特性描述了输出设备目标显示区域的宽度。对于一个连续媒体，这个就是视口(<code>viewport</code>)的宽度，并且包含了滚动条的宽度（如果有的话）。对于分页媒体，这是页框的宽度。</p>
<p>需要注意的是，<code>&lt;length&gt;</code>不能为负值。</p>
<p><strong>实例：</strong></p>
<p>下面的实例说明样式表只能应用于打印输出大于25cm的设备。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"print and (min-width: 25cm)"</span> <span class="attribute">href</span>=<span class="value">"http://…"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>实例：</strong></p>
<p>这个实例说明样式表只能应用于视口宽度在<code>400px</code>和<code>700px</code>之间的设备。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">media</span> screen and (min-width: <span class="number">400px</span>) and (max-width: <span class="number">700px</span>) </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p><strong>实例：</strong></p>
<p>这个实例说明样式应用于<code>handheld</code>和<code>screen</code>媒体类型，且最小宽度为<code>20em</code>，<code>em</code>是相对于初始的<code>font-size</code>值。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">media</span> handheld and (min-width: <span class="number">20em</span>), </span><br><span class="line">  screen and (min-width: <span class="number">20em</span>) </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<h3 id="height">height</h3><ul>
<li>取值：<code>&lt;length&gt;</code></li>
<li>应用于：视觉或触觉媒体类型</li>
<li>接受<code>min/max</code>前缀：是</li>
</ul>
<p><code>height</code>媒体特性和<code>width</code>几乎一样（但是height不常用），只是宽度与高度的区别，它同样包含了页面的水平方向滚动条的高度（如果有的话）。</p>
<p>负值也是不允许对。</p>
<h3 id="device-width">device-width</h3><ul>
<li>取值：<code>&lt;length&gt;</code></li>
<li>应用于：视觉或触觉媒体类型</li>
<li>接受<code>min/max</code>前缀：是</li>
</ul>
<p><code>device-width</code>媒体特性描述的是输出设备呈现表面的宽度（和<code>width</code>还是有很大区别的，对于连续媒体，<code>width</code>是指视口的宽度）。对于连续媒体，<code>device-width</code>指的是屏幕的宽度，对于分页媒体，这是页面纸张尺寸的宽度。</p>
<p>负值是不允许的。</p>
<p><code>device-width</code>一般是用于移动端。</p>
<p>实例：</p>
<p>下面的例子表明样式表应用于媒体类型为<code>screen</code>，且水平宽度为<code>800px</code>的设备。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">media</span> screen and (device-width: <span class="number">800px</span>) </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<h3 id="device-height">device-height</h3><ul>
<li>取值：<code>&lt;length&gt;</code></li>
<li>应用于：视觉或触觉媒体类型</li>
<li>接受<code>min/max</code>前缀：是</li>
</ul>
<p><code>device-height</code>媒体特性描述的是输出设备呈现表面的高度。对于连续的媒体，这是屏幕的高度。对于分页媒体，这是页面纸张尺寸的高度。</p>
<p>负值是不允许的。</p>
<p><strong>实例：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"screen and (device-height: 600px)"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="orientation">orientation</h3><ul>
<li>取值：<code>portrait | landscape</code></li>
<li>应用于：位图媒体类型</li>
<li>接受<code>min/max</code>前缀：否</li>
</ul>
<p><code>orientation</code>一般是用于检测移动端是横向还是竖向的。当<code>height</code>的值大于等于<code>width</code>的媒体特性值时，<code>orientation</code>的值为<code>portrait</code>，否则为<code>landscape</code>。</p>
<p>实例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">media</span> all and (orientation:portrait) </span>&#123; … &#125;</span><br><span class="line"><span class="at_rule">@<span class="keyword">media</span> all and (orientation:landscape) </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<h3 id="aspect-ratio">aspect-ratio</h3><ul>
<li>取值：<code>&lt;value&gt;</code></li>
<li>应用于：位图媒体类型</li>
<li>接受<code>min/max</code>前缀：是</li>
</ul>
<p><code>aspect-ratio</code>描述了输出设备目标显示区域的宽高比。该值包含两个以<code>/</code>分隔的正整数。代表了水平像素数（第一个值）与垂直像素数（第二个值）的比例。</p>
<p><strong>实例：</strong></p>
<p>下面为显示区域宽高至少为一比一的设备选择了一个特殊的样式表。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">media</span> screen and (min-aspect-ratio: <span class="number">1</span>/<span class="number">1</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h3 id="device-aspect-ratio">device-aspect-ratio</h3><ul>
<li>取值：<code>&lt;value&gt;</code></li>
<li>应用于：位图媒体类型</li>
<li>接受<code>min/max</code>前缀：是</li>
</ul>
<p>这个和<code>aspect-ratio</code>很类似，描述的是输出设备的宽高比。该值包含两个以<code>/</code>分隔的正整数。代表了水平像素数（第一个值）与垂直像素数（第二个值）的比例。</p>
<p><strong>实例：</strong></p>
<p>例如，如果一个设备的屏幕媒体特性中，宽度为<code>1280px</code>，高度为<code>720px</code>，也就是等于<code>16/9</code>，则以下的所有媒体查询将匹配它：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">media</span> screen and (device-aspect-ratio: <span class="number">16</span>/<span class="number">9</span>) </span>&#123; … &#125;</span><br><span class="line"><span class="at_rule">@<span class="keyword">media</span> screen and (device-aspect-ratio: <span class="number">32</span>/<span class="number">18</span>) </span>&#123; … &#125;</span><br><span class="line"><span class="at_rule">@<span class="keyword">media</span> screen and (device-aspect-ratio: <span class="number">1280</span>/<span class="number">720</span>) </span>&#123; … &#125;</span><br><span class="line"><span class="at_rule">@<span class="keyword">media</span> screen and (device-aspect-ratio: <span class="number">2560</span>/<span class="number">1440</span>) </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<h3 id="color">color</h3><ul>
<li>取值：<code>&lt;integer&gt;</code></li>
<li>应用于：视觉媒体类型</li>
<li>接受<code>min/max</code>前缀：是</li>
</ul>
<p><code>color</code>指定输出设备每个像素单元的比特值。如果设备不支持输出颜色，则该值为0。</p>
<p><code>&lt;integet&gt;</code>不能为负值。</p>
<p>这个媒体特性用的也是比较少的。</p>
<p><strong>实例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">media</span> all and (color) </span>&#123; … &#125;</span><br><span class="line"><span class="at_rule">@<span class="keyword">media</span> all and (min-color: <span class="number">1</span>) </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<h3 id="color-index">color-index</h3><ul>
<li>取值：<code>&lt;integer&gt;</code></li>
<li>应用于：视觉媒体类型</li>
<li>接受<code>min/max</code>前缀：是</li>
</ul>
<p><code>color-index</code>指定了输出设备中颜色查询表中的条目数量。</p>
<p><strong>实例：</strong></p>
<p>向所有使用至少256个索引颜色的设备应用样式表：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel="stylesheet" media="all and (min-color-index: 256)" href="http://foo.bar.com/stylesheet.css" /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="monochrome">monochrome</h3><ul>
<li>取值：<code>&lt;integer&gt;</code></li>
<li>应用于：视觉媒体类型</li>
<li>接受<code>min/max</code>前缀：是</li>
</ul>
<p>指定了一个黑白（灰度）设备每个像素的比特数。如果不是黑白设备，值为0。</p>
<p><strong>实例：</strong></p>
<p>向每个像素至少8比特的黑白设备应用样式表：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">media</span> all and (min-monochrome: <span class="number">8</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h3 id="resolution">resolution</h3><ul>
<li>取值：<code>&lt;resolution&gt;</code></li>
<li>应用于：位图媒体类型</li>
<li>接受<code>min/max</code>前缀：是</li>
</ul>
<p><code>resolution</code>指定输出设备的分辨率（像素密度）。分辨率可以用每英寸（dpi）或每厘米（dpcm）的点数来表示。</p>
<p><strong>实例：</strong></p>
<p>为每英寸至多300点的打印机应用样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">media</span> print and (min-resolution: <span class="number">300dpi</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h3 id="scan">scan</h3><ul>
<li>取值：<code>progressive | interlace</code></li>
<li>应用于：<code>tv</code>媒体类型</li>
<li>接受<code>min/max</code>前缀：否</li>
</ul>
<p><code>scan</code>描述了电视输出设备的扫描过程。</p>
<p><strong>实例：</strong></p>
<p>向以顺序方式扫描的电视机上应用样式表：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">media</span> tv and (scan: progressive) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h3 id="grid">grid</h3><ul>
<li>取值：<code>&lt;integer&gt;</code></li>
<li>应用于：视觉或触觉媒体类型</li>
<li>接受<code>min/max</code>前缀：否</li>
</ul>
<p><code>grid</code>判断输出设备是网格设备还是位图设备。如果设备是基于网格的（例如电传打字机终端或只能显示一种字形的电话），该值为1，否则为0。</p>
<p>对于<code>grid</code>，有效的值只有<code>1</code>和<code>0</code>。其他一切都会创建一个畸形都媒体查询。</p>
<p><strong>实例：</strong></p>
<p>向一个15字符宽度或更窄的手持设备应用样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">media</span> handheld and (grid) and (max-width: <span class="number">15em</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>标准中还包括了一些值、单位的介绍，这里就不一一说了，具体还是<a href="http://www.w3.org/TR/css3-mediaqueries/" target="_blank" rel="external">点我吧</a></p>
<p>需要看媒体查询的一些例子，可以看看这里：<a href="http://mediaqueri.es/" target="_blank" rel="external">http://mediaqueri.es/</a></p>
<p>还可以看看W3Cplus的文章：<a href="http://www.w3cplus.com/content/css3-media-queries" target="_blank" rel="external">http://www.w3cplus.com/content/css3-media-queries</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/CSS/">CSS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/CSS3/">CSS3</a><a href="/tags/Media-Query/">Media Query</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/01/07/css3-media-query/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/01/07/css3-media-query/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







</div>
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分類</p>
		<ul>
		
		  
			<li><a href="/categories/CSS/" title="CSS">CSS<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript/" title="JavaScript">JavaScript<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>2</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">標簽</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/CSS3/" title="CSS3">CSS3<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS/" title="iOS">iOS<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Flexbox/" title="Flexbox">Flexbox<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/JavaScript/" title="JavaScript">JavaScript<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Transform/" title="Transform">Transform<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Media-Query/" title="Media Query">Media Query<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Animation/" title="Animation">Animation<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/selector/" title="selector">selector<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情鏈接</p>
    <ul>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 訂閱</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> keep coding <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/https://github.com/cookfront" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:cookfront@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="http://cookfront.github.io/about" target="_blank" title="cookfront@gmail.com">cookfront@gmail.com</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"cookfront"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 









<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F1e9fdadfaa36dffc9a8914a1220e8161' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回頂部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
